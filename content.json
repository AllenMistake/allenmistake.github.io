[{"title":"欢迎来到泰兰德","date":"2024-06-15T03:55:21.000Z","path":"2024/06/15/WelcomeToThailand/","text":"突如其来的出差突然一下子接到通知，端午节过后就要来泰国出差了，起初知道这个事情的时候还是激动大于忐忑，但是经过一段时间（其实并不允许有太多时间去反应就是了）思考，思绪还是比较复杂的，毕竟要在泰国待很久，自己要去的地方又不是曼谷这种大城市，会有诸多的不适应。不过也还好，对于已经习惯出差的我来说，泰国也许就是到了一个很南方的地方，周围的同事都讲中文，除了工作上有新的任务需要熟悉之外，基本上没有什么太大差别，不过如果试图去接触外界，那恐怕是很难的，在泰国生活，特别是在泰国不是很发达的小城市生活，需要克服的苦难还是比较多的 首先来讲，一个foreigner，在国外难过的一关就是语言关，泰语终归来说还算小众，不过这边很多人还是会讲英语的，可惜我的英文水平也不高，只能一个单词一个单词的往外蹦，想要练成句子的话要很费劲，对于我和听的人都是一种折磨。我尝试去视频网站学习泰语，知道泰语有五个声调，在听到这五个声调的区别后，我毫不犹豫的放弃了，后来转变了一下思路，要不就干脆学习泰文吧，看了看视频教学，觉得上手也还是难了一些，也放弃了。 最终还是决定少和外界沟通。 语言不通带来的影响远比我想象的大，这里商品是泰文，路标是泰文，就连涂鸦也是泰文。这时候发现其实身处国外比自己想的要更艰难一些。由此带来的第二个困难就是孤独感，陌生的街道，陌生的人，陌生的动物，都仿佛在你周遭扣了一个无形的罩子，这个罩子让你感到喘不上气，在国内，总看见说每个人都是一座孤岛，但我想，在国外这种环境下才算是真的孤岛，孤独感如同洪水猛兽般袭来的时候，想起来王建国的那期去聊孤独 “因为孤独是我在这个世界上最爱的东西，也是唯一爱的东西” 孤独分为绝对孤独和屈从性孤独，还有认知障碍性孤独和主观迷幻性孤独。我想我大概是属于屈从性孤独吧，不属于王建国爱的那一种孤独，亦或者是很多种孤独叠加在一起？ 说了半天差点聊跑题，第三个就是泰国实在是太潮湿了，作为热带国家，日晒+湿气使得你在这边稍微运动量大一些就会出一脑门+一后背的汗，及时补充水分盐分成了必修课，并且一些补水晒后修复的洗护产品也变得尤为关键，Lotus超市速度安排上。 与Pak Chong的邂逅当我第一次来到泰国巴冲这个小县城时，心中充满了未知和好奇。从喧闹的大城市突然来到这个宁静而朴素的小地方，仿佛一下子被抛入了另一个世界。 下了飞机，走出机场的那一刻，迎面而来的热浪让我一下子意识到这里的气候与家乡的差别。阳光明晃晃地洒在地上，空气中弥漫着一股浓郁的热带植物的气息。机场外的马路不宽，两边种满了椰子树和不知名的灌木，显得有些杂乱，却也透着一股原始的生机。 一路颠簸到了巴冲，映入眼帘的是一片低矮的平房和简陋的店铺。街道并不宽敞，路旁是一些小摊贩，摆卖着新鲜的水果和各种当地小吃。卖货的阿姨们穿着五颜六色的传统服饰，热情地招呼着每一个路过的行人。孩子们在街边嬉戏打闹，脸上洋溢着纯真的笑容。 住的地方是一家当地的小旅馆，设施虽然简陋，但老板一家非常热情好客。他们用并不流利的英语和我交流，尽力让我感到宾至如归。房间里的家具都是木制的，显得有些陈旧，但却打扫得十分干净。晚上，躺在床上，听着窗外不时传来的昆虫鸣叫声和远处传来的犬吠声，心情渐渐平静下来。 每天早晨醒来，伴随着鸡鸣声，我会走到街上，感受这个小县城独特的早晨。街道上的小贩们已经开始了一天的忙碌，空气中弥漫着刚刚出炉的烤肉和热汤的香味。当地人用简朴的三轮车和摩托车代步，载着满满的货物，穿梭在狭窄的街巷间，忙碌而有序。 巴冲虽然落后，却有着自己独特的魅力。这里的人们过着简单而满足的生活，他们的热情和善良让我在异乡感受到了一丝温暖。每一个微笑，每一句简单的问候，都让我觉得这个小县城并不陌生。虽然远离了都市的繁华和便捷，但在这里，我找到了另一种宁静和自在。 –以上内容出自GPT，描述的还是比较准确的，甚至有些地方很细节，也很贴合实际，不得不感叹AI的强大。 有一个事情需要补充的，这几天下班，错过了两次班车，好巧不巧，遇到的都是同一个大叔送我回去，一次是用摩托，一次是用汽车，这个地方没有个交通工具真是寸步难行，也感受到了泰国人的热情，真的很感谢他。 目前感受就那么多，之后有什么特别的感悟再说","tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"http://www.allenmistake.top/tags/碎碎念/"}]},{"title":"marryChristmas","date":"2022-12-24T13:15:09.000Z","path":"2022/12/24/marryChristmas/","text":"“The Cake is A Lie”不知道怎么，突然想到了这一句著名台词，","tags":[]},{"title":"哈喽啊，我回来了","date":"2022-09-08T04:24:54.000Z","path":"2022/09/08/HelloMyNameIsZhang/","text":"#归来测试一下","tags":[]},{"title":"小张回家了（假装很高兴）","date":"2021-01-31T10:30:06.000Z","path":"2021/01/31/BackHome/","text":"田园将芜胡不归距离疫情爆发已经一年多的时间了，可是回家这件事情还是很难。 政策制定的都很人性了，其实还是不放心自己在家能不能把论文搞出来，今天特意来星巴克里面来找找学习的感觉，不得不说，我觉得除了家，任何一个有电源和暖气的地方都可以学习，没想到在这种嘈杂的环境中下还能投入 真是奇怪，卧室那么安静的地方学不下去，在嘈杂的咖啡馆里竟能码字神速。 之前在学校的时候一直纠结要不要回家，周围的小伙伴很多也选择了留校，毕竟研三了，论文高于一切。 大概是想换个环境吧，真不想在学校待了，压力有些大。 Balance其实，在我的潜意识里，一定是害怕过年的，过年意味着各种问候，各种聚会。对于我这种喜欢远离喧嚣的人来说，是极其排斥这种感觉的，我的理想状态是一个很隔绝的状态，这样才能静下来，去看看书也好，看看电影也好。 而且都已经回家了，必须为家里面贡献一些劳动力啊，北方的习俗还是很多的，又要贴各种福字吊钱，又要扫房。 给自己定个小目标吧，小年是哪天来着？控制好学习、娱乐之间的平衡吧 还有一本好不容易带回家的《日本史》，这个寒假不知道能不能读完 var ap = new APlayer({ element: document.getElementById(\"aplayer-ZcAJIEuS\"), narrow: false, autoplay: true, showlrc: false, music: { title: \"双门洞/惠化洞（口琴版）\", author: \"Tenholes蓝调口琴/园园\", url: \"双门洞.mp3\", pic: \"/2021/01/31/BackHome/dong.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","tags":[]},{"title":"告别意味着新的开始","date":"2021-01-01T03:28:42.000Z","path":"2021/01/01/newYear2021/","text":"2020很难描述我的2020年，因为疫情的原因发生了，上半年变得零零散散，感觉什么都干了， 比如学习做菜，开车上路… 可又感觉自己什么也没干，就好像一个人把屋子装饰的再怎么好，他还是没有走出那个屋子一样。 我以为自己改变了很多，但下半年告诉我，改变一个人确实是很难的。 其实对于跨年，我的感情一直是很淡的，从小对于元旦也只是一个不痛不痒的一天假，毕竟学生放完元旦还要上课。我是一个比较传统的人，一直觉得辞旧迎新是大年三十该干的，况且每年元旦都在外面，纵使周围花团锦簇，也觉得喧嚣而已。 但不管怎么说，2020年还是很值得我们去告别的，大家好像都对于2020有很多不好的记忆，我也是，但是不得不说，2020是一个特别的年份，发生了很多类似魔幻的时间，这让我感到一种新鲜感，也许是我记事之后经历的第一个不平凡的一年吧。 得了，说多了又陷入对过去的回顾。但今天还是多说说展望吧 2021今年对我来说大概终于能从学校里面走出去了吧，想想也觉得蛮恐慌，自己很多事情还没搞清楚，就要工作了。不求能完美应对接下来的每个问题，只希望在每次应对问题之后能更走向成熟吧，年年都追求成熟，但每年都感觉自己不够成熟 论文，专利的事情最近也是忙糟糟的，希望年后都能搞定，然后顺利毕业，这大概是我今年最大的愿望了 还有朋友问我找到了什么工作，首先感谢你对我博客的关注，这种自己慢慢耕种的土地突然来一位客人的感觉还不错，其次我没有回复你是因为最近事情比较多，而且工作的事情我也在纠结，也没法给出一个确定的答案，如果你想咨询什么问题可以在下面回复，我都能看见 计划什么的，每年的计划都写读完xx本书，太空了。作为一个年度希冀，更应该放眼于一片。最近的话对于历史和纪录片非常感兴趣，下载了《河西走廊》、还有各种美食纪录片，也买了关于日本的历史，特意买了纸质的书，我觉得对于历史类的书籍还是纸质书舒服，不是说能感受到历史的厚重之类的话，只是以后放在书架上会显得很有文化。 又扯远了，所以我的年度希冀就说这么几点吧 了解更多的历史、人文，更为知识面更广的人 去大西北（至少去甘肃、青海） 录毕业Vlog 减少对于视频的依赖 之前说减少对于游戏的依赖，我发现执行的挺成功，但是感觉由游戏转到视频上了，对于文字性的东西吸收的越来越浅，这样不好，太浮躁了，希望2021能沉下心来，用微单更好的捕捉生活美好吧 过年我想再写一篇，今天就先到这里吧，总之，2020，再见 goodbye var ap = new APlayer({ element: document.getElementById(\"aplayer-oBdfHePp\"), narrow: false, autoplay: true, showlrc: false, music: { title: \"我的姑娘 她在远方\", author: \"隔壁老樊\", url: \"我的姑娘.mp3\", pic: \"/2021/01/01/newYear2021/head.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","tags":[]},{"title":"Wake Me Up When September Ends","date":"2020-10-03T11:48:08.000Z","path":"2020/10/03/WakeMeUpWhenSepEnds/","text":"time 一场秋雨一场凉，提醒大家注意天气变化，不要像我一样，闹完嗓子接着感冒。 培养爱好九月份找完工作就开始学习摄影了，可惜没有什么机会拍人像，只能拍一拍风景，其实关于拍照学习的东西还有很多，目前也只是简单的看了一下大概的摄像参数，之后的 构图思路 不同情况下的参数调整（调光圈、快门、曝光） 后期的色调与主题的呼应 都是需要去学习的，争取在过年前把这些系统学习一下，如果情况顺利的话我可能会把我的学习过程记录在这里。 之前比较随笔拍的一张，仔细看图片还有点发虚 Wake Me Up既然工作已经确定了，那剩下就要好好搞论文了~ 争取在放假之前把论文前三章写出来，应该问题不大。 还是应该读书了，十月份至少读一本书吧，其实九月份看了《乌合之众》，但是并没有看完，这个前言实在是很劝退，但是我觉得分析得很中肯，其实《乌合之众》更像是一种观察报告，译者强调了一点，他无法对未来有很强的预见作用并用《资本论》来对比，诚然《乌合之众》有它自身的魅力，不然不可能被大家推荐来推荐去，就算现在问我的态度，我还是推荐的，但我更推荐大家去批判性的看，要有自己的思考，这本书有很强的局限性。 var ap = new APlayer({ element: document.getElementById(\"aplayer-kiKOQGHs\"), narrow: false, autoplay: true, showlrc: false, music: { title: \"Wake Me up When September Ends\", author: \"Green Day\", url: \"September.mp3\", pic: \"/2020/10/03/WakeMeUpWhenSepEnds/September.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"http://www.allenmistake.top/tags/碎碎念/"}]},{"title":"找不到工作，我很抱歉","date":"2020-08-31T03:23:09.000Z","path":"2020/08/31/keepStudy/","text":"好久没有更博了，原因主要还是自己没养成习惯，不给自己找理由。也不许什么目标，我想保证每篇博客言之有物，以后有想说的干货就说一说，不管你是想看技术还是看生活感悟，希望都对大家有帮助。 春由于今年的特殊性，上半年没什么学习动力，也算是很遗憾吧，没有抓住机会，在这个疫情期间没有好好投资自己，导致自己后面的选择面变得很窄。之前做了一些项目到后来基础打的不好，算法也跟不上，很多公司也都错过了，写这篇也算是对自己的反思吧。 我的实习由于家在天津，去找了天津一个国企的实习，感受了一下国企的氛围，坦白来讲，比我想象的好一些，工资肯定没有互联网那么高，甚至低很多很多，但是性价比也还是有的，而且周围的师傅对实习生都很好。现在不是都谈内卷问题嘛，不如换个角度，找那些和自己专业不那么对口，但是可以结合自己专业，在从事的领域有一定的优势。就像冯巩老师说的一样，在相声界吉他弹得最好，在吉他界相声说的最好，一样，我觉得这其实是一种规避内卷的方式。 下半年的计划其实目前的形式还是 不简单~不简单~ 心里赞叹这世上的艰难~，岗位变少了，人数变多了。和周围的同学商量来商量去最稳的办法是读博，但我觉得读博对于我这种学术菜鸡就是一种逃避手段，还是走向社会吧，就算是博士，也是学生，终归有自身的局限性。 提升最后说几个可以提升自己的点吧，可能会有点鸡汤味道，可以理解为给我喝的，不喜欢的可以忽略这部分 延时满足老生常谈的一个能力，往更大了说就是控制自己欲望的能力，说一个简单的例子，刷某音，刷某站一些毫无营养的视频，比如什么xxx挑战，或者是那些土味，刷起来太上头，要学会控制自己，不要让他们占据你过多的时间，我们还年轻，我们的时间尽量放在提升自己上面。 执行力之前买过一本书，叫做《执行力》，记得那本书写的还蛮不错的，可惜自己的执行力在没有人监督或者没有 deadline 的情况下基本为0，要想一想怎么提高了。我现在有点讨厌那种Todo List，计划了半天，执行力不够，画再多 0 不如写个 1 个 1，对吧。 之后打算写一些在国企工作的感悟，我们下一篇再见吧 最近有个新的记笔记的，也是仿 notion ，有个比较舒服的地方就是自动排版英文（不用费劲打空格啦），如果各位注册的话，我的邀请码：NLYYJP3 。 希望各位看官能支持一下（完全随意昂，你不支持我也会更新的），为了放音乐特意办了网抑云的会员，找不到工作，我很抱歉。 最后放个锦鲤，祝看到这篇文章的人，可能你曾经困苦，但结尾苦尽甘来。 比较喜欢的一张锦鲤照片 PS.人家说放太多锦鲤照片就不灵 var ap = new APlayer({ element: document.getElementById(\"aplayer-UyxobSXd\"), narrow: false, autoplay: true, showlrc: false, music: { title: \"问问吾问问\", author: \"丛帅\", url: \"问问吾问问.mp3\", pic: \"/2020/08/31/keepStudy/问问吾问问.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"http://www.allenmistake.top/tags/碎碎念/"}]},{"title":"来点音乐~","date":"2020-06-17T09:38:53.000Z","path":"2020/06/17/musicInSummer/","text":"Summer Coming~ 夏天到了，有点闷，来点音乐~ var ap = new APlayer({ element: document.getElementById(\"aplayer-qglrBLVI\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"月半弯\", author: \"陈坤\", url: \"月半弯.mp3\", pic: \"/2020/06/17/musicInSummer/月半弯.jfif\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);","tags":[]},{"title":"雨季，总是突如其来","date":"2020-05-07T12:40:03.000Z","path":"2020/05/07/2020May/","text":"稚气前两天和初中的朋友们见了一面，感觉大家也都在各自的岗位上混得不错。有人还开了宝马过来，有点小羡慕。 到场的几个人里面，就我在读研，还是比同龄的他们多了几分稚气，不知道如何才能摆脱“工作就好啦”他们安慰道。可是我们仍然是同龄人，就因为学习就会有这种傻气吗？不见得，还是自身不行。 不了解自己，所以无法做出选择有的时候，觉得自己又到了人生的十字路口上，我也清楚每个选项，但是还是太不了解自己了，还是无法做出选择。 我们总是在想把未来的每一天过好，找到适合自己的路。可惜生活是个单行路，不能回头那种，不选择是消极的，选择的时候也不必死去活来，毕竟谁都是选择一次，高考也罢，考研也罢，专业也好，工作也好，说是很重要，也没那么一锤定音。 但有的是时候还是要浇一盆冷水给自己，因为越到后面，我们的选择的容错率越低。 只要我们还年轻，我们还有的是机会，我们是后浪。 后浪前些日子，何冰老师和bilibili联合出品的《后浪》在青年节上发布了，我满怀激情的看完了这份演讲，朋友圈也都大量转发，感悟其实有很多，那种未来就在自我掌控之中的豪情，还有广阔天地，大有作为的澎湃，前浪对我们说，尽情驰骋吧，后浪！ bilibili献给新一代的演讲《后浪》 但是，大家在转发的时候，还是引用了不同的句子，我喜欢古文，我朋友圈发的是 “君子美美与共，和而不同”，加油，致后浪，致我们。 于是抱着兼收并蓄，看看众人如何理解的心态，我去知乎，发现这里竟然大多数对这部演讲有着一些或者很多的抵触情绪。 原因有很多，有些点说的其实也蛮有道理，往商业上来讲，其实就是 bilibili 做的一个宣传片，宣传一个年轻人比较多的平台，焕发着朝气。比较多的人觉得，后浪是因前浪而赋予名字。后浪也会变成前浪，正所谓 少年不识愁滋味，爱上层楼，爱上层楼。为赋新词强说愁。而今识尽愁滋味，欲说还休，欲说还休。却道天凉好个秋。 这个事情吧，准中年人看完会流泪，晚期青年人嗤之以鼻、尚未工作的大学生兴奋不已、未成年人。————引用知乎用户 其实还有比部分观点，意思就是很多年轻人并不能接触到这些很美好的事物，回归现实，确实是这样，这里面也有很多难。但是以为这个就去否定这个片子就没必要了，还有甚者去何冰老师微博下面爆破，无奈了。","tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"http://www.allenmistake.top/tags/碎碎念/"}]},{"title":"Flutter UI绘制渲染机制分析","date":"2020-04-16T03:31:04.000Z","path":"2020/04/16/flutter-ui/","text":"渲染流程 UI渲染流程 WeightWeight 在Flutter 中是必不可少的存在，翻译过来是控件的意思，Flutter中的每一种都是一个Weight。Widget里面存储了一个视图的配置信息，包括布局、属性等待。所以它只是一份轻量的，可直接使用的数据结构。在构建为结构树，甚至重新创建和销毁结构树时都不存在明显的性能问题。 而对于渲染问题，并不是由 Weight 直接管理，而是通过State这个对象来管理状态。 123456789101112/// If you wish to associate mutable state with a widget, consider using a/// [StatefulWidget], which creates a [State] object (via/// [StatefulWidget.createState]) whenever it is inflated into an element and/// incorporated into the tree./*** Widget会被填充到Element,并由Element管理底层渲染树。* Widget本身没有可变状态（所有的字段必须是final）。* 如果想要把可变状态与Widget关联起来，可以使用StatefulWidget，* StatefulWidget通过使用StatefulWidget.createState方法创建State对象，* 并将之扩充到Element以及合并到树中；*/ 可以看到， Weight是不可变的，如果要使它成为可变状态，就不得不提到Element ElementWidget 和 Element 之间是一对多的关系 。实际上渲染树是由 Element 实例的节点构成的树，而作为配置文件的 Widget 可能被复用到树的多个部分，对应产生多个 Element 对象。 打开Element类，在里面发现了 Element 的两个重要属性widget和renderObject。 123456789101112RenderObject get renderObject&#123; RenderObject result; void visit(Element element)&#123; assert(result == null); if(element is RenderObjectElement) result = element.renderObject; else element.visitChildren(visit); &#125; visit(this); return result;&#125; 也就是说Element同时持有了Widgets和RenderObject。那Element的作用就比较明确了，Element作为中间件来分离控件树和渲染对象。 RenderObject官方定义：An object in the render tree.渲染树中的一个对象。从其名字，我们可以很直观地知道，它就是负责渲染的工作，实际上，所有的布局、绘制和事件响应全都由它负责，开发复杂视图时我们可能经常需要与之打交道。而它又是由 Element 的子类 RenderObjectElement 创建出来的，RenderObject 也会构成一个 Render Tree，并且每个 RenderObject 也都会被保存下来以便在更新时复用，Render Tree构建的数据会被加入到 Engine所需的 LayerTree中，Engine通过 LayerTree进行视图合成并光栅化，提交给 GPU。 那么三者关系很明确了：配置文件 Widget 生成了 Element，而后创建 RenderObject 关联到 Element 的内部 renderObject 对象上，最后Flutter 通过 RenderObject 数据来布局和绘制。 一共有几颗树","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://www.allenmistake.top/tags/Flutter/"}]},{"title":"代理模式的几点总结","date":"2020-03-06T07:16:59.000Z","path":"2020/03/06/proxy/","text":"代理模式为其它对象提供一种代理以控制这个对象的访问。 简单的举个例子，可以看作一个玩家自己不打游戏，而是通过找代练让代练去操作游戏。诸如Windows上的快捷方式，其实都是一种代理模式。 优缺点优点 职责清晰。真实的角色就是实现实际的业务逻辑，不用担心其他非本职责的事务。 高扩展性。代理类完全可以在不做任何修改的情况下使用。 智能化。比如动态代理。 缺点 有些类型的代理模式可能会造成请求的处理速度变慢。 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。 结构图 UML框图 代理模式中有以下角色： 抽象主题类(Subject): 声明真实主题和代理Proxy 的共同接口方法。 真实主题类(RealSubject): 具体主题角色，定义了 Proxy 所代表的真实实体 代理类(Proxy)：持有对真实主题类的引用,使代理可以访问实体，并提供一个与 Subject 的接口相同的接口。 客户端类。 代码示例首先我们来看一下对应基本结构下的代理模式。 Subject抽象类定义了 RealSubject 和 Proxy 的共同接口，这样就在任何使用 RealSubject 的地方都可以使用Proxy。 123public abstract class Subject &#123; public abstract void request();&#125; RealSubject类123456public class RealSubject extends Subject &#123; @Override public void request() &#123; System.out.println(\"真实的请求RealSubject\"); &#125;&#125; Proxy类代理类。一个代理类可以代理多个被委托者或被代理者，因此一个代理类具体代理哪个真实主题角色，是由场景类决定的。 1234567891011121314public class Proxy extends Subject &#123; private RealSubject realSubject = null; public Proxy() &#123; this.realSubject = new RealSubject(); &#125; @Override public void request() &#123; this.realSubject.request(); &#125;&#125; Client 客户端1234567public class Client &#123; public static void main(String[] args) &#123; Proxy proxy = new Proxy(); proxy.request(); &#125;&#125; 静态代理所谓静态代理类是指：由程序员创建或由特定工具自动生成源代码，再对其进行编译。在程序运行之前，代理类的.class文件就已经存在了。 抽象主题类123public interface IShop &#123; void buy();&#125; 真实主题类123456public class Allenmistake implements IShop &#123; @Override public void buy() &#123; ... &#125;&#125; 代理类1234567891011public class Purchasing implements IShop &#123; private IShop mShop; public Purchasing(IShop shop) &#123; this.mShop = shop; &#125; @Override public void buy() &#123; mShop.buy(); &#125;&#125; 4、客户端类 12345678public class Clent &#123; public static void main(String[] args) &#123; IShop allenmistake = new Allenmistake(); IShop purchasing = new Purchasing(allenmistake); purchasing.buy(); &#125;&#125; 动态代理在代码运行时通过反射来动态地生成代理类的对象，并确定到底来代理谁。 通过动态代理，我们不再需要手动创建代理类，只需编写一个动态处理器即可，而真正的代理对象由JDK在运行时帮我们创建。所以我们也将之称为JDK动态代理。 方法步骤如下：（重点） 写一个代理类实现 InvocationHandler 接口，通过构造函数把代理对象（具体目标类）传入到此处理器中，在invoke()方法中增加method.invoke(realSubject, args)。在调用方法时，通过java.lang.reflect.Proxy 和newProxyInstance() 来获取代理实现类，生成代理对象时，直接调用方法即可。真实主题类发生变化时，由于它实现了公用的接口，因此代理类不需要修改。 改写静态代理的代理类和客户端类，如下所示： 动态代理类1234567891011public class DynamicPurchasing implements InvocationHandler &#123; private Object obj; public DynamicPurchasing(Object obj) &#123; this.obj = obj; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; return method.invoke(obj, args); &#125;&#125; 客户端类1234567891011public class Clent &#123; public static void main(String[] args) &#123; IShop jsonChao = new JsonChao(); DynamicPurchasing mDynamicPurchasing = new DynamicPurchasing(jsonChao); ClassLoader cl = jsonChao.getClass.getClassLoader(); // 生成代理类对象 IShop purchasing = Proxy.newProxyInstance(cl, new Class[]&#123;IShop.class&#125;, mDynamicPurchasing); purchasing.buy(); &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.allenmistake.top/tags/设计模式/"}]},{"title":"从预设ViewModel代码谈MVVM模式","date":"2020-02-03T14:03:31.000Z","path":"2020/02/03/mvvm/","text":"从MVC说起设计分层，不得不提到 MVC ，也就是 Model、View、Controller 这种模型——视图——控制器的设计模式有很多优点，最大的一个就是低耦合， 模型对象： 存存着应用的数据和业务逻辑。模型类通常用来映射与应用有关的一些事物，如用户、商店里的商品、服务器上的图片…模型对象不关心用户界面，它为存储和管理应用数据而生。 视图对象：这个不多做解释 控制器对象：含有应用的逻辑单元，是视图对象与模型对象的联系纽带。控制器对象相应视图对象触发的各类条件，此外还管理着模型对象与视图层间的数据流动。 MVC面临的问题MVC适合小规模的应用。他方便开发人员情理结构，快速添加新功能，为开发打下坚实基础。 但当项目功能逐渐变多的时候。fragment 和 acvtivity 开始膨胀，逐渐变得难以理解和扩展。这个时候控制层就要做出拆分。","tags":[]},{"title":"人生，就是不断和过去告别","date":"2020-01-08T02:10:47.000Z","path":"2020/01/08/goodbye2019/","text":"地久天长 电影名 其实一开始并不知道《地久天长》这部电影，只是好奇柏林影帝影后是怎样的演技，看完之后感觉，确实，这种在平凡之中所蕴藏在心底的悲伤，被演员悄无声息地蔓延开来，扑向屏幕外的观众。 3个小时的电影，电影采用闪回的方式，观众需要对闪回内容发生的时间进行分析。我想了想，为什么电影要用闪回，大概正如年纪大的人回首往事，一幕幕回忆涌上心头，尽管持续的时间不强，但是感情强烈。 每个人，只能陪你走一段路，这是我当时看完《山河故人》的最有印象的台词，那也是一部看完了全篇就好像过完一生的电影。而《地久天长》拍的更好，我很喜欢电影的英文名，So Long，My Son。So long 有如此之长，也有再见的意思，片中主角家庭很早就失去了他们的儿子，他们用自己的一生来为孩子告别。这是So long的双层含义。不得不说，很妙。 片头，当悠扬厚重的大提琴演奏出友谊地久天长的前奏时，就已经奠定了影片缓缓流淌的悲伤。正如片最后夫妻俩原谅了间接杀死自己孩子的干儿子一样，所有的感情都会随着时间的流逝而渐渐淡去，恨意，爱意。 正如歌里面唱的那样： 123456789我们曾经终日游荡在故乡的青山上我们也曾历尽苦辛到处奔波流浪...我们也曾终日逍遥荡桨在绿波上但如今却劳燕分飞远隔大海重洋 电影宣传曲封面 2019回顾说了半天电影的故事，现在才正式对2019年进行一个回顾。其实也没什么好回顾的，整个2019没做什么重要的事，简单列举一下 智能管家，对于 Android 各个组件使用慢慢熟悉 做了一个Flutter 小项目，但是对 Flutter 缺乏更深入的理解 算法方面，也是刷了不少 Leetcode ，做了不少总结，但是还是要时不时回顾。两个我觉得掌握比较好的就是回溯和排序了。下面重点是动态规划和树问题 Java方面由于看的比较早，现在印象不深，JVM 方面和 多线程 这方面总结的已经很多了，应该反复咀嚼。 通信方面实验室内容做的比较多，觉得最有收获的就是 MIMO 的空时编码，和Viterbi译码，程序写出来的时候那种成就感还是很不错的 你好，2020据说2020要贫困人口摘帽，我觉得我很危险了，现在只想搞钱.jpg 至少出1篇论文 看10本非专业书籍 找到一份满意的工作 LeetCode继续刷题！至少50道吧 之前的年度计划保存在本地，不知道什么时候删了，这次写到博客里，应该不会忘了。 最近事情有点多，等到之后再进行补充。","tags":[]},{"title":"Leetcode日记：322.换硬币","date":"2019-11-21T13:40:44.000Z","path":"2019/11/21/CoinChange/","text":"题目给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 【举例】输入: coins = [1, 2, 5], amount = 11输出: 3解释: 11 = 5 + 5 + 1 分析我们仍采取上次说的回溯转动态规划，来慢慢熟悉动态规划解题思路。 回溯123456789101112131415161718192021222324252627282930313233343536public int minCoins(int[] coins, int amount)&#123; if(coins == null || coins.length == 0 || amount &lt; 1)&#123; return -1; &#125; return proress(coins, 0, amount);&#125;/** * * @param coins coin数组 * @param i 当前考虑的第i个面值coin * @param rest 目前剩下需要换的钱 * @return */public int proress(int[] coins, int i, int rest) &#123; // base case: // 此时已经没有面值能考虑的 // 所以如果剩下的rest此时不是0，则返回-1 if(i == coins.length)&#123; return rest == 0 ? 0 : -1; &#125; // 最少张数，初始为-1 int res = -1; // 依次尝试使用当前面值(coins[i])0张、1张，但不能超过rest for(int k = 0; k * coins[i] &lt;= rest; k++)&#123; // 使用了k张coins[i]，剩下的钱为rest-k*coins[i] int next = proress(coins, i +1, rest - k* coins[i]); if(next != -1)&#123; if(res == -1) res = next + k; else res = Math.min(res, next + k); &#125; &#125; return res;&#125; 动态规划 找可变参数，如果看了回溯的代码，马上能确定分别是：硬币面值coins[i]、剩下的钱rest。 构建表，二维数组的行代表硬币面值，列代表兑换面值，如下图所示。注意，为了构建base case，我们必须要创建0硬币面值，以及0兑换钱数，因为我把0面值放在了数组最后，所以我们运算方向是自下向上的 随后我们对base case进行初始赋值，当0面值时。只有当兑换钱总数为0，数量才是0，其他都是-1(不可达) 最为关键的一步，如何填写非base case，我们要梳理清楚逻辑关系，首先赋值-1，然后我们考虑此时的coin[i]能否构成，不能构成（coin[i] &gt; rest）我们肯定不可达，如果coins[i] &lt; rest ，这是就要看 rest - coins[i] 是否可达，如果不可达，那rest也不可达，如果可达，我们就要和之前没有coins[i]参与的面值组成的rest比一比，谁更小。 以上这段文字需要细细品味，如果你觉得想起来有点吃力，请看下面两张图： 注意红字得到的过程 黄字在图中标出了比较过程 这两张图中，我希望你搞清楚红色数字的来由， 12345678910111213141516171819202122232425public int minCoins(int[] coins, int amount)&#123; if(coins == null || coins.length == 0 || amount &lt; 1)&#123; return -1; &#125; int N = coins.length; int[][] dp = new int[N + 1][amount + 1]; // base case初始化 for(int col = 1; col &lt;= amount; col++)&#123; dp[N][col] = -1; &#125; for(int i = N - 1; i &gt;= 0; i--)&#123; for(int rest = 0; rest &lt;= amount; rest++)&#123; dp[i][rest] = -1; if(dp[i + 1][rest] != -1) dp[i][rest] = dp[i + 1][rest]; if(rest - coins[i] &gt;= 0 &amp;&amp; dp[i][rest - coins[i]] != -1)&#123; if(dp[i][rest] == -1) dp[i][rest] = dp[i][rest - coins[i]] + 1; else dp[i][rest] = Math.min(dp[i][rest - coins[i]] + 1, dp[i][rest]); &#125; &#125; &#125; return dp[0][amount];&#125; 最后，欢迎大家来我的公众号看一看，周更一些算法总结和Java基础巩固~ 微信关注安知窝","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.allenmistake.top/tags/动态规划/"}]},{"title":"这可能是我见过最全的动态规划讲解","date":"2019-11-20T15:46:59.000Z","path":"2019/11/20/dp/","text":"理论篇什么时候用动态规划一个模型三个特征 模型：多阶段决策最优解模型 解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。 最优子结构： 最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。 无后效性： 无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。 重复子问题： 不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。 举个例子——棋盘问题一个机器人从4*4的棋盘的左上角走到右下角，每次走一个，且只能向下或向右，每个格子有自己的权值，请问怎样走权值总和最小？ 这就完全符合上述的情况（每走一格就代表一个阶段，每个阶段对应一个状态集合，最优路径一定由最优子路径组成；我们不关心来的路线，只关心经过路线的权值和；不同路径在相同阶段会有重复） 棋盘问题 两种解题思路 状态转移表法 我们先画出一个状态表。状态表一般都是二维的，所以你可以把它想象成二维数组。其中，每个状态包含三个变量，行、列、数组值。我们根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，我们将这个递推填表的过程，翻译成代码，就是动态规划代码了。 回溯、贪心与动态规划 回溯 回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。 动态规划 尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大 量的重复子问题。 贪心算法 贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。其中，最优子结构、无后效性跟动态规划中的无异。 “贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。 实战篇机器人达到指定位置方法数【题目】 假设有排成一行的N个位置，记为1~N，N一定大于等于2.开始时机器人在其中的M位置上。机器人可以往左走或者往右走，如果机器人来到1位置，那么下一步只能往右来到2位置；如果机器人来到N位置，那么下一步只能往左来到N-1位置。规定机器人必须走K步，最终能来到P位置的方法有多少种？ 【举例】N = 5，M = 2， K = 3， P = 3； 【解答】我们说过，所有的动态规划问题，都可以用回溯问题来解决，那么我们完全可以先利用递归的思路来想一下思路，然后过渡到动态规划，实际上，这种暴力递归到动态规划的优化对于很多问题都适用。 暴力递归其实暴力递归就是回溯，我们直接上代码 1234567891011121314151617181920/** * * @param N 位置1~N， 固定参数 * @param cur 当前所在位置，可变参数 * @param rest 还剩步数，可变参数 * @param P 最终目标，固定参数 * @return 返回方法数，int类型 */ public int walk(int N, int cur, int rest, int P)&#123; // 如果没有步数，当前位置就是最后位置 // 如果最后位置停在P，那么值钱移动就是有效，反之无效 if(rest == 0) return cur == P ? 1 : 0; // 考虑两种边界情况 if(cur == 1) return walk(N, 2, rest - 1, P); if(cur == N) return walk(N, N - 1, rest - 1, P); return walk(N, cur + 1, rest - 1, P) + walk(N, cur - 1, rest - 1, P); &#125; 看见没，回溯解决问题的代码就是那么简单，可是代码的简洁是用时间复杂度换来的。所以哈，面试的时候，如果面试官向你提了一个算法题，你可以先用回溯拖一下，因为回溯是很容易想到的解决问题的算法，然后我们再对他进行优化。 优化为动态规划在这之前，我们已经能确定了这个问题是具有无后效性的。 那么套路大体步骤如下： 找到什么可变参数可以代表一个递归状态，也就是哪些参数一旦确定，返回值就确定了。 把可变参数的所有组合映射成一张表，有一个可变参数就是一维表，2个可变参数就是二维表… 最终答案要的是表中的哪个位置，在表中标出。 根据地轨过程的base case，把这张表最简单，最不需要依赖其他位置的那些位置填好值。 根据递归过程的非base case的部分，也就是分析表中的普遍位置需要怎么计算得到，那么这张表的填写顺序就确定了。 填好表，返回最终答案在表中的位置。 针对于这道题我们可以套用一下：N = 7，M = 5， K = 9， P = 4； walk函数中，可变参数cur, rest一旦确定，返回值也就确定了。 如果可变参数cur和 rest组合的所有可能情况组成一张表，这张表便装下了所有的返回值。如下图所示 最终要求的位置，标出来。在这里我们最终位置是dp[9][4]，我们已经用星号在上图标出来了位置。 base case指问题的规模小到什么程度，就不需要划分子问题，很明显指的是代码如下的情况，表现在二维数组下图所示 123if(reset == 0)&#123; return cur == P ? 1 : 0;&#125; 那么剩下的代码对应的就是非base case，那么如何填写呢？我们要找到下一行是怎样计算得到的，很明显，是有旁边的两个格子相加得出来的（边界条件除外），很容易得出下表 代码最后，我们来看一下动态规划的代码 123456789101112131415161718public int ways2(int N, int M, int K, int P)&#123; // 参数无效直接返回0 if(N &lt; 2 || K &lt; 1 || M &lt; 1 ||M &gt; N || P &lt; 1 || P &gt; N ) return 0; int[][] dp = new int[K + 1][N + 1]; dp[0][M] = 1; for(int i = 1;i &lt;= K; i++)&#123; for(int j = 1; j &lt;= N; j++)&#123; if(j == 1) dp[i][j] = dp[i - 1][2]; else if(j == N) dp[i][j] = dp[i - 1][N - 1]; else dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]; &#125; &#125; return dp[K][P];&#125; 参照之前的回溯，还是很容易看懂的吧，实际就是维护了一个二维数组，实际上，我们的二维数组是可以继续优化的，毕竟当我们走到第3步的时候，我们并不关心第一步走的情况，那一层数据对我们来说就是没有的用的。 数组压缩当然，我们可以将二维数组压缩为一维数组，毕竟是无后效性。我们完全可以维持更新第i步时的位置信息，注意更新的时候保存中间值，防止更新的时候覆盖掉 123456789101112131415161718192021public int ways2(int N, int M, int K, int P)&#123; // 参数无效直接返回0 if(N &lt; 2 || K &lt; 1 || M &lt; 1 ||M &gt; N || P &lt; 1 || P &gt; N ) return 0; int[] dp = new int[N + 1]; dp[M] = 1; for(int i = 1; i &lt;= K; i++)&#123; int leftUp = dp[1]; // 记录左上角的值 for(int j = 1; j &lt;= N; j++)&#123; int tmp = dp[j]; if(j == 1) dp[j] = dp[j + 1]; else if(j == N) dp[j] = leftUp; else dp[j] = leftUp + dp[j + 1]; leftUp = tmp; &#125; &#125; return dp[P];&#125; 总结以上就是我对动态规划的一些梳理总结，希望大家看完这篇文章之后对于动态规划问题能有一个自己的判别，动态问题的难点在于识别出他的模型，建立你心中的那个表，解锁了动态规划问题之后，我们的算法库会多出来更多关于它的问题，希望大家持续关注。 我们下期再见！ 附录：本文参考自《程序源代码面试指南（第二版）》、极客时间——《数据结构与算法之美》。","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.allenmistake.top/tags/动态规划/"}]},{"title":"谈谈Java中的反射机制","date":"2019-11-17T03:39:35.000Z","path":"2019/11/17/Reflect/","text":"反射的定义何为反射？ 反射机制就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 用一句话总结就是反射可以实现在运行时可以知道任意一个类的属性和方法。 问题来了———— 那这样一来，我的私有变量不就暴露在外面了么？ 呃。。。是的，实际上，我们确实能通过反射机制对一个类的私有变量做修改，所以从某种程度上来讲，反射破坏了java的封装性，那么为什么还会作为一种高级特性存在于java中呢？ 别急，我们首先看一下反射能为我们做哪些工作。 反射用途获取有三种方式： 12345678910111213//方式一Person person = new Person();Class&lt;? extends Person&gt; personClazz01 = person.getClass();//方式二try &#123; Class&lt;?&gt; personClazz02 = Class.forName(\"Person\");&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125;//方式三Class&lt;? extends Person&gt; personClazz03 = Person.class; 通过反射机制得到类的包名和类名12345public static void main(String args[]) &#123; Person person = new Person(); System.out.println(\"Test1: 包名: \" + person.getClass().getPackage().getName() + \"，\" + \"完整类名: \" + person.getClass().getName());&#125; 核心：通过反射创建类对象1234567Class&lt;?&gt; class1 = null;class1 = Class.forName(\"反射.Person\");//由于这里不能带参数，所以你要实例化的这个类Person，一定要有无参构造函数Person person = (Person) class1.newInstance();person.setAge(27);person.setName(\"yyc\");System.out.println(\"Test3: \" + person.getName() + \" : \" + person.getAge()); 上述是通过反射创建一个无参对象，如果我的构造函数带参的话，需要利用Constructor， 12345678910111213141516171819Class&lt;?&gt; class1 = null;Person person1 = null;Person person2 = null;class1 = Class.forName(\"反射.Person\");//得到一系列构造函数集合Constructor&lt;?&gt;[] constructors = class1.getConstructors();try &#123; person1 = (Person) constructors[0].newInstance();&#125; catch (InvocationTargetException e) &#123; e.printStackTrace();&#125;person1.setAge(28);person1.setName(\"yyc\");person2 = (Person) constructors[1].newInstance(29, \"yyc\");System.out.println(\"Test4: \" + person1.getName() + \" : \" + person1.getAge() + \" , \" + person2.getName() + \" : \" + person2.getAge()); 通过反射调用类方法12345678910Class&lt;?&gt; class1 = null;class1 = Class.forName(\"反射.SuperPerson\");System.out.println(\"Test7: \\n调用无参方法fly()：\");Method method = class1.getMethod(\"fly\");method.invoke(class1.newInstance());System.out.println(\"调用有参方法smoke(int m)：\");method = class1.getMethod(\"smoke\", int.class);method.invoke(class1.newInstance(), 100); 反射原理说了那么多使用上的例子，我们还是更进一步，看一看系统底层是怎么去做的吧 1Person person = new Person(); 这是我们正常创建一个类的实例，我们从类加载的角度去讲一下它的创建过程，具体过程可以说的很多，可以参考这篇文章JVM类加载 遇到new，在磁盘中找 Person.class 文件 如果没有被加载，就在内存中生成一个代表这个类的java.lang.Class对象，所以，class对象只会有一个（在被加载的情况下）。补充：这一部分是通过类加载器实现的 ClassLoader 实际上，这个类加载是在编译时期就完成的，我们称之为“静态加载”，而反射引起的类加载是在运行时期进行的，也就是“动态加载”。 那我们看一看反射： 12class1 = Class.forName(\"反射.Person\");Person person = (Person) class1.newInstance(); 系统根据类的名称直接找到class对象（当然，如果没有的话肯定会触发动态加载），然后通过class对象来对Person对象进行一系列操作（在上述代码，是通过newInstance执行构造函数，创建对象）。此时，Person对象已经完全暴露，可以调用构造函数，或者其他类函数。 如果你没读懂的话，我们来看一下源码是如何做的: 123456@CallerSensitivepublic static Class&lt;?&gt; forName(String className) throws ClassNotFoundException &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); return forName0(className, true, ClassLoader.getClassLoader(caller), caller);&#125; 具体的内容我们可以不用掌握，但我们需要知道，forName这个会触发类加载器ClassLoader来对输入 String 对应类进行类加载，而这个时机是在运行时进行的。 说一说用途说了那么多，回到一开始的问题，反射究竟能起到什么作用呢？我们再来回顾一下：我们能通过类名直接访问类中的具体属性和方法。反过来，如果我们不知道类中的具体属性和方法，我们就只能用反射去得到，这种情况在什么时候会出现呢？ 那就是当我们使用第三方资源或者框架的时候，我们不知道具体的实现细节，便可以通过反射来了解里面内容，在我们的编译器中，输入一个类名或者一个实例在后面输入一个点“.”，系统会自动弹出其中的所有属性与方法，其实这就是反射。 Android与反射调用资源当我们项目需要调用第三方的布局时，我们不能使用setContentView(R.layout.activity_main)方法，我们需要借助反射setContentView(IDHelper.getLayout(getApplicationContext(), &quot;activity_main&quot;))，将布局交给工具类，以便在运行时查找。 Activity启动创建在Manifest文件中四大组件的注册都是用反射来完成的，还有布局文件中的widget等等。 足以见得反射应用之广 总结现在来看，反射是不是一个很神奇的功能，再回到一开始的问题，其实反射在破坏封装性的同时确实给我们带来了诸多便利。希望本文对你有所帮助。","tags":[{"name":"基础","slug":"基础","permalink":"http://www.allenmistake.top/tags/基础/"}]},{"title":"维特比算法","date":"2019-11-10T02:56:14.000Z","path":"2019/11/10/viterbi/","text":"好久没有更新通信相关的博客了，最近在做关于维特比译码的相关工作，这两周也是把维特比算法摸了个门清，下面来简单说一下维特比译码的关键思想，重要步骤。 维特比译码首先，我们要对维特比译码有个大概的认识。 维特比算法是基于状态转移的一种算法。在我的程序中，涉及到的是相位状态，对于CPM（连续相位调制）信号，相位是随着时间连续变化的，这边是一种状态转移，由于这种状态是具有记忆性的，我们在译码的时候，便可以利用这种记忆性，从前向后，或者从后向前译码。通过找到最优路径，来将信号恢复。 在CPM信号的译码中，我们可以画出这样一种状态转移网格图 状态转移网格图 其中，纵坐标代表的是状态，横坐标代表每个时刻的符号。第 n 时刻输入的符号不同，对应的状态也就不同。 约束长度在网格中，对于某些路径，Viterbi 算法递归地累积直到 k 个符号间隔分支量，并选择具有最大路径度量的路径。这个k便为约束长度。理想的情况下，约束长度等于信号长度，但是时间复杂度是O(2^N)，对于通信中的信号来说，复杂度太高，且难于实现，所以，在实际中约束长度一般不会等于信号长度。在我的程序中，约束长度等于2。 简化状态我们可以看，在上面的网格图中，有 4 种状态，计算起来复杂度比较高。我的项目中采取了简化状态的方法，通过观察状态转移网格，偶数时刻的状态只有两种情况，0 和 π。如下图所示 状态简化 状态与分支度量说了那么多，到底是如何找到这个最优路径的呢？对接收到的信号，对于第 n 个时刻，下一种状态对应的所有可能分支状态进行相关计算，我们把得到的这个量成为分支度量，我们比较使第 n 个时刻的分支度量最大的分支状态，保存下来。假设 n 时刻可能有两种状态，每种状态对应 2 种分支（我的项目中是4种），所以每个时刻要计算的度量总共有4个。 我们把最大似然分支找到之后，保存下来，然后往后进行递推，保存的分支数即为约束长度。 提前祝大家双十一快乐！","tags":[{"name":"译码","slug":"译码","permalink":"http://www.allenmistake.top/tags/译码/"}]},{"title":"智能管家项目总结1————运行时权限 + FileProvider","date":"2019-10-18T13:45:25.000Z","path":"2019/10/18/smartbutler1/","text":"智能管家SmartButler从PT站发现的 Android 练手小项目，慕课网上面的课程，看过视频之后感觉优点还是挺多的 上手简单 老师总结一些代码常用模板，有利于之后编程代码结构 这个框架虽说是 MVC ，但是对于小项目 MVC 也未尝不可，并且框架分类层次分明 采用许多开源框架 缺点 最重要的，年代稍微有些老，对于新版本（Android6.0 之后不太友好） 虽然采用了许多开源框架，但是对于框架本身并没有做太多的说明，只是轮子的拼接 部分后台接口发生改变，用不了 做了一些微小的工作对于这个练手项目，肯定是要抱着学习的态度，但同时，还要结合现在新版本来看旧版代码的一些局限性，自己只能做一些微小的工作 那么接下来，先从很尴尬的运行时权限说起 运行时权限在 Android6.0 之前，安装软件时，会告诉你该软件都需要什么什么权限，但是就算软件告诉你我要你各种隐私，你装个微信还是要装对吧，所以Android6.0很机智的引入了运行时权限这个概念，有些关键性的权限，你在AndroidManifest文件里面声明了，没有用，等到用的时候你还要申请一遍，而且会直接弹出询问UI。 这个申请的操作，是留给开发者去做的。 下面来讨论运行时权限在智能管家的应用 拍照与写入内存调用拍照代码中，我们加入版本检测，并在高版本中引入权限请求 123456789if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; //如果在Android7.0以上,使用FileProvider获取Uri intent.setFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION); Uri contentUri = FileProvider.getUriForFile(getActivity(), getActivity().getPackageName()+\".fileprovider\", tempFile); intent.putExtra(MediaStore.EXTRA_OUTPUT, contentUri); Log.e(\"getPicFromCamera\", contentUri.toString());&#125; else &#123; //否则使用Uri.fromFile(file)方法获取Uri intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(tempFile));&#125; 在这里引入了FileProvider，我们已经在配置文件中声明了 123456789&lt;provider android:name=\"androidx.core.content.FileProvider\" android:authorities=\"com.example.smartbutler.fileprovider\" android:exported=\"false\" android:grantUriPermissions=\"true\"&gt; &lt;meta-data android:name=\"android.support.FILE_PROVIDER_PATHS\" android:resource=\"@xml/provider_paths\" /&gt;&lt;/provider&gt; 首先，FileProvider 是什么？这个我将在后面博客详细说明，那么为什要引入呢？如果我知道一个文件的uri，是不是就可以随意访问了呢？如果没有FileProvider拦着你，确实是这样，但现在更严格了，Android 7.0后新增了对文件跨进程访问的限制，这个限制会造成，如果使用file://uri的方式访问，则会出现android.os.FileUriExposedException的异常。 注意，配置文件中的 &quot;@xml/provider_paths&quot;, 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;paths xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;external-path path=\"com.example.smartbutler\" name=\"images\" /&gt; &lt;root-path name=\"root_path\" path=\".\" /&gt;&lt;/paths&gt;","tags":[{"name":"权限","slug":"权限","permalink":"http://www.allenmistake.top/tags/权限/"}]},{"title":"次火锅儿噻","date":"2019-10-09T04:09:16.000Z","path":"2019/10/09/chongqing/","text":"重庆之行不知道什么时候西安重庆之间开始有了动车，赶上国庆，就去一趟呗。 但是果然还是不能调大假期的时候去，当地人民接到通知，不要去几个热门景点和游客抢位置。。以致于第一次去洪崖洞的我望洋兴叹，不过终于在6号晚上得以见到传说中的洪崖洞夜景了。 洪崖洞真的是很美的夜景，一个洪崖洞也把重庆这个城市的立体感展现的淋漓尽致——11楼出来是马路，1楼出来还是马路。 洪崖洞 而且特别感谢 iPhone 店里上课的老师，教了一些拍照的小技巧，让我拍照水平有所提高 洪崖洞进阶 但是说归说，iPhone 本身的拍照水平真的不行，或者说 iPhone 尽可能地还原原本的光影色彩，如果想让艺术高于生活，少不了后期的加工 iPhone无加工 B612 高下立判，不过其实这种模式也不错，单反不也都是这样吗，需要后期调整色彩。就是有点不够傻瓜（不懂单反，如果说错了多多包涵） 8D立体城市在蜂窝网上评价中有这么一条，叫做“8D立体城市”，我觉得形容的很贴切，在道路高低起伏的重庆里，楼房，交通，桥，这三种元素将空间利用率达到了极致。著名景点李子坝轻轨站就是最好的证明 李子坝 次火锅er~来了重庆，怎么能不吃火锅呢，有点遗憾的是我点的全都是微辣，不能完全领略重庆火锅的魅力，但对于我来说，这个辣度已经相当辣了。 重庆火锅 2019年没有假期至此，2019年所有假期都已经用完，再放假就是元旦了，现在要好好收收心，搞科研咯。 PS.发这篇文章真的无语，hexo又抽了，下午查问题查了半个多小时。。","tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"http://www.allenmistake.top/tags/碎碎念/"}]},{"title":"浅谈Android中的轻量级存储————SharePreference","date":"2019-09-28T08:07:18.000Z","path":"2019/09/28/sharepreference/","text":"SharePreference应用在App中，需要暂时存储的，我们可以利用SharePreference，我们把存储的轻量级数据，例如一个字符串，一个数字，写入shared preferences。当我们需要数据，再从中读取 何为 sharedPreferenceshared preferences本质上就是文件系统中的文件，可使用SharedPreferences类读写它。SharedPreferences实例用起来更像一个键值对仓库（类似于Bundle），但它可以通过持久化存储保存数据。（也就意味着应用关闭之后仍然有效）键值对中的键为字符串，而值是原子数据类型。进一步查看shared preferences文件可知，它们实际上是一种简单的 XML 文件，但SharedPreferences类已屏蔽了读写文件的实现细节。shared preferences文件保存在应用沙盒中，所以，不应用它保存类似密码这样的敏感信息。 XML文件格式 使用请看下面代码 12345678910111213public class QueryPreferences &#123; private static final String PREF_SEARCH_QUERY = \"searchQuery\"; public static String getStoredQuery(Context context)&#123; return PreferenceManager.getDefaultSharedPreferences(context) .getString(PREF_SEARCH_QUERY, null); &#125; public static void setStoredQuery(Context context, String query)&#123; PreferenceManager.getDefaultSharedPreferences(context) .edit() .putString(PREF_SEARCH_QUERY, query) .apply(); &#125;&#125; QueryPreference 类中，我们定义了两个方法，分别用来存储信息和取出信息。由于我们存储的键值对只有一种，且维持一个，所以我们在类的一开始把 Key 固定。值得注意的是，我们要传递上下文信息 Context ，只有找到自己 context对应的 SharedPrefernce 才可以找到与之对应的键值对。 需要补充的是，现在android原生库中的sharedPreference被官方标注为不推荐使用。具体原因其实是 扩展库中的 sharedPreference 支持更多的存储类型，可以看一下 Google 开发者在18年11月发布的一段新特性视频其中介绍了关于扩展库中 sharedPreference 的特性。我们选择 sharedPreference 时，引进扩展库 androidx 即可，函数逻辑基本一致 引进库代码： java implementation &quot;androidx.preference:preference:1.1.0&quot; ` 在build.gradle","tags":[{"name":"Android","slug":"Android","permalink":"http://www.allenmistake.top/tags/Android/"}]},{"title":"Android 线程下载 handle 使用分析","date":"2019-09-21T07:40:46.000Z","path":"2019/09/21/handler/","text":"从 AsyncTask 说起在Android网络库之HttpURLConnection与数据解析我们提到了利用 AsyncTask 在后台运行耗时操作。 AsyncTask是执行后台线程的最简单方式，但它不适用于那些重复且长时间运行的任务。虽然耗时操作在后台运行，不会使系统崩溃，但是我们如果加载图片不能等它全都下载之后一起显示（内存占用也是一个问题）。 考虑到上面的问题，很多应用通常会选择仅在需要显示图片时才需要下载。 主线程Android系统中，线程使用的收件箱叫作消息队列（message queue）。使用消息队列的线程叫作消息循环（message loop）。消息循环会循环检查队列上是否有新消息。消息循环由线程和looper组成。Looper对象管理着线程的消息队列。主线程就是个消息循环，因此也拥有looper。主线程的所有工作都是由其looper完成的。looper不断从消息队列中抓取消息，然后完成消息指定的任务。 1234567891011121314151617181920212223242526private ThumbnailDownloader&lt;PhotoHolder&gt; mThumbnailDownloader;...@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setRetainInstance(true); new FetchItemsTask().execute(); // 创建 HandlerThread mThumbnailDownloader = new ThumbnailDownloader&lt;&gt;(); // 初始化Looper mThumbnailDownloader.start(); mThumbnailDownloader.getLooper(); Log.i(TAG, \"Background thread started\");&#125;@Nullable@Overridepublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; ...&#125;@Overridepublic void onDestroyView() &#123; super.onDestroyView(); mThumbnailDownloader.clearQueue();&#125; ThumbnailDownloader的 getLooper() 方法是在 start() 方法之后调用的。（稍后会学习更多有关Looper的知识）这能保证线程就绪，避免潜在竞争（尽管极少发生）。因为 getLooper() 方法能执行成功，说明 onLooperPrepared() 方法肯定早已完成。这样，queueThumbnail（）方法因Handler为空而调用失败的情况就能避免了。 在 onDestroy() 方法内调用 quit() 方法结束线程。这非常关键。如不终止 HandlerThread ，它会一直运行下去，成为僵尸。 12345678@Overridepublic void onBindViewHolder(@NonNull PhotoHolder photoHolder, int position) &#123; GalleryItem galleryItem = mGalleryItems.get(position); Drawable placeholder = getResources().getDrawable(R.drawable.bill_up_close); photoHolder.bindDrawable(placeholder); // 获取图片 url 传入，添加下载任务 mThumbnailDownloader.queueThumbnail(photoHolder, galleryItem.getUrl());&#125; Handler、Looper、Message 结构分析剖析MessageMessage需要自己定义三个变量，分别是 What：用户定义的int型消息代码，用来描述消息 obj：用户指定，随消息发送的对象 target：处理消息的 Handler 剖析 Handler 结构图 作用：创建、发布、处理 Message 我们来说一下 Handler 使用时的流程，结合一下代码分析。 1234567891011121314public void queueThumbnail(T target, String url)&#123; Log.i(TAG, \"Got a URL: \"+url); if(url == null)&#123; mRequestMap.remove(target); &#125;else&#123; // 使用一个标记下载请求的T类型作为key， // 我们可以存取和请求关联的URL下载链接 // 这个标记对象是PhotoHolder， 下载结果就能很方便的发送给显示图片的UI元素 mRequestMap.put(target, url); // 将下载消息添加到后台线程的消息队列中 mRequestHandler.obtainMessage(MESSAGE_DOWNLOAD, target) .sendToTarget(); &#125;&#125; 我们在obtainMessage(…) 方法获取消息，紧接着用让这个Message调用 sendToTarget() 方法将其发送给它的Handler，Handler 会将这个Message放置在 Looper 消息队列的尾部。 Looper 取得消息队列中的Message后，会将他发送给消息的目标Handler去处理。消息一般实在目标 Handler 的 Handler.handleMessage(…) 实现方法中进行处理的。 Handler创建、发送Message 1234567891011121314@Overrideprotected void onLooperPrepared() &#123; mRequestHandler = new Handler()&#123; @Override public void handleMessage(@NonNull Message msg) &#123; if(msg.what == MESSAGE_DOWNLOAD)&#123; T target = (T)msg.obj; Log.i(TAG, \"Got a request for URL: \" + mRequestMap.get(target)); // 获取图片的耗时操作 handleRequest(target); &#125; &#125; &#125;;&#125; 上述代码中，我们是在 onLooperPrepared() 方法里实现 Handler.handleMessage(...) 方法的。HandlerThread.onLooperPrepared() 是在Looper首次检查消息队列之前调用，所以该方法是创建Handler实现的好地方。 在Handler.handleMessage(…)方法中，首先检查消息类型(what)，再获取obj值（T类型下载请求），然后将其传递给handleRequest(…)方法处理。（前面说过，队列中的下载消息取出并可以处理时，就会触发调用Handler.handleMessage(…)方法。handleRequest() 方法是下载执行的地方。在这里，确认URL有效后，就将它传递给FlickrFetchr新实例。确切地说，此处使用的是Android网络库之HttpURLConnection与数据解析中创建的FlickrFetchr.getUrlBytes(…)方法。 传递 Handler我们使用 mRequestHandler，已经可以从主线程安排后台任务。 从主线程安排 ThumbnailDownloader 上的任务 反过来，也可以从后台线程使用与主线程关联的Handler，安排主线任务 ![从ThumbnailDownloader线程上规划主线程任务] 主线程是一个拥有 handler 和 Looper 的消息循环。主线程上创建的 Handler 会自动与它的 Looper 相关联。主线程上创建的这个 Handler 也可以传递给另一线程。传递出去的 Handler 与创建它的线程 Looper 始终保持着联系。因此，已传出 Handler 负责处理的所有消息都将在主线程的消息队列中处理。 123456789101112131415161718// HandlerThread 文件// 来自主线程的 Handlerprivate Handler mResponseHandler;private ThumbnailDownloadListener&lt;T&gt; mThumbnailDownloadListener;// 新增监听器接口 响应下载请求public interface ThumbnailDownloadListener&lt;T&gt;&#123; void onThumbnailDownloaded(T target, Bitmap bitmap);&#125;public void setThumbnailDownloadListener(ThumbnailDownloadListener&lt;T&gt; listener)&#123; mThumbnailDownloadListener = listener;&#125;public ThumbnailDownloader(Handler responseHandler)&#123; super(TAG); mResponseHandler = responseHandler;&#125; 1234567891011121314// 主线程创建的HandlerHandler responseHandler = new Handler();mThumbnailDownloader = new ThumbnailDownloader&lt;&gt;(responseHandler);mThumbnailDownloader.setThumbnailDownloadListener( new ThumbnailDownloader.ThumbnailDownloadListener&lt;PhotoHolder&gt;() &#123; // 实现接口中的抽象方法，来更新UI @Override public void onThumbnailDownloaded(PhotoHolder photoHolder, Bitmap bitmap) &#123; Drawable drawable = new BitmapDrawable(getResources(), bitmap); photoHolder.bindDrawable(drawable); &#125; &#125;); 那么就有一个疑问了，如果在这里面更新UI，那么在PhotoAdapter中的 onBindViewHolder() 中的 1mThumbnailDownloader.queueThumbnail(photoHolder, galleryItem.getUrl()); 是什么用途呢？ 其实显而易见 queueThumbnail() 方法的作用是向消息队列中添加下载请求，而下载之后负责更新UI是利用在主线程创建的 mResponseHandler 处理的。 说回正题，现在，通过mResponseHandler，ThumbnailDownloader能够使用与主线程 Looper 绑定的 Handler。同时，还有ThumbnailDownloadListener 使用返回的 Bitmap 执行UI更新操作。具体来说，就是通过 onThumbnailDownloaded 实现，使用新下载的 Bitmap 来设置 PhotoHolder 的 Drawable。 我们在 handleRequest 方法中添加下面代码 12345678910mResponseHandler.post(new Runnable() &#123; @Override public void run() &#123; if(mRequestMap.get(target) != url || mHasQuit)&#123; return; &#125; mRequestMap.remove(target); mThumbnailDownloadListener.onThumbnailDownloaded(target, bitmap); &#125;&#125;); Message设有回调方法属性后，取出队列的消息是不会发给target Handler的。相反，存储在回调方法中的 Runnable 的 run() 方法会直接执行。 那么上述代码有什么作用呢？ 首先，它再次检查 requestMap。这很有必要，因为 RecyclerView 会循环使用其视图。在ThumbnailDownloader下载完成 Bitmap 之后，RecyclerView可能循环使用了 PhotoHolder 并相应请求了一个不同的URL。该检查可保证每个PhotoHolder都能获取到正确的图片，即使中间发生了其他请求也无妨。 接下来，检查mHasQuit值。如果ThumbnailDownloader已经退出，运行任何回调方法可能都不太安全。 最后，从requestMap中删除配对的PhotoHolder-URL，然后将位图设置到目标PhotoHolder上。 总结最后，我们做一个流程总结，当然，很多细节我没有写在里面，例如mResponse的监听器接口、清理队列、处理完一个Handler之后在Map中删除相应的target，仅供参考。 流程总结 之后会从源码的角度继续分析Android的Handler机制。","tags":[{"name":"线程","slug":"线程","permalink":"http://www.allenmistake.top/tags/线程/"}]},{"title":"这应该是我的博客里面讲网络最详细的一篇","date":"2019-09-18T12:42:31.000Z","path":"2019/09/18/net/","text":"一直想写一篇关于计算机网络的总结，这次算是实现了，肯定不会一次性写完， 我会不定期的更新， 感兴趣的朋友可以持续关注一下。 网络模型七层模型（从下到上排序） 物理层 建立、维护、断开物理连接 数据链路层 建立逻辑连接、进行硬件地址寻址、差错校验等功能。将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。 网络层 进行逻辑地址寻址，实现不同网络之间的路径选择。 我们熟悉的 IP 协议，还有 ARP、ICMP都是在这一层 传输层 定义传输数据的协议端口号，以及流控和差错校验。 最著名的就是TCP、UDP 会话层 建立、管理、终止会话。 表示层 数据的表示、安全、压缩 应用层 网络服务的用户的接口。直接与用户相连。日常使用的HTTP、HTTPS都是在这一层。 五层协议我们重点了解现在的五层模型，在七层模型的基础上，将数据链路层和物理层合并为网络接口层，应用层、表示层、会话层合并为应用层。 HTTP协议传输时报文内容结构变化 下面我们专门说几个重点的层级、协议 数据链路层这一层其实没什么可说的， 他们把上一层（网络层）数据报加头和尾，封装成帧， 其中包含源 MAC 地址 和目的 MAC 地址。这里的差错控制方式基本没有，只有差错检验(CRC)， 那么数据链路层是怎么知道目的地址的 MAC 地址呢？这就要说到网络层的 ARP 和 RARP 协议 网络层ARP 和 RARP协议ARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存（就是一个IP-MAC地址对应表缓存）。 如果查询的IP-MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址。如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机。 而广播主机拿到ARP包后会更新自己的ARP缓存（就是存放IP-MAC对应表的地方）。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。 RARP协议的工作与此相反，不做赘述。 IP 协议注意，IP 是不可靠传输协议，他并没有提供数据传达以后的差错控制机制。 TCP、UDP TCP、UDP TCP、UDP相应应用层协议 什么时候应该使用TCP？当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 什么时候应该使用UDP？当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。例如：QQ电话、QQ视频 TCP连接的建立与终止三次握手 客户端 - &gt; 服务端 （SYN = 1， Seq = X） 服务端 - &gt; 客户端 （SYN = 1, ACK = X + 1, Seq = Y） 客户端 - &gt; 服务端 （ACK = Y + 1, Seq = Z） 为什么要三次握手？如果有消息在传输的过程中由于某些原因没有及时传到服务端，等到在传到服务端的时候，服务端已经不需要了，但是此时接收到过期消息的服务端仍然认为这是一个请求建立连接的报文，那么他就会向客户端发送一个确认连接（第二次握手），如果仅有两次握手，此时连接建立，而客户端并没有消息传入服务端，（本来就是服务端自作多情嘛），那么服务端就会一直变为等待消息传入状态，造成资源浪费。 四次挥手 主动方 - &gt; 被动方（Fin = 1，ACK = Z Seq = X） 被动方 - &gt; 主动方 （ACK = X + 1, Seq = Z） 被动方 - &gt; 主动方 （Fin = 1， ACK = X, Seq = Y） 主动方 - &gt; 被动方 （ACK = Y, Seq = X） 关于四次挥手，我本人是比较生疏的，所以这里我分别解释一下4次挥手的含义 主动方表示：我没有数据要发给你了 进入FIN_WAIT_1状态 被动方表示：我同意了，稍等 主动方收到之后，进入FIN_WAIT_2状态（半连接，等待被动方忙完手头工作） 被动方表示：关闭连接吧 被动方正式进入LAST_ACK状态 主动方进入 主动方表示：好的 主动方进入 TIME_WAIT状态， 被动方接收之后关闭连接，主动方等2MSL之后没有收到回复，也关闭连接 为什么要进行四次挥手呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，也就是你传给我的同时我也可以传给你。这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。 Http请求和响应（未完待续）","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://www.allenmistake.top/tags/计算机网络/"}]},{"title":"Android网络库之HttpURLConnection与数据解析","date":"2019-09-17T10:13:06.000Z","path":"2019/09/17/httpurlconnection/","text":"网络连接基本对于 Android 中的网络问题， 我们要着重学习其中的工作原理，这篇文章主要来说一说 Android 自己的库中，是怎样利用 Http 协议请求数据的。 12345678910111213141516171819202122public byte[] getUrlBytes(String urlSpec) throws IOException&#123; URL url = new URL(urlSpec); HttpURLConnection connection = (HttpURLConnection) url.openConnection(); try&#123; ByteArrayOutputStream out = new ByteArrayOutputStream(); InputStream in = connection.getInputStream(); if(connection.getResponseCode() != HttpURLConnection.HTTP_OK)&#123; throw new IOException(connection.getResponseMessage() + \":with \" + urlSpec); &#125; int bytesRead = 0; byte[] buffer = new byte[1024]; while((bytesRead = in.read(buffer)) &gt; 0)&#123; out.write(buffer, 0, bytesRead); &#125; out.close(); return out.toByteArray(); &#125;finally &#123; connection.disconnect(); &#125;&#125; getUrlBytes（String）方法能从指定URL获取原始数据并返回一个字节流数组。getUrlString（String）方法则将getUrlBytes（String）方法返回的结果转换为String。 在 getUrlBytes( String ) 方法中，首先根据传入的字符串参数，如 https://www.baidu.com （顺带提一句，http后面的s时一定要加的），创建一个 URL对象。然后调用 openConnection() 方法创建一个指向要访问URL的连接对象。URL.openConnection() 方法默认返回的是 URLConnection 对象， 但要链接的是http URL， 因此需将其强制类型转换为 HttpURLConnection 对象。这让我们得以调用他的 getInputStream() 、getResponseCode() 方法。 虽然 HttpURLConnection 对象提供了一个连接欸， 但只有调用 getInputStream() 方法时（如果是 POST 请求， 则调用 getOutputStream() 方法）， 它才会真正连接到指定的URL地址，才会给你反馈代码。 AsyncTask 在后台线程上运行代码首先在主程序中创建一个内部类来声明 AsyncTask 工具类，定义自己要在线程中做什么耗时操作 123456789101112private class FetchItemsTask extends AsyncTask&lt;Void, Void, Void&gt;&#123; @Override protected Void doInBackground(Void... params)&#123; try&#123; String result = new FlickrFetchr().getUrlString(\"https://www.baidu.com\"); Log.i(TAG,\"Fetched contents of URL:\" + result); &#125; catch(IOException ioe)&#123; Log.e(TAG,\"Failed to fetch URL:\", ioe); &#125; return null; &#125;&#125; 随后，我们在 fragnment 主程序中调用 让AsyncTask在后台运行 123456@Overridepublic void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setRetainInstance(true); new FetchItemsTask().execute();&#125; 调用 execute() 方法会启动 AsyncTask， 进而触发后台线程并调用 doInBackground(...)方法。 Android中的线程 Android中的线程 关于线程的详细说明，会在下一篇中展开介绍，JSON解析有待补充 网络中 JSON 解析当浏览器向服务器请求数据时，成功之后服务器会返回数据，这个数据的格式多种多样，其中有XML，HTML，JSON，在这里面我们用 JSON 举个例子。请看下面代码 1234567891011121314151617181920212223public List&lt;GalleryItem&gt; fetchItems()&#123; List&lt;GalleryItem&gt; items = new ArrayList&lt;&gt;(); try&#123; String url = Uri.parse(\"https://api.flickr.com/services/rest/\") .buildUpon() .appendQueryParameter(\"method\", \"flickr.photos.getRecent\") .appendQueryParameter(\"api_key\", API_KEY) .appendQueryParameter(\"format\", \"json\") .appendQueryParameter(\"nojsoncallback\", \"1\") .appendQueryParameter(\"extras\", \"url_s\") .build().toString(); String jsonString = getUrlString(url); Log.i(TAG, \"Received JSON: \" + jsonString); JSONObject jsonBody = new JSONObject(jsonString); parseItems(items, jsonBody); &#125;catch (IOException ioe)&#123; Log.e(TAG, \"Failed to fetch items？？？\", ioe); &#125; catch (JSONException je) &#123; Log.e(TAG, \"Failed to parse\", je); &#125; return items;&#125; 从程序上来看，我们首先构建了请求URL，随后 getURLString() 来获取返回的数据，官方的API中含有getRecent方法， 我们首先指定请求的具体方法，然后输入ID来获取请求资格， 注意，有些网页默认返回 XML 格式数据，我们需要指定 format 为 json。 当然，我们现在获取的 JSON 是乱糟糟的一坨，我们需要从这里面找到我们真正需要的数据，请看下面代码 123456789101112131415161718192021222324//将读到的json分name解析private void parseItems(List&lt;GalleryItem&gt; items, JSONObject jsonBody) throws IOException, JSONException&#123; // 通过JSON解析，注意JSON获取的是对象树结构，详细结构参考下图 JSONObject photosJsonObject = jsonBody.getJSONObject(\"photos\"); JSONArray photoJsonArray = photosJsonObject.getJSONArray(\"photo\"); for(int i = 0; i &lt; photoJsonArray.length(); i++)&#123; // 获取JSONArray中每一个成员，加入List JSONObject photoJsonObject = photoJsonArray.getJSONObject(i); GalleryItem item = new GalleryItem(); item.setId(photoJsonObject.getString(\"id\")); item.setCaption(photoJsonObject.getString(\"title\")); if(!photoJsonObject.has(\"url_s\"))&#123; continue; &#125; item.setUrl(photoJsonObject.getString(\"url_s\")); items.add(item); &#125;&#125; JSON数据解析过程","tags":[{"name":"网络","slug":"网络","permalink":"http://www.allenmistake.top/tags/网络/"}]},{"title":"多种多样的单例模式","date":"2019-09-15T15:59:54.000Z","path":"2019/09/15/singleton/","text":"饿汉模式特点：基于类加载机制， 避免了多线程的同步问题，在类加载时期就已经生成。所以必定只有唯一一个。同时会降低类加载速度，而且如果这个实例不会被使用，会造成内存浪费。 1234567public class Singleton&#123; private static Singleton instance = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 懒汉模式（线程不安全）1234567891011public class Singleton&#123; private static Singleton instance; private static Singketon()&#123; &#125; public static Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 懒汉模式（线程安全）12345678910public class Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; public static synchronized Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 双重检查模式（DCL）12345678910111213public class Singleton&#123; private volatile static Singleton singleton; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(instance == null)&#123; synchronized (Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; &#125;&#125; 静态内部类特点：首先我们要明确一点，类加载的时候，外部类中的静态内部类是不会被加载的，只有在被调用的时候才会被加载。这也是静态内部类方法区别于饿汉模式的地方。只有在 getInstance() 方法被调用后，才会产生实例，且唯一。 123456789public class Singleton&#123; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return SingletonHolder.sInstance; &#125; private static class SingletonHolder&#123; private static final Singleton sInstance = new Singleton(); &#125;&#125; 枚举单例123456public enum Singleton&#123; INSTANCE; public void doSomeThing()&#123; ... &#125;&#125; 使用场景 整个项目需要一个共享访问点或共享数据 创建一个对象需要消耗的资源过多， 比如访问 I/O 或者数据库等资源。 工具类对象","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.allenmistake.top/tags/设计模式/"}]},{"title":"九月的前奏","date":"2019-09-02T03:04:41.000Z","path":"2019/09/02/monthlysummary/","text":"我发现hexo博客部署真的有太多问题，最近又出现了很多之前没有出现过的小毛病，虽说不是致命问题，但也是很恶心。 所以考虑之后还是转到CSDN里面，尽管广告界面杂乱，但好在部署方便，这二者未来要好好权衡一下。","tags":[]},{"title":"ListView的优化、与RecyclerView简单对比","date":"2019-08-22T14:15:17.000Z","path":"2019/08/22/listview-vs-recyclerview/","text":"从逐渐被弱化的ListView说起说到ListView，它曾经是Android UI开发中用的最多的组件之一，直到现在，很多应用还是用的ListView结构，但是现在逐渐被 androidx 中的 RecyclerView 所取代。 ListView的布局是自己实现的， 使用ViewHolder提高运行效率ViewHolder 模式是提高 ListView 效率的一个很重要的方法。 ViewHolder 模式充分利用了 ListView 的视图缓存机制，避免了每次在调用 getView() 都通过 findViewById() 实例化控件。 1234567891011121314151617181920public View getView(int position，View convertView，ViewGroup parent)&#123; Fruit fruit = getItem(position); View view; ViewHolder viewHolder; if(convertView == null&#123; view = LayoutInflater.from(getContext()).inflate(resourceId，parent，false); viewHolder = new ViewHolder(); viewHolder.fruitImage=(ImageViewview.findViewById(R.id.fruit_image); viewHolder.fruitName=(TextViewview.findViewById(R.id.fruit_name); view.setTag(viewHolder); //将 ViewHolder存储在View中 &#125;else&#123; view = convertView; //通过Tag找到缓存的布局 viewHolder = (ViewHolder)view.getTag()); &#125; //重新获取ViewHolder viewHolder.fruitImage.setImageResource(fruit.getImageId(; viewHolder.fruitName.setText(fruit.getName()); return view;&#125; 孰优孰劣在谷歌建议使用recyclerView的现在，为什么我们还在这里讨论孰优孰劣呢？ 那么我们就先看看两个组件的优缺点： ListView：优点： 轻量级，当 view 只提供显示功能的话，代码简单。缺点： 实现功能相对有限，如果对于子view有更多功能要求的话，代码复杂。 只能纵向滑动，实现横向滑动代码复杂。 性能较差，需要自己改善代码，避免内存泄露。 RecyclerView优点： 集成多个接口，功能强大。 由于交给LayoutManager，可实现各种滑动方向。 有完善的回收机制。缺点： 重量级，实现简单功能代码量较大。 所以说，对于一些功能简单的应用程序来说，ListView已经足够用了。例如现在微信中的卡券，由于没有实现复杂的动画以及其他事件，用ListView是刚好合适的。","tags":[]},{"title":"Fragment间数据传递","date":"2019-08-16T09:19:52.000Z","path":"2019/08/16/fragmentdata/","text":"项目中的逻辑结构图 主要思想： 要传递crime 的日期给DatePickerFragment，需新建一个newInstance(Date)方法，然后将Date作为 argument 附加给 fragment。 要将新日期返回给CrimeFragment， 并更新模型层以及对应的视图，需将日期打包为extra并附加到Intent，然后调用CrimeFragment.onActivityResult(…)方法，并传入准备好的Intent参数 CrimeFragment 和 DatePickerFragment间的事件流 argument回顾在之前Activity 和 Fragment 传值的过程中，我们使用了 Argument，下面我们回顾一下我们是如何使用它的。 Argument使用 为满足以上要求，通常添加名为 newInstance() 的静态方法给 Fragment类。使用该方法，完成fragment实例及Bundle对象的创建，然后将argument 放入bundle中，最后附加给fragment。 托管activity需要fragment实例时，转而调用newInstance() 方法，而非直接调用其构造函数。并且，为满足fragment创建argument的要求，activity可给newInstance()传入任何需要的参数 传值那么，fragment之间传值同样也需要借助argument 12345678//DatePickerFragment 中的 newInstance 方法，返回一个DPF实例public static DatePickerFragment newInstance(Date date)&#123; Bundle args = new Bundle(); args.putSerializable(ARG_DATE, date); DatePickerFragment fragment = new DatePickerFragment(); fragment.setArguments(args); return fragment;&#125; 当然，与之对应，在 CrimeFragment 中创建 dialog 语句也要改成调用 newInstance 的形式 12//CrimeFragment 中点击事件开启DatePickerFragmentDatePickerFragment dialog = DatePickerFragment.newInstance(mCrime.getDate()); 另外，这里的Date不能直接被 DatePickerFragment 所识别，我们需要对 DatePickerFragment 所接收到的 Date 进行处理，当然这不是重点，这里不展开。 返回更新数据首先，我们要弄清这两个fragment之间的关系。如果是activity的数据回传，我们调用startActivityForResult(…)方法，ActivityManager负责跟踪管理activity父子关系。回传数据后，子activity被销毁，但ActivityManager知道接收数据是哪个activity。 设置目标fragment(关联)可将CrimeFragment设置成DatePickerFragment的Target fragment。这样，在CrimeFragment 和 DatePickerFragment 被销毁并重建后，操作系统会重新关联他们。调用以下方法可建立这种关联 1public void setTargetFragment(Fragment fragment, int requestCode) 在CrimeFragment 中，创建请求代码常量，然后将CrimeFragment设为DatePickerFragment 实例的目标fragment12345678910private static final int REQUEST_DATE = 0; //在onCreatView中设置按钮监听器 @Override public void onClick(View view) &#123; FragmentManager manager = getFragmentManager(); DatePickerFragment dialog = DatePickerFragment.newInstance(mCrime.getDate()); dialog.setTargetFragment(CrimeFragment.this, REQUEST_DATE); dialog.show(manager, DIALOG_DATE); &#125; 传递数据给目标fragment(传值)处理有同一个activity托管的两个fragment之间的数据返回时，可借用Fragment.onActivityResult(…)方法。因此，直接调用目标fragment的Fragment.onActivityResult(…)方法，就能实现数据回传。需要以下信息： 请求代码：与传入 setTargetFragment(…) 方法的代码相匹配，告诉目标 fragment 返回结果来自哪里 结果代码：决定下一步该采取什么行动 Intent：包含extra数据 我们来看一下具体怎么做的 12345678910111213public static final String EXTRA_DATE = \"com.example.criminalintent.date\";private void sendResult(int resultCode, Date date)&#123; if(getTargetFragment() == null)&#123; return; &#125; Intent intent = new Intent(); intent.putExtra(EXTRA_DATE, date); getTargetFragment().onActivityResult(getTargetRequestCode(), resultCode, intent);&#125; 随后，我们将 DatePickerFragment 的确定按钮点击事件修改为调用sendResult(…)方法 12345678910111213return new AlertDialog.Builder(getActivity()) .setView(v) .setTitle(R.string.date_picker_title) .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialogInterface, int i) &#123; int year = mDatePicker.getYear(); int month = mDatePicker.getMonth(); int day = mDatePicker.getDayOfMonth(); Date date = new GregorianCalendar(year, month, day).getTime(); sendResult(Activity.RESULT_OK, date); &#125; &#125;) 最后，在CrimeFragment接收数据 12345678910111213141516@Overridepublic void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if(resultCode != Activity.RESULT_OK)&#123; return; &#125; if(requestCode == REQUEST_DATE)&#123; Date date = (Date)data.getSerializableExtra(DatePickerFragment.EXTRA_DATE); mCrime.setDate(date); updateDate(); &#125;&#125;private void updateDate() &#123; mDateButton.setText(mCrime.getDateStr());&#125;","tags":[]},{"title":"浅谈 ViewPager 使用方法与原理","date":"2019-08-15T12:41:03.000Z","path":"2019/08/15/viewpager/","text":"从功能说起ViewPager 是什么？是一种布局结构，并且还是一个类。当为UI添加ViewPager后，用户可左右滑动屏幕，切换查看不同列表项的明细页面。 需要做哪些工作为了添加ViewPager具体功能实现，我们要做以下工作： 创建 Activity 实例，这个 Activity 里来存放 ViewPager 视图 定义包含 ViewPager 的视图层级结构 在 Activity 类中关联使用 ViewPager 以及 Adapter 项目中MVC层级结构 通过这个结构图我们可以看出，通过点击事件 CrimeListFragment 来启动 CrimePagerActivity ，并且CrimePagerActivity 中包含了一个 ViewPager PagerAdapterViewPager 需要 PagerAdapter 的支持， Google提供了PagerAdapter的子类FragmentStatePaferAdapter ，它能协助处理许多事情。如下面代码所示 12345678910111213FragmentManager fragmentManager = getSupportFragmentManager();mViewPager.setAdapter(new FragmentStatePagerAdapter(fragmentManager) &#123; @Override public Fragment getItem(int position) &#123; Crime crime = mCrimes.get(position); return CrimeFragment.newInstance(crime.getId()); &#125; @Override public int getCount() &#123; return mCrimes.size(); &#125;&#125;); FragmentStatePagerAdapter 提供了两个有用的方法，我们必须进行方法覆盖 getItem(int) 获取并显示crime 数组中指定位置的Crime时，他会返回配置过得CrimeFragment来显示指定的Crime getCount() 返回数组列表中包含的列表项数目 注意，创建FragmentStatePagerAdapter实例需要FragmentManager FragmentStatePagerAdapter 与FragmentPagerAdapter 区别：前者在滑动过后，调用 remove() 方法将 fragment 移除。而后者不会移除，只是销毁了视图，fragment 实例还保存在 FragmentManager 中。 应用：由此看来，后者会占用大量内存来换取加载速度，所以前者在大容量 fragment 的情况下，例如每个 fragment 都是一个高清图片且数量上百上千，那么适合用前者。如果数量少或者比较重视响应or加载速度，建议用后者，加载速度快。 工作原理为何不用RecyclerView上一篇博客提到，RecyclerView也可以提供横着翻的实例，为什么不用它呢？ 由于无法使用现有的fragment， 因此在 CriminalIntent 应用中使用 RecyclerView 需处理大量内部实现工作。Adapter 需要我们及时地提供View。然而，决定 fragment 视图何时创建的是 FragmentManager 。因此， 当RecyclerView 要求Adapter提供fragment视图时，我们无法立即创建fragment并提供视图。所以，核心的区别在于Adapter和PagerAdapter的区别。 PagerAdapter123public Object instantiateItem(ViewGroup container, int position)public void destoryItem(ViewGroup container, int position, Object object)public abstract boolean isViewFromObject(View view, Object object) PagerAdapter.instantiateItem告诉pager adapter创建指定位置的列表项视图， 然后将其添加给ViewGroup视图容器， 而destroyItem告诉pager adapter销毁已建视图。视图创建完成之后，ViewPager会在某个时间点看到它。未确定该视图所属对象， ViewPager会调用isViewFromObject，这里的Obj是instantiateItem返回的对象。因此假设ViewPager调用instantiateItem(ViewGroup, 5)返回A对象，那么只要传入的View参数是第5个对象的视图，isViewFromObject(View, A)方法就应该返回true，否则返回false。 当然，以上这些其实都封装在了FragemntPagerAdapter和FragemntStatePagerAdapter 中，当我们使用的时候并不需要具体实现。 (2019-8-20更新)注意：这里面 FragmentStatePagerAdapter 并不是绝对的退出视野就调用 destoryItem ,当我在Android 模拟器里观察内部调用机制时，我们发现pagerAdapter会保留三个视图，当前视图，上一个视图和下一个视图，猜测是方便加载。举个例子，当我们从第二个视图跳转到第一个视图时，并不会调用 creatItem()，因为 3 -&gt; 2 时已经预先创建了 1。","tags":[]},{"title":"RecyclerView基础","date":"2019-08-13T12:45:50.000Z","path":"2019/08/13/recyclerview/","text":"RecyclerView、ViewHolder和Adapter首先，我们要明确这三个类各自的任务和逻辑结构。 RecyclerView 任务仅限于回收和定位屏幕上的 View ，RecyclerView 自身不会创建视图， 他通过 Adapter 创建。 Adapter 是一个控制器对象， 从模型层获取数据， 然后提供给 RecyclerView 显示，是沟通的桥梁。 他负责： 创建必要的 ViewHolder 绑定 ViewHolder 至模型层数据 Adpater 与 RecyclerView 之间的桥梁 ViewHolder 负责容纳 View 视图 ViewHolder 配合 RecyclerView 使用 使用 RecyclerView12mCrimeRecyclerView = view.findViewById(R.id.crime_recycler_view);mCrimeRecyclerView.setLayoutManager(new LinearLayoutManager(getActivity())); 当我们创建一个 RecyclerView 时， 我们首先要对他进行布局加载， 更要注意的是托管给 LayoutManager。没有 LayoutManager 的支持， 不仅 RecyclerView 无法正常工作， 还会导致应用崩溃。这是为什么呢？实际上， RecyclerView 不会亲自摆放屏幕上的列表项， 摆放的任务委托给了 LayoutManager。 LayoutManager 还负责定义屏幕上的滚动行为（竖着滚还是横着滚等等） ViewHolder 显示视图12345private class CrimeHolder extends RecyclerView.ViewHolder&#123; public CrimeHolder(LayoutInflater inflater, ViewGroup parent)&#123; super(inflater.inflate(R.layout.list_item_crime, parent, false)); &#125;&#125; 在 CrimeHolder 的构造方法中， 我们首先实例化list_item_crime布局，然后传给 super 方法， 也就是 ViewHolder 的构造方法。 基类ViewHolder 因而实际引用这个视图。 Adapter架起桥梁（绑定ViewHolder）12345678910111213141516171819202122232425262728private class CrimeAdapter extends RecyclerView.Adapter&lt;CrimeHolder&gt;&#123; private List&lt;Crime&gt; mCrimes; public CrimeAdapter(List&lt;Crime&gt; crimes)&#123; mCrimes = crimes; &#125; @Override public int getItemCount() &#123; return mCrimes.size(); &#125; @NonNull @Override public CrimeHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) &#123; LayoutInflater layoutInflater = LayoutInflater.from(getActivity()); return new CrimeHolder(layoutInflater, parent); &#125; @Override public void onBindViewHolder(@NonNull CrimeHolder holder, int position) &#123; Crime crime = mCrimes.get(position); //令每个ViewHolder绑定数据，具体bind函数略 holder.bind(crime); &#125; &#125; RecyclerView 需要新的ViewHolder 来显示列表时，会调用 onCcreateViewHolder 方法。在这个方法内部， 我们创建一个 LayoutInflater， 然后用他创建 CrimeHolder。 CrimeAdapter 必须覆盖 onBindViewHolder 方法。桥梁的具体过程： 首先，调用 Adapter 的 getItemCount() 方法， RecyclerView 询问数组里列表中包含多少个对象。 接着，RecyclerView 调用 Adapter 的 onCreateViewHolder(ViewGroup, int) 方法创建 ViewHolder 及其要显示的视图。 最后，RecyclerView 会传入 ViewHolder 及其位置， 调用 onBindViewHolder(ViewHolder, int)方法。Adapter 会找到目标位置的数据并将其绑定到 ViewHolder 的视图上。所谓绑定，就是使用模型数据填充视图。 最后，别忘了关联 Adapter 和 RecyclerView1234567private void updateUI()&#123; CrimeLab crimeLab = CrimeLab.get(getActivity()); List&lt;Crime&gt; crimes = crimeLab.getCrimes(); mAdapter = new CrimeAdapter(crimes); //将具体的 RecyclerView 和 Adapter 关联到一起 mCrimeRecyclerView.setAdapter(mAdapter); &#125;","tags":[]},{"title":"7月——踏上新征程","date":"2019-07-03T12:53:35.000Z","path":"2019/07/03/newtrip/","text":"六月工作总结六月做的最有意义的事情就是尝试了 Flutter 这个新技术，与此同时也通过一件事明白了一个道理，这件事情有时间我会详细讲。不过首先就 Flutter 来讲： 学习一种语言如何使用是很简单的，像 Flutter，学习怎么布局和添加组件时容易的，但是Flutter的渲染机制是怎么样的，你只知道是60FPS，但是她是怎么做到60FPS的，要做到知其然又要知其所以然。 项目很重要，但自己的理解同样重要，做一个简单的小项目不如花点时间把内核思想理解了，把源码看一看，把机制熟悉熟悉。 可以扩展到其他任何学习，Java、JVM、数据结构与算法，不能死记硬背，拿我们最常见的快排来说，不能只是背一下代码，更重要的是知道他的排序过程，做到根据过程知道代码怎么写。 七月展望 数据结构与算法 Java基础知识 做小项目来理解原理部分 并发何网络编程这块最好结合视频观看，有实战操作会好很多 其他感悟电脑前些日子又坏了，最近重装了一下系统，配置环境越来越熟练了，这种老物件还是有点感情在里面的，希望他能陪我走完研究生旅程。","tags":[]},{"title":"dart中的异步初级+获取firebase数据","date":"2019-06-27T13:14:19.000Z","path":"2019/06/27/flutterapp4/","text":"概述Dart是一个单线程的语言，遇到有延迟的运算（比如IO操作、延时执行）时，线程中按顺序执行的运算就会阻塞，用户就会感觉到卡顿，于是通常用异步处理来解决这个问题。当遇到有需要延迟的运算（async）时，将其放入到延迟运算的队列（await）中去，把不需要延迟运算的部分先执行掉，最后再来处理延迟运算的部分。和 Java 中的多线程不同，dart 采用的基于事件的异步模型。简单说就是在某个单线程中存在一个事件循环和一个事件队列，事件循环不断的从事件队列中取出事件来执行，因此，耗时事件不会阻塞整个事件循环，这让它后面的事件也会有机会得到执行。讲到这里，你想起来什么了么。对！Android 中的多线程 Handler/Looper 也是采取这个模式！ async 和 awaitasync 和 await 在项目中的耗时操作有很大应用空间，例如登陆等待操作、网络请求操作。下面我们利用官方文档来具体说明 async 的用途和具体执行流程 1234567891011121314151617181920212223242526272829303132import 'dart:async';Future&lt;void&gt; printDailyNewsDigest() async &#123; var newsDigest = await gatherNewsReports(); print(newsDigest);&#125;main() &#123; printDailyNewsDigest(); printWinningLotteryNumbers(); printWeatherForecast(); printBaseballScore();&#125;printWinningLotteryNumbers() &#123; print('Winning lotto numbers: [23, 63, 87, 26, 2]');&#125;printWeatherForecast() &#123; print(\"Tomorrow's forecast: 70F, sunny.\");&#125;printBaseballScore() &#123; print('Baseball score: Red Sox 10, Yankees 0');&#125;const news = '&lt;gathered news goes here&gt;';const oneSecond = Duration(seconds: 1);// Imagine that this function is more complex and slow. :)Future&lt;String&gt; gatherNewsReports() =&gt; Future.delayed(oneSecond, () =&gt; news); 其中，gatherNewsReport 执行耗时操作，如果不将这个函数进行异步处理，代码执行将会受到阻塞。当使用了异步处理之后，执行顺序如下图所示： 异步程序执行顺序 可以看到，程序的执行顺序如下 程序开始执行 main 函数同步执行 printDailyNewsDigest() 这个异步函数 printDailyNewsDigest() 利用 await 关键词调用gatherNewsReports()耗时操作，并开始执行. gatherNewsReports() 函数返回一个未完成的 future (一个 Future&lt;String&gt; 实例). 因为 printDailyNewsDigest() 是一个异步函数并且正在 await 一个返回值, 他暂停执行并给调用它的main函数返回一个未完成的 future (在这个例子中, 是一个 Future&lt;void&gt; 实例) 剩余的 print 函数被执行，由于他们是同步的，每个函数都可以在下一个函数调用之前被完全执行. 当 main() 函数结束, 异步函数被重新执行. 首先, gatherNewsReports() 返回一个已经完成确定的future值(Future&lt;String&gt;). 随后 printDailyNewsDigest() 函数继续执行打印 news. 当 printDailyNewsDigest() 函数执行完毕, 给 main 函数返回的 future(Future&lt;void&gt;)也完成了, app 退出. 关于异步的讨论，我们在这里先告一段落，之后会更详细的了解，现在只需要知道执行的顺序。下面我们来说一说 firebase。 firebaseFirebase 让移动端应用具有访问后端服务的能力，包括鉴权、存储、数据库以及无服务器托管的服务。国内的话应该类似于 Bmob 系统，不过感觉 firebase 网络体验要差一些，毕竟谷歌的东西。 第一次配置firebase，首先要注册一个firebase账号，如果有的话直接登录就可以。接下来步骤依次是 pubspec.yaml，添加 cloud_firestore 依赖包并保存（如果出现问题打开 android/app/build.gradle，然后找到 minSdkVersion 16 这一行，把这一行改为 minSdkVersion 21，并保存文件。） 在你的 Firebase console 中，点击 Add project，新建一个 Firebase 项目； 在 Flutter 项目目录中，打开文件 android/app/src/main/AndroidManifest.xml；在 manifest 中，找到 package 属性中的值，它代表的是 Android 的包名（类似于 com.yourcompany.yourproject 这样的）复制这个值；这个值填入 package name； 点击 Register App；在 Firebase 中按照里面的步骤下载 google-services.json 文件；回到 Flutter 应用目录，将 google-services.json（就是你刚刚下载的文件）放入到 android/app 目录中； 在 IDE 或者编辑器中，打开 android/app/build.gradle 文件，然后将下列这一行粘贴到文本中： 1apply plugin: 'com.google.gms.google-services' 打开 android/build.gradle 文件，然后在里面的 buildscript 标签下，新增一个依赖： 12345678910buildscript &#123; repositories &#123; // ... &#125; dependencies &#123; // ... classpath 'com.google.gms:google-services:3.2.1' // new &#125;&#125; 在 cloud firestore 中添加自己的数据集 获取数据12345678910Widget _buildBody(BuildContext context) &#123; return StreamBuilder&lt;QuerySnapshot&gt;( stream: Firestore.instance.collection('user').snapshots(), builder: (context, snapshot) &#123; if (!snapshot.hasData) return LinearProgressIndicator(); return _buildList(context, snapshot.data.documents); &#125;, );&#125; 当然，在这之前别忘了导入包。然后我们利用 Firestore.instance.collection(&#39;user&#39;).snapshots() 语句得到对应的数据集，即声明中的Collection，将这些文件传给snapshot 12345678910//读取firebase数据DocumentSnapshot ds;List&lt;DocumentSnapshot&gt; l;var userMap = Map&lt;String, String&gt;();l = snapshot.map((data) =&gt; ds = data).toList();for (int i = 0;i&lt;l.length;i++)&#123; record = Record.fromSnapshot(l[i]); userMap.putIfAbsent(record.name, () =&gt; record.pw);&#125; 首先我们定义了DocumentSnapshot类型变量，随后核心代码 1l = snapshot.map((data) =&gt; ds = data).toList(); (data)相当于一个迭代器(这个语法查了半天才知道)，随后我们将snapshot中存储的DocumentSnapshot 转换为 List 类型，方便我们读取。在此之前，我们要定义一个接受数据的类型，在我的项目里定义了一个 Record 类型，来存储 firestore 中的数据类型 userName 和 passWord，代码如下 123456789101112131415class Record &#123; final String name; final String pw; final DocumentReference reference; Record.fromMap(Map&lt;String, dynamic&gt; map, &#123;this.reference&#125;) : assert(map['userName'] != null), assert(map['passWord'] != null), name = map['userName'], pw = map['passWord']; Record.fromSnapshot(DocumentSnapshot snapshot) : this.fromMap(snapshot.data, reference: snapshot.reference); @override String toString() =&gt; \"Record&lt;$name:$pw&gt;\";&#125; 最后，为了方便在程序中使用，我们建立了一个 Map ，首先将我们需要的数据（在这个项目中是用户名和密码）加入 Map ，来使得数据之间通过映射关系可以相互查找， 码那么多字好累啊，加油干！","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://www.allenmistake.top/tags/Flutter/"},{"name":"开源项目","slug":"开源项目","permalink":"http://www.allenmistake.top/tags/开源项目/"}]},{"title":"自己动手Flutter——动画初步","date":"2019-06-23T08:54:44.000Z","path":"2019/06/23/flutterapp3/","text":"动画基本原理我们首先在 State 类里声明 Animation 类型和 AnimationControler 类型，Animation 是负责产生变化值的控件，而 Controler 是 负责动画的生成的。注意，如果需要用的动画控件，类声明必须要跟着 with SingleTickerProviderStateMixin如果在不同时刻有着不同的动画效果，就涉及多个 controler 此时就要声明 with TickerProviderStateMixin 123Animation&lt;double&gt; animation;AnimationController controller;Animation&lt;double&gt; animationAI; 方法重写如果想要具体定义动画是怎样进行的，一定要重写 initState() 和 dispose()。如下方代码所示 123456789101112131415161718192021222324252627@overridevoid initState() &#123; super.initState(); //设置 control 的持续时间 controller = new AnimationController( duration: const Duration(seconds: 2), vsync: this); //以下是产生动画的核心代码，设置了开始状态和结束状态 //这个值和animation应用的控件属性有关，下面会细说 animation = new Tween(begin: -1.0, end: -0.25).animate( CurvedAnimation(parent: controller, curve: Curves.fastOutSlowIn)) ..addStatusListener((status) &#123; //..addStateListener 可以监听动画是否完成 if (status == AnimationStatus.completed) &#123; _pressCard(myCard); &#125; else if (status == AnimationStatus.dismissed) &#123; controller.forward(); &#125; &#125;); animationAI = new Tween(begin: 1.0, end: 0.25).animate( CurvedAnimation(parent: controller, curve: Curves.fastOutSlowIn));&#125;@overridevoid dispose() &#123; controller.dispose(); super.dispose();&#125; 我们在 build 函数外面定义了动画之后，我们就可以在控件中应用他们了 在控件中应用动画123456789101112131415161718192021AnimatedBuilder( animation: controller, builder: (BuildContext context, Widget child) &#123; return Transform( transform: Matrix4.translationValues( animationAI.value * width, 0.0, 0.0), child: new Center( child: Container( padding: const EdgeInsets.only(top: 16.0), width: 100.0, height: 100.0, child: Image( image: ExactAssetImage(\"$aiPicPath\"), width: 40, height: 40, ), ), ), ); &#125;), 在要使用动画的控件位置，首先要声明一个 AnimationBuilder ，并且首先定义它的 animation属性，将这个控件的动画发生与 control 绑定在一起，最后再builder 返回一个动画类型，我的 App 里返回的是一个 Transform 类似于平移的一个动画，核心代码是 transform: Matrix4.translationValues(animationAI.value * width, 0.0, 0.0), 此段代码效果则是产生平移效果。效果如下 平移动画效果 重置、开启动画12controller.reset();controller.forward(); 我们将以上两行代码添加到 onPressed 属性中，这样每次点击按钮的时候都会重置并且播放动画。 setState 和 addStatusListener在 Flutter 中，带有 State 字样的基本都会更新UI，onPressed 中的 setState 函数可以让其中改变的参数马上更新到 UI ，其中的函数一经修改，setState 会立即寻找页面中会调用到该参数的位置，迅速刷新。 addStateListener 同样也是这个含义，他监听动画的状态，以便在动画停止时（或其他状态）用户可以定义参数变化，来改变UI，在这里的应用就是，当动画播放完之后，再调用结果通知 dialog，如果不这样做的话，动画和 dialog 同时触发，没有效果。","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://www.allenmistake.top/tags/Flutter/"},{"name":"开源项目","slug":"开源项目","permalink":"http://www.allenmistake.top/tags/开源项目/"}]},{"title":"Awesome Flutter","date":"2019-06-21T14:19:47.000Z","path":"2019/06/21/FlutterStudy/","text":"简介本文大部分内容翻译自 Github 中 Awesome Flutter 项目，该项目集合了当下学习 Flutter 的优秀文章及开源项目，然而该项目对于所陈列的项目只有简单的分类，并没有做简要的说明。 当然如果看不了英文可以去看这篇翻译的文章，Awesome Flutter中文版 是由国内Coder翻译的，翻译质量不错，但仍缺少对文章内容的概括。 这篇文章的目的是想做一个简单的梳理，并对文章内容进行简化，整理成适合初学者。 手把手教你动手Flutter如果你觉得自己对属于自己的 Flutter App 一筹莫展时，你可以看看其他人是怎么开发的App，一下这些 App 功能简单，但是对于初学者，手打出来是很有帮助的，建议大家在编译器好好敲一敲，体会一下： 开发一个安卓应用 —— 配置和开发第一个应用，作者是 Ashraff Hathibelagal。注意：采用的是IntelliJ IDEA，个别设置可能和 AS 不同，不过不影响程序的编写。这里并没有给出 Flutter 官方的教程，不知道为什么，可以通过第二篇跳转到官方给出的 Flutter 超级入门教学。难度：★ Animated Chat —— 创建漂亮的 UI，来自谷歌代码实验室（Google Code Labs）。如果说第一个侧重于如何使用编译器编写运行Flutter App，那么这个则是将内容具体到对于布局和控件的使用。难度：★ Firebase Chat —— Firebase integration，来自谷歌代码实验室。如果你想快速了解 Firebase 这个 Flutter 工具，那么这篇文章是你的入门之选，只需要你对面向对象语言有所掌握即可。 难度：★ Planets-Flutter：从设计到开发 —— 详细的 planets design 教程。这是一个手把手教你做出好看应用的博客，设计到基础动画，页面跳转等知识，缺点是全英文，而且停更了难度：★~★★ 个人博客 Flutter Institute既含有手把手教你写 App 的教程，并且更新一些开发中会遇到的问题。还算不错难度：★~★★★ Flutter by Example很推荐看的博客，里面涵盖了很多常用的控件工具库，例如网络库，动画库，登陆界面等等。强烈推荐！难度：★★ 组件示例 官方 Gallery —— 来自 Flutter 团队的展示 Material Design 风格的 Widget 和一些其他功能展示的示例 APP。对于一些新功能，基础控件，参考官方的写法可能是最简单直白的，缺点是官网没有讲解部分，但是很全！实用度：★★★★ Flutter 示例（708 ★）—— 为 Flutter 开发者提供的一个简单基础的独立应用，作者是 Nishant Srivastava。类似于官方给出的，这两个结合观看基本上就可以设计出美观的 Flutter App 了实用度：★★★★ UI这些 UI 设计是我挑出来比较实用的设计，其实都是很实用的，只不过对于我来说应用场景比较小，于是就落榜了。 Contact Picker —— 从通讯录里选取一个联系人，作者是 Michael Goderbauer StaggeredGridView（115 ★）—— 具有不同尺寸磁贴（tile）的 GridView，作者是 Romain Rastel。实用度：★★★★ Sticky Header (27 ★) - 长条式固定headers by Romain Rastel.实用度：★★★ Sticky Headers (73 ★) - Configurable sticky headers by Simon Lightfoot.可以设置内容的固定headers。实用度：★★★ 径向菜单（76 ★）—— 带动画的径向菜单，作者是 Victor Choueiri。 Tinder 卡片（58 ★）—— Tinder like 卡片滑动效果，作者是 Ivascu Adrian。实用度：★★★ Login Animation (119 ★) - 从登录平滑过渡到主页的动画 Ruchika Gupta.实用度：★★★★★ List Drag&amp;Drop (55 ★) - 表单内容拖拽by Norbert515.实用度：★★★★ Calendar Widget (8 ★) - 按照时间顺序记录事件的 widget by David Bennett.实用度：★★ Shimmer (55 ★) - Shimmer effect while content is loading by HungHD.给 widget 加波浪阴影特效实用度：★★★ 图片 Image Picker —— 图片选择器，作者是 Collin Jackson。很实用的库，用来选择照片库中的一个图片，或是自己拍一张。实用度：★★★★★ Carousel Slider（42 ★）—— 旋转滑动小部件，支持无限滚动和自定义子部件，作者是 serenader。图片无限滑动实用度：★★★★ Photo View (25 ★) - Scalable image view with loading placeholder by Renan C. Araújo.图片放缩、截图管理、照片Galaxy集合实用度：★★★ 导航、路由 Fluro（292 ★）—— 具有导航、通配符、查询、过渡动画的最亮、最时尚、最酷的 Flutter 路由器，作者是 Posse。 Circle Indicator（12 ★）—— PageViewer 的圆形指示器，作者是 Lung Razvan。 Quick Actions —— 与应用程序的主屏幕快速操作进行交互。 Swiper (12 ★) - Horizontal, Vertical, Partial swipe with indicator by Xueliang Ren. 认证 本地身份验证 —— Ios 和 Android 上的 Touch ID、锁屏密码和指纹验证 Flutter 登录（96 ★）—— FaceID, TouchID, 还有指纹扫描，作者是 Rody Davis。 Google Sign-In —— Google 身份验证。 Firebase Auth —— Firebase 身份验证。 Facebook Login (62 ★) - Authenticate with native Android &amp; iOS Facebook login SDKs by Iiro Krankka. Flutter OAuth（44 ★）—— Buffer、Strava、Unsplash 和 Github 身份验证，作者是 Joe Birch。 Instagram —— Instagram 身份验证，作者是 Wilfried Mbouenda Mbogne。 文字和富文本 Masked Text (6 ★) - Masked text with custom and monetary formatting by Ben-hur Santos Ott.给文本输入加上自定义mask，比如信息遮盖 * 、或者自动添加 - 。等 风格 Flutterial（46 ★）—— Flutter Material 主题的探索者，作者是 Erick Ghaumez。 Frosted Glass —— 渲染器效果，作者是 Collin Jackson。 Font Awesome —— Font Awesome 图标包，作者是 Brian Egan。 FlutterIcon —— 图标字体生成器。 Pigment（27 ★）—— 简单但是很实用的在 Flutter 里面使用颜色的包。 多媒体 音频插件（95 ★）—— Beta 版，作者是 Erick Ghaumez。 录音机（24 ★）—— 录制音频并存储在本地，作者是 Jordan Alcaraz。 Stereo（22 ★）—— 在 iOS 和 Android 上面播放音乐，作者是 2Find。 WebRTC (80 ★) - WebRTC plugin for iOS/Android by CloudWebRtc. Chewie (70 ★) - Provides low-level access to video playback by Brian Egan. 语音 Speech Recognition（41 ★）—— 语音转文字，作者是 Erick Ghaumez。 OK Google —— 整合了 Google 语音助手，作者是 Marcin Szalek。 存储 Firebase Storage —— 用 Firebase 作为数据存储设备。 Secure Storage (23 ★) - Keychain and Keystore storage by German Saprykin. 模板 Movie Details（93 ★）—— 电影详情页面，作者是 Iiro Krankka。 Flutter Mates（160 ★）—— 如何从 randomuser.me API 加载个人信息列表，并通过一个漂亮的页面展示个人信息详情，作者是 Iiro Krankka。 Weather（50 ★）—— 学习如何使用 Canvas 和动画去制作天气应用，作者是 Alessandro Aime。 TodoMVC（644 ★）—— 准备使用不同框架的备忘录应用：Vanilla, Redux, built_redux，作者是 Brian Egan。 Restaurant Menu（219 ★）—— 饭店菜单，作者是 Braulio Cassule。 UI 挑战（222 ★）—— 个人信息应用、旅行应用、美食应用，作者是 Tomi Alagbe。 Cupertino Settings（19 ★）—— iOS 设置，作者是 Matthias Rupp。 Music Player（59 ★）—— 音乐播放器部件，作者是 Tobe O。 Dashboard（142 ★）—— 仪表板和商品列表，作者是 Ivascu Adrian。 Todo (94 ★) - Todo template from Dribble by Marc L. Card Swipe Animation (40 ★) - Swipe cards template by Ruchika Gupta. 插件 Flutter 插件 —— Flutter 团队的官方插件 Sqflite（221 ★）—— SQLite 的 Flutter 插件，作者是 Alexandre Roux。 WebView（152 ★）—— 作者是 Hadrien Lejard。 Pub Plugins —— Dart Pub Repository 的筛选插件。 Flutter Location（79 ★）—— 处理位置，处理回调以获得连续的位置，作者是 Lyokone。 QR Code Reader（32 ★）—— 二维码扫描插件，作者是 Matheus Villela。 Battery —— 获取电池相关的各种信息。 Zebra EMDK（3 ★）—— 使用 Zebra EMDK 来获取 Barcode Scanner API。 Proximity Sensor Plugin —— 一个可以访问你设备上的距离传感器（proximity sensor）的插件，作者是 Manoj NB。 Geolocation（72 ★）—— 功能齐全的地理位置插件：当前位置，位置更新，地理编码，地点等等，作者是 Loup。 Local Notifications（62 ★）—— 展示本地通知的插件，作者是 Michael Bui。 App Rating（20 ★）—— 为 App Store 和 Google Play 评分和写评论，作者是 Rody Davis。 Get Version（13 ★）—— 获取版本名、版本号、App ID 和带有操作系统版本的平台信息，作者是 Rody Davis。 Downloader (23 ★) - Create and manage download tasks by HungHD. Place Dialog (9 ★) - Places picker dialog returning the places to the app by David Bennett. Cached Network Image (61 ★) - Show images from the internet and keep them in the cache directory by Rene Floor. Device Calendar - Plugin for modifying calendars on the user’s device by Built to Roam. 蓝牙 / NFC / Beacon Flutter Ble（45 ★）—— 蓝牙，作者是 Polidea Flutter Blue（142 ★）—— 蓝牙，作者是 Paul DeMarco。 NFC (12 ★) - Connect IsoDep iso 14443-4 cards for android by Göksel Uyulmaz. Beacons (4 ★) - Flutter beacons plugin by Loup. 开源 APP当学会了一些基础之后，可以去看看别人编写的 App 来提高自己对于 App 设计模式以及层级结构的理解，没有结构和层次的 App 是很糟糕的。 FriendlyChat（106 ★）—— 一群谷歌员工开发的离线或者是基于 Firebase 的聊天应用。 Meme Chat（244 ★）—— Flutter 上的聊天应用，用到了 Firebase、谷歌登陆和设备相机集成，作者是谷歌员工。 Flitter（83 ★）—— Glitter 客户端，作者是 Hadrien Lejard 和 Kevin Segaud。里面用到了 Redux 和 Jaguar。 Lime ——（129 ★）Lime 是 Sebastian Sellmair 开发的社交网络应用。 Planets-Flutter（149 ★）—— 显示了丰富 UI 的行星探索应用，作者是 Sergi Martínez。 NewsBuzz（175 ★）—— 从 News API 获取数据并使用 Firebase 做后台的新闻阅读器，作者是 Ankur Kedia。 DroidKaigi2018-flutter（226 ★）—— 东京 DroidKaigi 2018 的非官方会议应用，作者是 konifar。 Music Player（178 ★）—— Pawan Kumar 开发的全功能音乐播放器。 InKino（820 ★）—— 完整的电影应用程序，使用 Flutter_Redux 框架进行状态管理，具有很好的过渡动画，以及一套很全面的小部件还有单元测试，作者是 Iiro Krankka。 WhatTodo (105 ★) - Todoist like UI by Burhanuddin Rashid. FlutterGram (74 ★) - Complete Instagram based on Firestore &amp; Google Functions by MDanics. BookSearch (97 ★) - Digital BookShelf for your reading progress by Norbert515. Cinematic (145 ★) - UI for Movie DB Public API by Aaron Oertel. Beer-Me-Up (75 ★) - Beer tracking nicely designed by Benoit Letondor. 以上这些开源代码质量都还是比较高的，大家可以有针对性地看其中的一两个。","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://www.allenmistake.top/tags/Flutter/"}]},{"title":"自己动手Flutter——项目三步走","date":"2019-06-18T14:07:04.000Z","path":"2019/06/18/flutterapp2/","text":"项目的三步走策略 三步走 暂时是这个思路，预计如果时间充裕的话，一个月之内到第二阶段是没有问题的，至于联机方面，心里比较没底。 还有一个问题是今天投了西瓜的移动端开发，在大厂里面实习感觉会尽可能的提升自己敲代码的能力。 最近的问题及解决方案onPressed如果点击事件涉及到当前页面的UI更新，onPressed: (){}函数里面一定要定义setState()函数，在这个函数中进行 UI 相关参数修改，不然系统不会即时刷新 UI 关于这点，初始 App 源码说的比较精髓： This call to setState tells the Flutter framework that something has changed in this State, which causes it to rerun the build method below so that the display can reflect the updated values. If we changed _counter(更新 UI 所需参数) without calling setState(), then the build method would not be called again, and so nothing would appear to happen. 页面间传值不得不说，页面间传值这个问题困扰了我一天的时间，在网上查相关资料查得焦头烂额，其实现在来看还是蛮简单的： 传入参数： 1234567891011Navigator.push&lt;List&gt;( context, new MaterialPageRoute( builder: (BuildContext context) =&gt; new SetPage(widget.card1, widget.card2, widget.card3), ),).then((List result) &#123; if (result[0] != '') widget.card1.cardName = result[0]; if (result[1] != '') widget.card2.cardName = result[1]; if (result[2] != '') widget.card3.cardName = result[2];&#125;); 可以看出，传入参数还是比较简单的，只要给新 new Page 加一个构造函数，然后生成新页面的时候把参数传过去就行；难点在于参数返回，核心代码在于 Navigator 中的 push 操作，首先要在 push 后面加上 &lt;返回的数据类型&gt; 这么一个泛型结构，随后在 push 后面 接上 .then 函数，这个函数的参数就是你要接受的参数括号里面是接受的类型和值，花括号里面接受的是后续相关处理操作。 Widget界面的溢出在网上找了半天关于溢出的相关问题，溢出的问题通常都是由 Row 或是 Column 设置不当导致，最终大家都倾向于将 Row、Column 中的 children 放入 Expanded 中，保持安全边界，这会使得被 Expanded 保护的 widget 以Row、Column方式撑满整个屏幕，并且这个边界是自适应的。","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://www.allenmistake.top/tags/Flutter/"},{"name":"开源项目","slug":"开源项目","permalink":"http://www.allenmistake.top/tags/开源项目/"}]},{"title":"自己动手Flutter——View初步","date":"2019-06-16T14:35:21.000Z","path":"2019/06/16/flutterapp1/","text":"有着上次对 Flutter 的认识，于是我马不停蹄的着手开发了一个基于 Flutter 的 App，一开始真的是很难，Flutter 对于我来说简直就是未知的领域。 所做的工作界面展示 主界面 主界面含有一个 Drawer 实现设置页面(SetPage)和关于界面(AboutPage)的跳转 drawer 关于作者 图片的引入pubspec.yaml这个文件中 assets 部分进行声明，再在类中调用即可。注意，调用本地图片用 ExactAssetImage 函数。 页面跳转页面路由 Navigator 的使用 遇到的问题第一天开发认识了关于 Text 的属性，对于 Row 和 Column 的 children 布局稍有掌握（毕竟这俩用的情形还是很多的） Widget参考了无数篇关于 widget 的使用，感觉这一块的知识太过于零散，层次很难分清楚，比如什么时候该用 Center、什么时候该用 Container ，没有概念，导致开发时候 View 极其混乱。 网络引入新的依赖之后，App 在运行编译的时候总是卡在 resolving depencenies ，如果卡了很长时间并且报 Error running Gradle:，那很大一部分可能是你被墙挡住了，解决办法我不多说。 图片的加载我现在也不明白图片加载嵌套那个是什么机制，只是知道使用一个 DecoratedBox 嵌套 ，其中有个属性是 BoxDecoration ， 接下来要做的 三张卡片的逻辑做出来，不要再是“1，2，3”这样的 text widget，要是图片加文字。 设置界面中加入模式调整，并学会在两个页面中间传值。 点击相应的卡片，将点击的结果传递给同页面的 Container","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://www.allenmistake.top/tags/Flutter/"},{"name":"开源项目","slug":"开源项目","permalink":"http://www.allenmistake.top/tags/开源项目/"}]},{"title":"开始一场Flutter之旅","date":"2019-06-14T03:20:39.000Z","path":"2019/06/14/startflutter/","text":"是时候搞一点新东西了其实我在去年就对 Flutter 有所了解，当时的 Flutter 已经可以和 react native 相互竞争了，但是但是 flutter 生态化没有完全建立起来，根本和 RN 比不了，虽然在 Github 有了几十万 star 但是也只是作为 Android 和 iOS 之间跨平台的一种方案。 然而在2019年5月，谷歌在其官方博客宣布，Flutter 已支持移动、Web、桌面和嵌入式设备，这意味着它正式成为了支持多平台的轻量级 UI 框架。 所以，是时候搞一点新东西了。 Flutter 优势我简单说一下 Flutter 的优势，首先就是跨平台特性；其次，其采用 Dart 语言，这个语言内部机制决定了 Flutter 有一个很优秀的功能——热重载，也就是说改动代码后不需要重新运行应用（Init…resolve…），代码的改动可以直接作用于正在运行的程序；最后一点就是渲染，他采用 GPU 渲染应用，体验上我完全不输 RN 原生应用。 Flutter 配置可以参照官方文档进行配置:https://flutter-io.cn/docs 我踩到的坑：国内用户提示加的那两个环境变量（两个网站）一定要加在系统变量中，不要加在用户变量，会由于权限问题导致没有效果，导致新建 Flutter 出现卡死情况（网站上不去、解析不了当然卡死） 构建自己的第一个 flutter App（假的）项目地址：https://github.com/AllenMistake/flutter_app 之所以是假的，是因为完全参考官方给出的示例代码，毕竟，我刚刚上手，API都不懂，怎么码代码嘛，还是要一步一步来，不要一口吃个胖子。 我在这里分析几个源码中我认为比较重点的几个点： 单行函数1void main() =&gt; runApp(new MyApp()); =&gt;在dart中表示单行函数或方法，算是提高代码简洁度的一个语法糖吧。 widget结构分析首先我们看一下最初的源码 12345678910111213141516class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: 'Welcome to Flutter', home: new Scaffold( appBar: new AppBar( title: const Text('Welcome to Flutter'), ), body: const Center( child: const Text('Hello World'), ), ), ); &#125;&#125; Scaffold 是 Material library 中提供的一个 widget，它提供了默认的导航栏、标题和包含主屏幕 widget 树的 body 属性。widget 树可以很复杂。 一个 widget 的主要工作是提供一个 build() 方法(总是要重写，类似于activity中的 onCreate)来描述如何根据其他较低级别的 widgets 来显示自己。 本示例中的 body 的 widget 树中包含了一个 Center widget，Center widget 又包含一个 Text 子 widget，Center widget 可以将其子 widget 树对其到屏幕中心。 添加依赖添加依赖在 pubspec.yaml 中，然后点击右上角出现的Packages get，当然别忘了在主程序中引入包。 添加一个 Stateful widgetStateless widgets 是不可变的，这意味着它们的属性不能改变——所有的值都是 final。 Stateful widgets 持有的状态可能在 widget 生命周期中发生变化，实现一个 stateful widget 至少需要两个类：1）一个 StatefulWidget 类；2）一个 State 类，StatefulWidget 类本身是不变的，但是 State 类在 widget 生命周期中始终存在。 万物皆是 widget123456return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), ); 这个代码中 ListTile 和 Text 都是 widget 他们各自的属性用括号括起来，记住，每个属性写完之后要加逗号，这个很容易忘。 二阶段：加入Icon和跳转页面我们看一下最终结构关系图 第二阶段结构图 来看看第二阶段学习了哪些内容吧 在 stateful widget 上添加交互12345678910111213141516171819202122Widget _buildRow(WordPair pair) &#123; final bool alreadySaved = _saved.contains(pair); return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), trailing: new Icon( alreadySaved ? Icons.favorite : Icons.favorite_border, color: alreadySaved ? Colors.red : null, ), onTap: () &#123; setState(() &#123; if (alreadySaved) &#123; _saved.remove(pair); &#125; else &#123; _saved.add(pair); &#125; &#125;); &#125;, ); &#125; 在 onTap 属性中，我们添加了点击事件的逻辑。我们在 _buildRow 中让心形 ❤️图标变得可以点击。如果单词条目已经添加到收藏夹中， 再次点击它将其从收藏夹中删除。当心形 ❤️图标被点击时，函数调用 setState() 通知框架状态已经改变。 提示: 在 Flutter 的响应式风格的框架中，调用 setState() 会为 State 对象触发 build() 方法，从而导致对 UI 的更新 导航到第二个页面；1234567891011121314151617181920212223242526272829void _pushSaved() &#123; Navigator.of(context).push( new MaterialPageRoute&lt;void&gt;( builder: (BuildContext context) &#123; final Iterable&lt;ListTile&gt; tiles = _saved.map( (WordPair pair) &#123; return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), ); &#125;, ); final List&lt;Widget&gt; divided = ListTile.divideTiles( context: context, tiles: tiles, ).toList(); return new Scaffold( appBar: new AppBar( title: const Text('Saved Suggestion'), ), body: new ListView(children: divided), ); &#125;, ), ); &#125; 添加一个显示收藏夹内容的新页面（在 Flutter 中称为路由［route］）。 在 Flutter 中，Navigator (导航器)管理应用程序的路由栈。将路由推入（push）到导航器的栈中，将会显示更新为该路由页面。 从导航器的栈中弹出（pop）路由，将显示返回到前一个路由。 我们在 RandomWordsState 的 build 方法中为 AppBar 添加一个列表图标。当用户点击列表图标时，包含收藏夹的新路由页面入栈显示。 添加 Navigator.push 调用，这会使路由入栈（以后路由入栈均指推入到导航管理器的栈） 在新的 route（路由）页面中显示收藏的内容。Navigator（导航器）会在应用栏中自动添加一个”返回”按钮，无需调用Navigator.pop，点击后退按钮就会返回到主页路由。 接下来，添加 MaterialPageRoute 及其 builder。 现在，添加生成 ListTile 行的代码，ListTile 的 divideTiles() 方法在每个 ListTile 之间添加 1 像素的分割线。 该 divided 变量持有最终的列表项，并通过 toList() 方法非常方便的转换成列表显示。 builder 返回一个 Scaffold，其中包含名为”Saved Suggestions”的新路由的应用栏。新路由的body 由包含 ListTiles 行的 ListView 组成；每行之间通过一个分隔线分隔。 最终，我们可以通过 Flutter Inspector 查看 Widget Tree 具体结构 Widget Tree","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://www.allenmistake.top/tags/Flutter/"}]},{"title":"经典定时同步算法与训练序列设计","date":"2019-06-10T01:58:27.000Z","path":"2019/06/10/classictiming/","text":"S&amp;C算法S&amp;C 算法是 Schimidl&amp;Cox 同步算法的简称，是一种基于训练序列的同步估计算法，它是由 Schimidl 和 Cox 提出的。它是最经典的一种基于训练序列的同步估计算法，后续的 Minn 算法和 Park 算法都在它基础上做改进的。 S&amp;C 算法的训练序列的结构图如图 3-2 所示。 S&C训练序列结构图 如图 3-2 所示，训练序列 1 由两个长度为 N/ 2 训练序列 A 组成，这两个 A 是完全一样的序列；训练序列 2 由长度为 N 的训练序列 B 组成。训练序列 1 通常是用来完成符号定时估计和小数倍载波偏移估计。训练序列 1 的 N 个子载波的频域特性表现为，在偶数子载波上放置一个长度为 N/ 2 的1PN 序列，在奇数子载波上全部置零，然后进行 N 点的 IFFT 变换，就能够创造出前后 N/2 个点值一样的训练序列 1。具体实现的时候，可以使用 N/2 个点的 PN 序列，进行 IFFT 之后，得到序列 A，把 A 重复放置一次就能得到训练序列 1。训练序列 2 通常是和训练序列 1一起来完成整数倍载波偏移估计的。训练序列 2 的 N 个子载波的频域特性表现为，在奇数子载波上放置一个长度为 N/ 2 的其他序列，在偶数子载波上放置一个长度为 N/ 2 的2PN 序列，然后进行 N 点的 IFFT 变换，就可以得到训练序列 2，其中，2PN 序列与1PN 序列的有一个差分关系，如下式所示， $v(k)=\\frac{P N_{2}(k)}{P N_{1}(k)} \\qquad k=1,2, \\cdots N / 2$ 从训练序列 1 的第一个采样值开始，将前后对应的数据共轭相乘相加，可以得到相关函数，如下式所示： $P(d)=\\sum_{n=0}^{N / 2-1} r^{*}(d+n) r(d+N / 2+n)$ 式中 d 表示估计到的滑动窗的起始位置，理想位置就是第一个采样点。峰值会受到 CP 的干扰，进而出现一个平台，我们一般把它称为平台效应。下式表示滑动窗内的信号能量： $R(d)=\\sum_{n=0}^{N / 2-1}|r(d+n+N / 2)|^{2}$ 归一化后的定时测度函数可定义为 $M(d)=\\frac{|P(d)|^{2}}{R^{2}(d)}$ 使得 $M(d)$ 取得最大值的 d 就是估计出的符号起始位置，一般把这个位置记为 $\\hat{d}$ ，如下式所示： $\\hat{d}=\\arg \\max (M(d))$ Minn 算法 Minn算法训练序列结构图 从图 3-4 中可以看到，Minn 算法由 4 个训练符号构成，第一个和第二个训练符号都是 A，第三个和第四个训练符号都是 -A，其中，A 和 -A 互为相反数，A 是由伪随机 PN 序列进行 IFFT 之后得到的。 Minn 算法的运算过程和 S&amp;C 算法的运算过程基本一致，只是由于训练序列结构的改变，导致了相关函数和能量函数也一起发生了变化，具体变化如下式所示： $P(d)=\\sum_{k=0}^{1} \\sum_{m=0}^{N / 4-1} r^{*}\\left(d+\\frac{N \\cdot k}{2}+m\\right) \\cdot r\\left(d+\\frac{N \\cdot k}{2}+m+\\frac{N}{4}\\right)$ $R(d)=\\sum_{k=0}^{1} \\sum_{m=0}^{N / 4-1}\\left|r\\left(d+\\frac{N \\cdot k}{2}+m+\\frac{N}{4}\\right)\\right|^{2}$ $M(d)=\\frac{|P(d)|^{2}}{R^{2}(d)}$ Park 算法 Park算法训练序列结构图 从图 3-5 中可以看出一个 Park 算法的训练序列由四个训练符号构成的。其中 A 是由长度为 N/4 的伪随机 PN 序列经过 IFFT 得到的，B 是 A 的逆向排列，A*是A 的共轭，B*是 B 的共轭。 Park 算法的相关函数，能量函数和定时测度函数定义为： $P(d)=\\sum_{k=0}^{N / 2-1} r(d+k) \\cdot r(d-k-1)$ $R(d)=\\sum_{k=0}^{N / 2-1}|r(d+k)|^{2}$ $M(d)=\\frac{|P(d)|^{2}}{R^{2}(d)}$ Park 算法的训练序列虽然前后也是对称的，但是并没有利用前后对称这一特性，而是利用了训练序列中心共轭对称这个更难得的性质。从中间两个值向两边依次进行相关运算，才能够达到唯一的相关峰值，排除 CP 的干扰。而且使得归一化后的符号定时测度函数 $M(\\hat{d})$ 达到最大的 $\\hat{d}$ 对应的并不是 FFT 窗开始的位置，而是训练序列的中点。Park 算法的相关函数的运算过程如图 3-6 所示， Park相关函数运算过程 三种算法效果以上这三种方法在AWGN信道下表现良好对于 S&amp;C 算法，S&amp;C 算法在各种信道下，在找出理想的 FFT 窗附近都存在着一个“平台”。对于 Minn 算法和 Park 算法，在 ETU 信道（一种多径干扰模型）下，随着多径衰落、时延和频偏的增加，定时测度函数峰值被削弱，且幅度变化较大，也有可能出现“双峰”的情况，造成定时同步判断的错误。","tags":[{"name":"定时同步","slug":"定时同步","permalink":"http://www.allenmistake.top/tags/定时同步/"}]},{"title":"读书笔记-高效15法则","date":"2019-06-08T11:11:31.000Z","path":"2019/06/08/bookGaoXiao/","text":"高效15法则 放下To do List吧用日程表代替任务清单 安排一大块时间 重要的事情安排在早的时候 设计出理想的一周 每天 90 分钟 —— 2 小时缓冲时间 战胜拖延症 未来的我是最大的敌人 想一想为什么要做，做这件事情带来的乐趣 or 痛苦 可靠的伙伴 奖励和惩罚 行动，向理想中的自己进发 足够好的目标（也许不完美） 随手记 准备一个小本本，不要错过任何一个想法 用手机笔记，而不是笔记本电脑 拒绝 每天只有 1440 分钟，利用好 每个 Yes 意味着对另一件事情说 No 帕雷托（八二法则） 80% 的结果是由 20% 的行动产生 思维模式 -&gt; 分辨出带给你超额回报的少数事情 判断你哪 20% 的时间会生成 80% 的价值 教你省时 放弃 —— 什么事情可以不做 分派 —— 那些可以分派出去 重新设计 —— 那些需要我换种节省时间的方式继续做 主题日主题日的设置可以提高效率，主题日中的主题占据很大部分时间 专注日 （周二——周四） 缓冲日 （周一、周日） 自由日 （周五、周六） 恢复精力 科学方法凡是只做一次，如果一件事只需做 5 分钟，立刻去做 改变清晨，改变人生 6 点甚至更早起床（个人觉得 7 点差不多） 饮用大量水可补充水分 健康早餐 + 运动 少吃碳水化合物（糖类和淀粉，现实当中土豆、零食） 精力就是一切 番茄工作法 25 分钟的工作，5 分钟的休息 保持精力 足够的睡眠 多吃天然食物（少吃零食、路边摊小吃） 多喝水，每天保持运动 E-3C 精力 Energy 精力就是效率，效率才是关键，而不是时间 捕捉 Capture 捕捉生活中的灵感与想法 日历 Calendar 日程表 专注 Concentrate 保持专注，25 分钟的专注时光","tags":[{"name":"效率","slug":"效率","permalink":"http://www.allenmistake.top/tags/效率/"}]},{"title":"归来仍是少年","date":"2019-06-02T14:30:24.000Z","path":"2019/06/02/monthlysummary6/","text":"5月份工作5月是一个过渡月份，由4月的忙碌重心逐渐向学习方面转移。可惜自己抵抗力实在太差，劳动节放假出去大吃大喝了一通之后，就喜得支气管炎，持续了大概两周，导致之前展望的工作也没有完成的太理想。 不过还好，基本把Java的并发和GC机制看完了。 6月份计划接下来可以把重心放到算法上面来，其次可以关注一下设计模式 算法方面： Leetcode 刷 10 道题，仍然以DP、回溯为主，最好设计一些哈希表操作，前面的经典题目可以再回顾一下。 《左程云》这本书还是值得看一下的，只不过有些问题点到为止，建议有些经典题目去 Leetcode 上面找大神，看看他们的解法 设计模式： 《大话设计模式》这本书我感觉写的不是很好，不知道为什么有那么多人推荐，不过结合着大PDF看肯定还是有收获的，还要结合源码看，这方面我觉得可以先对各种设计模式有一个整体的认知，然后再去读源码，这样理解逐步加深，有个过程。 其他感悟六一儿童节刚刚过去，其实跟自己也没啥关系了，只是看着朋友圈发现每个人的人生轨迹真的是不一样，高中的同学很多都去留学了，他们的视野比我更开阔，发展的前景也更好，而我却只能和一些2本 3本挤破头去争互联网公司的 996 。其实想想自己家乡也有几个很一般的研究所，但是进去直接就是养老，感觉毫无意义，难道我25岁就要走进办公室政治，混工龄？ 我不想这样。","tags":[]},{"title":"JVM学习之HotSpot虚拟机中的垃圾收集器","date":"2019-05-27T14:53:31.000Z","path":"2019/05/27/JVM4/","text":"垃圾收集器如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。下面是Hotspot 虚拟机包含的所有收集器： HotSpot 虚拟机的垃圾收集器 Serial!(Seral.jpg) 特点：是最基本、发展历史最悠久的收集器。这是一个单线程收集器。但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。 应用年代：新生代 采用算法：复制算法 应用：是虚拟机运行在Client模式下的默认新生代收集器。 优势：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程效率。 缺点：Stop the world！ ParNew!(ParNew.jpg) 特点：ParNew收集器其实就是Serial收集器的多线程版本 应用年代：新生代 采用算法：复制算法 应用：CPU较多 优势：除了Serial收集器外，目前只有它能与CMS收集器配合工作。 缺点：在单CPU环境，表现甚至不如Serial Parallel Scavenge!(Para.jpg) 特点：Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。（吞吐量 = 运行用户代码时间 + 垃圾收集时间）。他的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间。还可以根据当前系统的运行情况收集性能监测信息，动态调整这些参数以提供最合适的停顿时间或者最大吞吐量。 应用年代：新生代 采用算法：复制算法 优势：同特点 Serial Old 特点：Serial 的老年版本 应用年代：老年代 采用算法：标记-整理 应用：与Parallel Scavenge收集器搭配使用；作为CMS收集器的后备预案，在并发收集发生Conurrent Mode Failure 使用。 优势： Parallel Old 特点：Parallel Old是Parallel Scavenge收集器的老年代版本 应用年代：老年代 采用算法：标记-整理 应用：注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel CMS（重点） 特点：是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。他的关注点在于尽可能地缩短垃圾收集时用户线程的停顿时间。 应用年代：老年代 采用算法：标记-清除 应用场景：大部分集中在互联网站或者B/S系统的服务端上的 Java 应用 优势：停顿时间短 它的运作过程相对来说较为复杂，分为 4 个步骤初始标记、并发标记、重新标记、并发清除 !(cms.jpg) 其中，初始标记，重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只标记一下GC Roots能直接关联到的对象，速度很快。并发标记阶段就是进行GC Roots Tracing的过程。重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记几率，这个阶段的停顿时间一般会比初始标记阶段稍长，但远比并发标记时间短。整个过程耗时最长的阶段是并发标记，并发清除过程，但这两个过程可以和用户线程一起工作。 缺点： CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。 CMS收集器无法处理浮动垃圾，可能出现“Conurrent Mode Failure”失败而导致另一次 Full GC的产生。由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会产生新的垃圾，这一部分垃圾出现在标记过程之后，CMS无法在档次收集中处理掉它们，只好留待下一次GC时再清理掉。这部分垃圾就称为“浮动垃圾”。因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时程序运作使用。在JDK1.5的默认设置下，CMS 收集器当老年代使用了 68% 的空间后就会被激活。如果预留空间无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案Serial Old。 CMS是一款基于“标记-清除”算法实现的收集器，所以会有大量空间碎片问题。 G1G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。 堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。 Hotspot堆结构 G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。 G1堆分配 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 具备如下特点： 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.allenmistake.top/tags/JVM/"}]},{"title":"Leetcode日记：95&96：不同的二叉搜索树","date":"2019-05-21T13:20:14.000Z","path":"2019/05/21/leetcode96/","text":"96-题目给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 12345678910输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 96-分析这个问题可以用动态规划的方式解决。我将在下面解释直觉和公式。 给定序列1…n，为了从序列中构造二叉搜索树(BST)，我们可以列举序列中的每个数字 i ，并将该数字用作根，自然，其左侧的子序列1…(i-1)将位于根的左分支，类似地，右子序列(i+1)…n位于根的右分支。然后我们可以递归地从子序列构造子树。通过以上方法，我们可以确保我们构建的BST都是独特的，因为它们有独特的根。 问题是要计算唯一的二叉树数量。为此，我们需要定义两个功能: $G(n)$:长度为n的序列的唯一BST数。 $F(i，n)，1 &lt;= i &lt;= n$:唯一BST的数目，其中 i 是BST的根，序列范围从1到n。 可以看出，G(n)是我们需要计算来解决这个问题的实际函数。G(n)可以从F(i，n)中导出，最后递归地引用G(n)。首先，给定上面的定义，我们可以看到唯一的BST G(n)的总数，是使用每个数字I作为根的BST F(i)的总和。即$$G(n) = F(1, n) + F(2, n) + … + F(n, n) (1)$$特别是在下面的情况下，从长度为1(只有根)或0(空树)的序列中，只有一个组合可以构造一个BST。即$$G(0)=1，G(1)=1$$给定序列1…n，我们从序列中选择一个数字 i 作为根，那么具有指定根F(i)的唯一BST的数量是其左右子树的BST数量的笛卡尔乘积。例如，F(3，7):以数字3为根的唯一BST树的数目。要从以3为根的整个序列[1，2，3，4，5，6，7]中构建一个唯一的边界点，也就是说，我们需要从它的左子序列[1，2]中构建一个唯一的边界点，从右子序列[4，5，6，7]中构建另一个边界点，然后将它们组合在一起(即笛卡尔乘积)。棘手的是，我们可以将[1，2]序列之后的唯一BST的数量当作G(2)，将[4，5，6，7]序列外的唯一BST的数量视为G(4)。因此，F(3，7) = G(2) G(4)。即$$F(i，n)= G(i-1) G(n-i) 1 &lt;= i &lt;= n (2)$$结合以上两个公式，我们得到了G(n)的递推公式。即$$G(n)= G(0) G(n-1)+G(1) G(n-2)+…+G(n-1)* G(0)$$就计算而言，我们需要从较低的数字开始，因为G(n)的值取决于G(0) … G(n-1)的值。 保存中间结果，在这道题中，中间结果所代表变量是 $G(n)$ 。 96-代码1234567891011public int numTrees(int n) &#123; int [] G = new int[n+1]; G[0] = G[1] = 1; for(int i=2; i&lt;=n; ++i) &#123; for(int j=1; j&lt;=i; ++j) &#123; G[i] += G[j-1] * G[i-j]; &#125; &#125; return G[n];&#125; 95-题目给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。 示例: 1234567891011121314151617输入: 3输出:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释:以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 95-代码12345678910111213141516171819202122232425262728public List&lt;TreeNode&gt; generateTrees(int n) &#123; return genTrees(1,n);&#125;public List&lt;TreeNode&gt; genTrees (int start, int end)&#123; List&lt;TreeNode&gt; list = new ArrayList&lt;TreeNode&gt;(); if(start &gt; end)&#123; list.add(null); return list; &#125; if(start == end)&#123; list.add(new TreeNode(start)); return list; &#125; List&lt;TreeNode&gt; left,right; for(int i = start; i &lt;= end;i++)&#123; left = genTrees(start, i-1); right = genTrees(i+1, end); for(TreeNode lnode: left)&#123; for(TreeNode rnode: right)&#123; TreeNode root = new TreeNode(i); root.left = lnode; root.right = rnode; list.add(root); &#125; &#125; &#125; return list;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.allenmistake.top/tags/动态规划/"},{"name":"树","slug":"树","permalink":"http://www.allenmistake.top/tags/树/"}]},{"title":"Leetcode日记：买卖股票的最佳时期系列","date":"2019-05-19T12:27:20.000Z","path":"2019/05/19/leetcodeStock/","text":"牛刀小试——买卖一次买卖股票是 Leetcode 上一系列问题，基本都是用动态规划和贪心算法思想计算出来的。我们看第一个入门级的： 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 分析我们完全可以用暴力法解决问题，但是有没有一种更好的方法呢？答案是肯定的，我们完全可以一次遍历，只需要两个变量，一个变量存储目前遇到的最小值，一个变量储存目前遇到的最大利润。 代码12345678910111213class Solution &#123; public int maxProfit(int[] prices) &#123; int min = Integer.MAX_VALUE; int max = 0; for(int i = 0; i &lt; prices.length; ++i)&#123; if(prices[i] &lt; min) min = prices[i]; else if(prices[i] - min &gt; max) max = prices[i] - min; &#125; return max; &#125;&#125; 山雨欲来——多次买卖这次再上一个问题的基础上，改动为了可以多次买卖。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 分析我们可以把利润 profit 设为一个累积量，只要下一次的比上一次的大，就把差值累计给 profit ，如果下一次的比上一次的小，更新 min（可以理解为：当n &lt; n-1时，在 n-1 时刻将股票抛售， 在 n 时刻买）、 代码12345678910111213141516class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices.length == 0) return 0; int min = prices[0]; int profit = 0; for(int i = 1; i &lt;prices.length; ++i)&#123; if(prices[i] &lt; prices[i-1]) min = prices[i]; else profit = profit + prices[i] - prices[i-1]; &#125; return profit; &#125;&#125; 风起云涌——只能买两次示例 1: 1234输入: [3,3,5,0,0,3,1,4]输出: 6解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 分析这道题有一个常人很容易陷入的误区，一开始我觉得这道题挺简单的，后来发现自己想的有问题,我一开始的做法是，维护两个最大值，max1,max2，像上面那道题一样，只要下一次的比上一次的大，就把差值累计给 profit ，并和max1、max2对比，如果比其中任何一个大，替换掉那一个，如果下一次的比上一次的小，更新 min，重新计算 profit，但是这样有个问题，加入数组是这样的： 1[1,2,4,2,5,7,2,4,9,0] 我的方法是,1-&gt;4 1max1 = 3, max2 = 0; 2-&gt;7更新 1max1 = 5,max2 = 3; 2-&gt;9 1max1 = 7,max1 = 5; 所以我的最终答案是12，然而，最优方法是1-&gt;7,2-&gt;9此时，最大利润是13. 那么，我们究竟如何取舍呢？ 方法一——四变量其实在第二道题的基础上稍微修改一下思路就好，但不是很容易想到，首先我们要建立一个变量来存储第二次买股票时所花费的费用，这个变量存在的目的意义是为了计算第二次卖出股票时的利润$$buyTwoProfit = prices[i] - buyTwoCost$$而这个buyTwoCost至关重要，我们如何确定他的更新呢？其实仔细想想就知道； 首先，第二次买入一定是股票下降的时候 第二次买入一定是赚，确保赚的比之前的第二次买入多才会更新 $$buyTwoCost = prices[i] - buyOneProfit$$ 对应代码： 1buyTwoCost = Math.min(buyTwoCost, prices[i] - buyOneProfit); 四变量过程 方法二——分界线我们可以换个角度想 最多允许两次不相交的交易，也就意味着这两次交易间存在某一分界线，考虑到可只交易一次，也可交易零次，故分界线的变化范围为第一天至最后一天，只需考虑分界线两边各自的最大利润，最后选出利润和最大的即可。这种方法抽象之后则为首先将[1,n] 拆分为[1,i] 和[i+1,n], 参考卖股票系列的第一题计算各自区间内的最大利润即可。[1,i] 区间的最大利润很好算，但是如何计算[i+1,n] 区间的最大利润值呢？难道需要重复n 次才能得到？注意到区间的右侧n 是个不变值，我们从[1, i] 计算最大利润是更新波谷的值，那么我们可否逆序计算最大利润呢？这时候就需要更新记录波峰的值了 方法一代码123456789101112131415161718public int maxProfit(int[] prices) &#123; if (prices == null || prices.length == 0) &#123; return 0; &#125; int buyOneCost = prices[0]; int buyOneProfit = 0; int buyTwoCost = Integer.MAX_VALUE; int buyTwoProfit = 0; for (int i = 1; i &lt; prices.length; i ++) &#123; buyOneProfit = Math.max(buyOneProfit, prices[i] - buyOneCost); buyOneCost = Math.min(buyOneCost, prices[i]); buyTwoProfit = Math.max(buyTwoProfit, prices[i] - buyTwoCost); buyTwoCost = Math.min(buyTwoCost, prices[i] - buyOneProfit); &#125; return Math.max(buyOneProfit, buyTwoProfit); &#125; 方法二代码123456789101112131415161718192021222324public int maxProfit(int[] prices) &#123; if (prices == null || prices.length &lt;= 1) return 0; // get profit in the front of prices int[] profitFront = new int[prices.length]; profitFront[0] = 0; for (int i = 1, valley = prices[0]; i &lt; prices.length; i++) &#123; profitFront[i] = Math.max(profitFront[i - 1], prices[i] - valley); valley = Math.min(valley, prices[i]); &#125; // get profit in the back of prices, (i, n) int[] profitBack = new int[prices.length]; profitBack[prices.length - 1] = 0; for (int i = prices.length - 2, peak = prices[prices.length - 1]; i &gt;= 0; i--) &#123; profitBack[i] = Math.max(profitBack[i + 1], peak - p rices[i]); peak = Math.max(peak, prices[i]); &#125; // add the profit front and back int profit = 0; for (int i = 0; i &lt; prices.length; i++) &#123; profit = Math.max(profit, profitFront[i] + profitBack[i]); &#125; return profit;&#125; 惊涛骇浪——k次交易示例 1: 123输入: [2,4,1], k = 2输出: 2解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2: 1234输入: [3,2,6,5,0,3], k = 2输出: 7解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 分析我们仍然使用动态规划来完成。我们维护两种量，一个是当前到达第i天可以最多进行 j 次交易，最好的利润是多少（global[i][j] ），另一个是当前到达第i天，最多可进行j次交易，并且最后一次交易在当天卖出的最好的利润是多少（local[i][j] ）。下面我们来看递推式，全局的比较简单，global[i][j]=max(local[i][j],global[i-1][j]) ，也就是去当前局部最好的，和过往全局最好的中大的那个（因为最后一次交易如果包含当前天一定在局部最好的里面，否则一定在过往全局最优的里面）。全局（到达第i天进行j次交易的最大收益）= max{局部（在第i天交易后，恰好满足j次交易），全局（到达第i-1天时已经满足j次交易）}对于局部变量的维护，递推式是$$local[i][j] = max(global[i-1][j-1] + \\text{max}(diff,0),local[i-1][j] + diff)$$ 也就是看两个量 第一个是全局到 i-1 天进行 j-1 次交易，然后加上今天的交易，如果今天是赚钱的话（也就是前面只要 j-1 次交易，最后一次交易取当前天） 第二个量则是取 local 第 i-1 天j次交易，然后加上今天的差值（这里因为local[i-1][j] 比如包含第i-1天卖出的交易，所以现在变成第i天卖出，并不会增加交易次数，而且这里无论diff是不是大于0都一定要加上，因为否则就不满足local[i][j]必须在最后一天卖出的条件了）。 局部（在第i天交易后，总共交易了j次）= max{情况2，情况1}情况1：在第i-1天时，恰好已经交易了j次（local[i-1][j] ），那么如果i-1天到i天再交易一次：即在第i-1天买入，第i天卖出（diff），则这不并不会增加交易次数！【例如我在第一天买入，第二天卖出；然后第二天又买入，第三天再卖出的行为和第一天买入，第三天卖出的效果是一样的，其实只进行了一次交易！因为有连续性】情况2：第i-1天后，共交易了 j-1 次（global[i-1][j-1] ），因此为了满足“第 i天过后共进行了 j次交易，且第i天必须进行交易”的条件：我们可以选择: 在第i-1天买入，然后再第i天卖出（diff） 在第i天买入，然后同样在第i天卖出（收益为0）。 上面的算法中对于天数需要一次扫描，而每次要对交易次数进行递推式求解，所以时间复杂度是$O(n*k)$，如果是最多进行两次交易，那么复杂度还是$O(n)$。空间上只需要维护当天数据皆可以，所以是$O(k)$，当 k=2，则是$O(1)$。补充：这道题还有一个陷阱，就是当k大于 n（天数）/2 时，其实就退化成第二个问题了 代码12345678910111213141516171819202122232425262728293031public int maxProfit(int k, int[] prices) &#123; if (prices == null || prices.length &lt; 2) &#123; return 0; &#125; int days = prices.length; if (days/2 &lt;= k) &#123; return maxProfit2(prices); &#125; // local[i][j] 表示前i天，至多进行j次交易，第i天必须sell的最大获益 int[][] local = new int[days][k + 1]; // global[i][j] 表示前i天，至多进行j次交易，第i天可以不sell的最大获益 int[][] global = new int[days][k + 1]; for (int i = 1; i &lt; days; i++) &#123; int diff = prices[i] - prices[i - 1]; for (int j = 1; j &lt;= k; j++) &#123; local[i][j] = Math.max(global[i - 1][j-1] + Math.max(diff, 0),local[i - 1][j] + diff); global[i][j] = Math.max(global[i - 1][j], local[i][j]); &#125; &#125; return global[days - 1][k];&#125;public int maxProfit2(int[] prices) &#123; int maxProfit = 0; for (int i = 1; i &lt; prices.length; i++) &#123; if (prices[i] &gt; prices[i-1]) &#123; maxProfit += prices[i] - prices[i-1]; &#125; &#125; return maxProfit;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.allenmistake.top/tags/动态规划/"}]},{"title":"Java日常学习总结JVM之类加载与双亲委派模型","date":"2019-05-19T04:10:16.000Z","path":"2019/05/19/JVM3/","text":"类加载机制定义把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。 类的生命周期加载，验证，准备，解析，初始化，使用和卸载。其中验证，准备，解析3个部分统称为连接。这7个阶段发生顺序如下图： 类加载步骤 其中加载，验证，准备，解析及初始化是属于类加载机制中的步骤。注意此处的加载不等同于类加载。 触发类加载的条件 遇到new,getstatic,putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发初始化。生成这4条指令的最常见的Java代码场景是： 使用new关键字实例化对象的时候 读取或设置一个类的静态字段的时候（被final修饰，已在编译期把结果放入常量池的静态字段除外） 调用一个类的静态方法的时候 使用java.lang.reflect包的方法对类进行反射调用的时候。 当初始化一个类的时候，发现其父类还没有进行过初始化，则需要先出发父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle 实例最后的解析结果REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出发初始化。 类加载的具体过程加载: 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转换为方法区内的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 验证：是连接阶段的第一步，目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。注意，这个校验比静态编译器将源码转换成字节码时的校验更为严格！包含四个阶段的校验动作 文件格式验证验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。 元数据验证对类的元数据信息进行语义校验，是否不存在不符合Java语言规范的元数据信息 字节码验证最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。 符号引用验证最后一个阶段的校验发生在虚拟机将符号引用转换为直接引用的时候，这个转换动作将在连接的第三个阶段——解析阶段中发生。符号验证的目的是确保解析动作能正常进行。 准备：准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。这些变量所使用的内存都将在方法区中分配。只包括类变量。初始值“通常情况”下是数据类型的零值。“特殊情况”下，如果类字段的字段属性表中存在ConstantValue 属性，那么在准备阶段变量的值就会被初始化为 ConstantValue 属性所指定的值。 初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。 1public static int value = 123; 如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。 1public static final int value = 123; 解析：虚拟机将常量池内的符号引用替换为直接引用的过程。“动态解析”的含义就是必须等到程序实际运行到这条指令的时候，解析动作才能进行。相对的，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析。 初始化：类加载过程中的最后一步。初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程。&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。&lt;clinit&gt;()与类的构造函数不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的&lt;clinit&gt;()方法执行之前，父类的&lt;clinit&gt;()方法已经执行完毕。简单地说，初始化就是对类变量进行赋值及执行静态代码块。 类加载器前面提到的加载部分的功能是将类的class文件读入内存，并为之创建一个java.lang.Class对象。这部分功能就是由类加载器来实现的。 类加载分类类加载器类似于原始部落结构，存在权力等级制度。类加载器具有等级制度，但并非是继承关系（毕竟老大是用c++写的。。）以组合的方式来复用父加载器的功能，这也符合组合优先原则。 启动类加载器（Bootstrap ClassLoader）：由C++语言实现（针对HotSpot）,负责将存放在\\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中，即负责加载Java的（Object、System、String等）。 平台类加载器（Platform ClassLoader）：用以加载一些扩展的系统类。如 XML、加密、压缩相关功能类： 应用程序类加载器（Application ClassLoader）：负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器，通过ClassLoader.getSystemClassLoader()方法直接获取。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。以上3种类加载器基本上负责了所有Java类的加载。下面我们来具体了解上述几个类加载器实现类加载过程时相互配合协作的流程。 双亲委派模型双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 双亲委派模型 低层次的当前类加载器，不能覆盖更高层次类加载器已经加载的类。如果低层次的类加载器想加载一个位置，要非常礼貌的向上逐级询问：“请问，这个类已经加载了吗？”被询问的高层次类加载器会自问两个问题：第一，我是否已经加载过此类？第二，如果没有，是否可以加载此类？只有当所有高层次类加载器在两个问题上的回答均为“否”时，才能让当前类加载器加载这个未知类。如图所示，左侧绿色箭头向上主机询问是否能加载此类，如果都加载不了，则通知发起加载请求的当前类加载器，准予加载。在右侧三个小标签里，列举了此层类加载器主要加载的代表性类库，事实上不止于此。 这样的好处是不同层次的类加载器具有不同优先级，比如所有Java对象的超级父类java.lang.Object，位于rt.jar，无论哪个类加载器加载该类，最终都是由启动类加载器进行加载，保证安全。即使用户自己编写一个java.lang.Object类并放入程序中，虽能正常编译，但不会被加载运行，保证不会出现混乱。 双亲委派模型的代码实现ClassLoader中loadClass方法实现了双亲委派模型 12345678910111213141516171819202122232425262728293031323334353637protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; synchronized (getClassLoadingLock(name)) &#123; //检查该类是否已经加载过 Class c = findLoadedClass(name); if (c == null) &#123; //如果该类没有加载，则进入该分支 long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; //当父类的加载器不为空，则通过父类的loadClass来加载该类 c = parent.loadClass(name, false); &#125; else &#123; //当父类的加载器为空，则调用启动类加载器来加载该类 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; //非空父类的类加载器无法找到相应的类，则抛出异常 &#125; if (c == null) &#123; //当父类加载器无法加载时，则调用findClass方法来加载该类 long t1 = System.nanoTime(); c = findClass(name); //用户可通过覆写该方法，来自定义类加载器 //用于统计类加载器相关的信息 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; //对类进行link操作 resolveClass(c); &#125; return c; &#125;&#125; 整个流程大致如下： 首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。 如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加载器来加载。 如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的findClass方法来完成类加载。关于自定义类加载器，本篇文章就不介绍了，主要是重写findClass方法。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.allenmistake.top/tags/JVM/"}]},{"title":"Java日常学习总结JVM之内存模型","date":"2019-05-18T02:30:34.000Z","path":"2019/05/18/JVM2/","text":"对象创建、内存布局和访问定位对象的创建 虚拟机遇到一个new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用； 检查这个符号引用代表的类是否已经被加载，解析和初始化过。如果没有，那必须先执行响应的类加载过程； 在类加载检查功通过后，为新生对象分配内存。对象所需的内存大小在类加载完成后便可完全确定。 从源文件到字节码过程 源码转化成字节码的过程 分析词法解析是通过空格分割出单词、操作符、控制符符等信息，将其形成 token 信息流， 传递给语法解析器；在语法解析时，把词法解析得到的 token 信息流按照 Java 语法规则组装成一颗语法树，如图虚线框所示；在语义分析阶段，需要检查关键字的使用是否合理、类型是否匹配、作用域是否正确等；当语义分析完成之后，即可生成字节码。 字节码必须通过类加载过程加载到 JVM 环境，才可以执行。执行有三种模式：第一，解释执行；第二，JIT编译执行；第三，JIT 编译与解释混合执行（主流JVM默认执行模式）。混合执行模式的优势在于解释器在启动时先解释执行，省去编译时间。随着时间推进，JVM 通过热点代码统计分析，识别高频的方法调用、循环体、公共模块等，基于强大的 JIT 动态编译技术，将热点代码转换成机器码，直接交给 CPU 执行。JIT 的作用是将 Java 字节码动态的编译成可以直接发送给处理器指令执行的机器码。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.allenmistake.top/tags/JVM/"}]},{"title":"Leetcode日记：120：三角形最小路径和","date":"2019-05-14T15:36:23.000Z","path":"2019/05/14/leetcode120/","text":"题目给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： 1234 [2], [3,4], [6,5,7],[4,1,8,3] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明： 如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 分析三角形具有树状结构，我们首先想到的是遍历算法，例如DFS。然而，如果你仔细观察，你会发现相邻的节点总是共享一个“分支”。换句话说，有重叠的子问题。此外，假设x和y是k的“子”，一旦从x和y到底部的最小路径已知，从k开始的最小路径可以在O(1)中确定，这是最佳子结构。下一次的结果会利用到上一次的结果。因此，就时间复杂性而言，动态规划将是这个问题的最佳解决方案。 自上而下 vs 自下而上对于“自上而下”的动态规划，从最顶端的节点开始，我们递归地找到每个节点的最小路径和。计算路径和时，我们将其存储在数组中(记忆)；下次我们需要计算同一节点的路径和时，只需从数组中检索它。但是，您需要一个至少与输入三角形本身大小相同的缓存来存储 pathsum (占用 $O(N^2)$ 空间)。或许我们可以做一些剪枝优化，有可能释放一些在特定点之后永远不会使用的内存，但是在递归解决方案中不能直接看到正在处理的节点的顺序，因此决定丢弃缓存的哪一部分可能是一项困难的工作。 另一方面，自下而上的动态规划非常简单————我们从底层的节点开始；这些节点的最小路径和是节点本身的值。从那里开始，第 k 行第 i 节点处的最小路径总和将是其两个子节点的路径总和加上自身值中的较小者，即: 1A[k][i] = Math.min( A[k+1][i], A[k+1][i+1]) + triangle[k][i]; 或者更好的是，因为在计算 minpath[k] 之后，行 minpath[k+1] 将是无用的，所以我们可以简单地将 minpath 设置为一维数组，并随着迭代不断更新自身: 1A[j] = Math.min(A[j], A[j+1]) + triangle.get(i).get(j); 动态规划小结最近也做了不少关于动态规划的题目，之后还会不断进行补充，我觉得现在是一个不错的时机来对动态规划问题思路做一个总结： 拿到一道算法题，如何快速确定他可以用动态规划做呢？ 首先，这道题需要求最优解，也就是说答案一般是唯一的，但是这个唯一是相对的，比如之前的机器人路径，明明最后有那么多条路径可以到终点，为什么也用动态规划呢？关于这个问题，我们要发散思维，虽然路径不是唯一的，但是可达路径数是唯一的。我们最终求的结果（返回值）也是路径数。所以我们采用动态规划，当然，还有下面一个重要原因。 在计算过程中，$n+1$ 步的计算可以用到第 $n$ 步的结果 ，我们可以建立一个存储结构来存放中间产生的结果，来给第 n+1 步提供便利，而不需要从第一步重新计算，这也是动态规划不同于回溯的地方。 代码123456789public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int[] A = new int[triangle.size()+1]; for(int i = triangle.size()-1; i &gt;= 0; i--)&#123; for(int j = 0;j &lt; triangle.get(i).size(); j++)&#123; A[j] = Math.min(A[j], A[j+1]) + triangle.get(i).get(j); &#125; &#125; return A[0];&#125; 更多动态规划问题更多动态规划问题关注标签：动态规划","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.allenmistake.top/tags/动态规划/"}]},{"title":"从 JDK7 与 JDK8 对比详细分析 HashMap 的原理与优化","date":"2019-05-13T13:05:26.000Z","path":"2019/05/13/hashmap/","text":"概述从本文你可以学习到： 什么时候会使用 HashMap ？他有什么特点？ 你知道 HashMap 的工作原理吗？ 你知道 get 和 put 的原理吗？equals() 和 hashCode() 的都有什么作用？ 你知道 hash 的实现吗？为什么要这样实现？ 如果 HashMap 的大小超过了负载因子 (load factor) 定义的容量，怎么办？ 为什么 HashMap 的容量是 2 的 n 次幂的形式？ 在说明这些问题的同时， 我从 JDK7 —— JDK8 的 HashMap 的变化来说明开发人员对这个数据结构的优化，重点放在了 put() 函数 和 resize() 函数，还结合了《码出高效》这本书指出了 HashMap 在并发情况下表现出来的问题。 注意：源码可能与 JDK 中实际代码略有不同， 这里面 JDK7 版以《码出高效》为准，JDK8 版本以网络版本为准，意在说明某个函数功能， 便于理解。 两个重要参数说起在HashMap中有两个很重要的参数，容量(Capacity)和负载因子 (Load factor) 。 Capacity 就是 bucket 的大小，Load factor就是 bucket 填满程度的最大比例。如果对迭代性能要求很高的话，不要把 capacity 设置过大，也不要把 load factor 设置过小。当 bucket 中的 entries 的数目大于 capacity *load factor 时，就需要调整 bucket 的大小为当前的2倍。 put函数的实现put函数大致的思路为： 对key的 hashCode() 做 hash ，然后再计算 index ; 如果没碰撞直接放到 bucket 里； 如果碰撞了，以链表的形式存在 buckets 后； 如果碰撞导致链表过长 (大于等于 TREEIFY_THRESHOLD )，就把链表转换成红黑树； 如果节点已经存在就替换 old value (保证 key 的唯一性)； 如果 bucket 满了 (超过 load factor * current capacity)，就要 resize。 具体代码的实现如下： JDK7 的 put123456789101112131415161718192021222324252627282930313233343536373839public V put(K key, V value) &#123; int hash = hash(key); int i = indexFor(hash, table.length); //此循环通过 hashCode 返回值找到对应的数组下标位置 //如果 equals 结果为真，则覆盖原值， 如果都为 false ，则添加元素 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; //如果key的 hash 是相同的，那么在进行如下判断 //key 是同一个对象或者 equals 返回为真， 则覆盖原来的Value值 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null;&#125;void addEntry(int hash, K key, V value, int bucketIndex) &#123; //如果元素的个数达到 threshold 的扩容阈值且数组下标位置已经存在元素，则进行扩容 if ((size++ &gt;= threshold) &amp;&amp; (null != table[bucketIndex]))&#123; //扩容 2 倍， size 是实际存放元素的个数，而 length 是数组的容量大小(capacity) resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex);&#125;//插入元素时，应该插入在头部，而不是尾部void createEntry(int hash. K key, V value, int bucketIndex)&#123; //不管原来的数组对应的下标是否为 null ，都作为 Entry 的 BucketIndex 的 next值 Entry&lt;K,V&gt; e = table[bucketIndex]; （***） table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); size++;&#125; 关于并发的问题：如上源码， 在 createEntry() 方法中，新添加的元素直接放在 slot 槽（ slot 哈希槽，table[i] 这个位置）使新添加的元素在下一次提取后可以更快的被访问到。 如果两个线程同时执行 (***) 处时， 那么一个线程的赋值就会被另一个覆盖掉， 这是对象丢失的原因之一。 我们构造一个 HashMap 集合，把所有元素放置在同一个哈希桶内， 达到扩容条件后，观察一下 resize() 方法是如何进行数据迁移的。示例代码和图可参考《码出高效》P204。 JDK8 的 put12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public V put(K key, V value) &#123; // 对 key 的 hashCode() 做 hash return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // tab 为空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 计算 index，并对 null 做处理，这里观察到 index 的计算 i = (n - 1) &amp; hash if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; // 这个位置有节点，且与新节点相同，进行覆盖 if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 这个位置有节点，且节点类型为 TreeNode else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 该链为链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; //桶内还是一个链表，则插入链尾（尾插） if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // 检测是否该从链表变成树 treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 写入 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 超过 load factor*current capacity，resize if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 可以看出，JDK 7 是先对 size++ 进行检查， 如果超过阈值， 则扩容，最后把节点放入 table。而 JDK 8 相反，先把节点放入， 放入后的 size 若超出， 则扩容。 hash 与 hashCode()在 get 和 put 的过程中，计算下标时，先对 hashCode 进行 hash 操作，然后再通过 hash 值进一步计算下标，如下图所示： hash计算下标 关于 hash 函数 与 hashCode 的关系，这里，为了避免碰撞，JDK7 进行了四次扰动，JDK8 简化了这个操作，只是高低位做了异或，但核心思想都是增强 hash 中各位的相关性，减少碰撞。 JDK7 中的 hash123456789101112final int hash(Object k) &#123; int h = hashSeed; //如果 key 是字符串类型，就使用 stringHash32 来生成 hash 值 if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; //一次散列 h ^= k.hashCode(); //二次散列 h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; JDK8 中的 hash1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 扩容（超级重要！）JDK7 的扩容分析1234567891011121314151617181920212223242526272829303132333435void resize(int newCapacity) &#123; //创建一个扩容后的新数组 Entry[] newTable = new Entry[newCapacity]; //将当前数组中的键值对存入新数组 //JDK8 移除 hashSeed 计算， 因为计算时会用到 Random.nextInt(), 存在性能问题 transfer(newTable, initHashSeedAsNeeded(newCapacity)); //用新数组替换旧数组 table = newTable; //注意，MAX 时 1&lt;&lt;30， 如果 1&lt;&lt;31 则成 Integer 的最小值：-2147483648 threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);&#125;void transfer(Entry[] newTable, boolean rehash) &#123; //外部传入参数时，指定新表大小为：2*oldTable.length int newCapacity = newTable.length; //遍历现有数组中的每一个单链表的头 entry for (Entry&lt;K,V&gt; e : table) &#123; //如果此 slot 上存在元素，则进行遍历， 直到 e==null，退出循环 while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; //当前元素总是直接放在数组下标的 slot 上，而不是放在链表最后 if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; //根据新的数组长度，重新计算此 entry 所在下标i int i = indexFor(e.hash, newCapacity); //把原来 slot 上的元素作为元素的下一个 e.next = newTable[i]; //新迁移过来的节点直接放置在 slot 位置上 newTable[i] = e; //继续向下遍历 e = next; &#125; &#125; &#125; 关于并发的问题：如果 resize 完成， 执行了 table = newTable ，则后续的元素就可以在新表上进行插入操作。如果多个线程同时执行了 resize ，每个线程又都会 new Entry[newCapcity] 这是线程内的局部数组对象，线程之间是不可见的。迁移完成后，resize 的线程会赋值给 table 线程共享变量，从而覆盖其他线程的操作，因此在“新表”中进行插入操作的对象会被无情抛弃。总结一下， HashMap 在高并发场景中， 新增对象丢失原因是： 并发赋值时被覆盖。 已遍历区间新增元素会丢失。 “新表被覆盖”。 迁移丢失。在迁移过程中， 有并发时， next 被提前置成 null。 JDK8 的扩容分析例如我们从 16 扩展为 32 时，具体的变化如下所示： resize引起的hash 因此元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n-1 的 mask 范围在高位多 1bit (红色)，因此新的 index就会发生这样的变化： index 因此，我们在扩充 HashMap 的时候，不需要重新计算 hash ，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是0的话索引没变，是 1 的话索引变成 “原索引 + oldCap”。可以看看下图为 16 扩充为 32 的 resize 示意图： resize 这个设计确实非常的巧妙，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 resize 的过程，均匀的把之前的冲突的节点分散到新的 bucket 了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102final Node&lt;K,V&gt;[] resize() &#123; //oldTab 为当前表的哈希桶 Node&lt;K,V&gt;[] oldTab = table; //当前哈希桶的容量 length int oldCap = (oldTab == null) ? 0 : oldTab.length //当前的阈值 int oldThr = threshold; //初始化新的容量和阈值为 0 int newCap, newThr = 0; //如果当前容量大于 0 if (oldCap &gt; 0) &#123; //超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; //没超过最大值，就扩充为原来的 2 倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) //如果旧的容量大于等于默认初始容量 16, 那么新的阈值也等于旧的阈值的两倍 newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr;//那么新表的容量就等于旧的阈值 else &#123;// zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY;//此时新表的容量为默认的容量 16 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);//新的阈值为默认容量 16 * 默认加载因子 0.75f = 12 &#125; if (newThr == 0) &#123;//如果新的阈值是 0，对应的是当前表是空的，但是有阈值的情况 float ft = (float)newCap * loadFactor;//根据新表容量和加载因子求出新的阈值 //进行越界修复 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; //更新阈值 threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) //根据新的容量构建新的哈希桶 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; //更新哈希桶引用 table = newTab; //如果以前的哈希桶中有元素 //下面开始将当前哈希桶中的所有节点转移到新的哈希桶中 if (oldTab != null) &#123; //把每个 bucket 都移动到新的 buckets 中 for (int j = 0; j &lt; oldCap; ++j) &#123; //取出当前的节点 e Node&lt;K,V&gt; e; //如果当前桶中有元素,则将链表赋值给 e if ((e = oldTab[j]) != null) &#123; //将原哈希桶置空以便 GC oldTab[j] = null; //如果当前链表中就一个元素，（没有发生哈希碰撞） if (e.next == null) //直接将这个元素放置在新的哈希桶里。 //注意这里取下标是用哈希值与桶的长度-1。由于桶的长度是2的n次方，这么做其实是等于一个模运算。但是效率更高 newTab[e.hash &amp; (newCap - 1)] = e; //如果发生过哈希碰撞 ,而且是节点数超过8个，转化成了红黑树 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); //如果发生过哈希碰撞，节点数小于 8 个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置。 else &#123; // preserve order //因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下标，即 low 位， 或者扩容后的下标，即 high 位。 high 位 = low 位 + 原哈希桶容量 //低位链表的头结点、尾节点 Node&lt;K,V&gt; loHead = null, loTail = null; //高位链表的头节点、尾节点 Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next;//临时节点 存放 e 的下一个节点 do &#123; next = e.next; //这里又是一个利用位运算 代替常规运算的高效点：利用哈希值与旧的容量，可以得到哈希值去模后，是大于等于 oldCap 还是小于 oldCap，等于 0 代表小于 oldCap，应该存放在低位，否则存放在高位 if ((e.hash &amp; oldCap) == 0) &#123; //给头尾节点指针赋值 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125;//高位也是相同的逻辑 else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125;//循环直到链表结束 &#125; while ((e = next) != null); //将低位链表存放在原 index 处， if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //将高位链表存放在新 index 处 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 此段代码来源：CSDN博客，采取了一些删改，注释太多太影响阅读。。 JDK 7 与 JDK 8 中关于 HashMap的对比 JDK 8 为红黑树 + 链表 + 数组的形式，当桶内元素大于 8 时，便会树化； hash 值的计算方式不同 (jdk 8 简化)； 1.7 table 在创建 hashmap 时分配空间，而 1.8 在 put 的时候分配，如果 table 为空，则为 table 分配空间； 在发生冲突，插入链中时，7 是头插法，8 是尾插法； 在 resize 操作中，7 需要重新进行 index 的计算，而 8 不需要，通过判断相应的位是 0 还是 1，要么依旧是原 index，要么是 oldCap + 原 index。 总结我们现在可以回答开始的几个问题，加深对 HashMap 的理解： 什么时候会使用 HashMap？他有什么特点？ 是基于 Map 接口的实现，存储键值对时，它可以接收 null 的键值，是非同步的，HashMap 存储着 Entry(hash, key, value, next) 对象。 你知道 HashMap 的工作原理吗？ 通过 hash 的方法，通过 put 和 get 存储和获取对象。存储对象时，我们将 K / V 传给 put 方法时，它调用 hashCode 计算 hash 从而得到 bucket 位置，进一步存储，HashMap 会根据当前 bucket 的占用情况自动调整容量 (超过 Load Facotr 则 resize 为原来的 2 倍)。获取对象时，我们将 K 传给 get ，它调用 hashCodeO() 计算 hash 从而得到 bucket 位置，并进一步调用 equals() 方法确定键值对。如果发生碰撞的时候，Hashmap 通过链表将产生碰撞冲突的元素组织起来，在 Java 8 中，如果一个 bucket 中碰撞冲突的元素超过某个限制 (默认是 8 )，则使用红黑树来替换链表，从而提高速度。 你知道 get 和 put 的原理吗？equals() 和 hashCode() 的都有什么作用？ 通过对 key 的 hashCode() 进行 hashing，并计算下标 ( (n-1) &amp; hash )，从而获得 buckets 的位置。如果产生碰撞，则利用 key.equals() 方法去链表或树中去查找对应的节点 你知道hash的实现吗？为什么要这样实现？ 在 Java 1.8 的实现中，是通过 hashCode() 的高 16 位异或低 16 位实现的：(h =k.hashCode()) ^ (h &gt;&gt;&gt; 16) ，主要是从速度、功效、质量来考虑的，这么做可以在 bucket 的 n 比较小的时候，也能保证考虑到高低 bit 都参与到 hash 的计算中，同时不会有太大的开销。 如果 HashMap 的大小超过了负载因子 ( load factor ) 定义的容量，怎么办？ 如果超过了负载因子 (默认0.75)，则会重新 resize 一个原来长度两倍的 HashMap，并且重新调用 hash 方法。 为什么 capcity 是 2 的幂？ 因为 算 index 时用的是(n-1) &amp; hash，这样就能保证 n-1 是全为 1 的二进制数，如果不全为 1 的话，存在某一位为 0，那么 0，1与 0 与的结果都是 0，这样便有可能将两个 hash 不同的值最终装入同一个桶中，造成冲突。所以必须是 2 的幂。 更多数据结构请访问我的博客-数据结构分类","tags":[{"name":"哈希","slug":"哈希","permalink":"http://www.allenmistake.top/tags/哈希/"}]},{"title":"红黑树的那些事","date":"2019-05-12T02:26:53.000Z","path":"2019/05/12/rbtree/","text":"这篇文章基本来自《码出高效》这本书， 由我自己总结归纳一些基础性的知识。部分图和源代码来自于CarpenterLee博客 从最简单的树说起1.树（Tree） 相对来说，树是一个很基础的概念， 不需要去多谈。 需要掌握两个概念： 深度：从根节点出发，到某节点边的条数。 高度：从某结点出发，到叶子节点为止， 最长简单路径上边的条数。 2.平衡二叉树 高度差为 1 的二叉树。 其性质如下： （1）树的左右高度差不能超过 1 （2）任何往下递归的左子树和右子树， 必须符合第一条性质。 （3）没有任何节点的空树或只有根节点的树也是平衡二叉树。 3.二叉查找树（又名二叉搜索树，Binary Search Tree） 性质：对于任意节点，它的左子树上所有节点的值都小于他， 而他的右子树上的所有节点的值都大于他。 遍历节点的三种方式：前序遍历、中序遍历、后序遍历。**他们三者规律如下** （1）在任何递归子树中， 左节点一定在右节点之前遍历。 （2）前序、中序、后序，仅指根节点在遍历时的位置顺序。 AVL 树与树形旋转AVL是一种平衡二叉查找树， 增加或删除节点后通过树形旋转重新达到平衡。 右旋：以某个节点为中心， 将他沉入当前右子节点的位置， 而让他当前的左子节点作为新树的根节点，也称为顺时针旋转；左旋：以某个节点为中心， 将他沉入当前左子节点的位置， 而让他当前的右子节点作为新树的根节点，也称为逆时针旋转； 左旋图示 右旋图示 左旋源代码12345678910111213141516//Rotate Rightprivate void rotateRight(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; l = p.left; p.left = l.right; if (l.right != null) l.right.parent = p; l.parent = p.parent; if (p.parent == null) root = l; else if (p.parent.right == p) p.parent.right = l; else p.parent.left = l; l.right = p; p.parent = l; &#125;&#125; 红黑树红黑树和 AVL 树类似，但不准求所有的递归子树高度差不超过 1，而是保证**从根节点到叶尾的最长路径不超过最短路径的两倍，所以他的最坏运行时间也是$O(\\text{log}n)$它的五个约束条件：1.节点只能是红色或者黑色2.根节点必须是黑色3.所有 NIL$^1$ 节点都是黑色4.一条路径上不能出现相邻的两个红色节点5.在任何递归子树内，根节点到叶子节点的所有路径上包含相同数目的黑色节点 【说明1】NIL 指在叶子节点不存在的两个虚拟节点，默认是黑色的。 红黑树 VS AVL树再插入时， 红黑树和AVL树都能在至多两次旋转内恢复平衡。在删除时由于红黑树只追求大致上的平衡， 因此红黑树能在至多三次旋转内恢复和平；而 AVL 树追求绝对平衡， 至多旋转$O(\\text{log}n)$次。 因此，面对频繁的插入和删除，红黑树较为合适；面对低频修改、大量查询时，AVL相对合适。 TreeMapTreeMap 是按照 Key 的排序结果来组织内部结构的 Map 类集合， 它改变了 Map 类散乱无序的形象。 虽然 TreeMap 没有 ConcurrentHashMap 和 HashMap 普及（毕竟插入和删除的效率远没有后两者高），但是在 Key 有排序要求的场景下， 使用 TreeMap 可以事半功倍。 在 TrreMap 的接口继承树， 有两个接口：SortedMap 和 NavigableMap。SortedMap 接口表示它的 Key 是有序不可重复的， 支持获取头尾 Key-Value 元素， 或者根据 Key 指定范围获取子集合。插入的 Key 必须实现 Comparable 或提供额外的比较器 Comparator ，所以 Key 不能是 null ，但是 Value 可以；NavigableMap 接口继承了 SortedMap ，根据指定的搜索条件返回最匹配的 Key-Value 元素。 不同于 HashMap ，TreeMap 并非一定要覆写 hashCode() 和 equals() 方法来达到Key去重的目的。 关于 TreeMap 和 HashMap 的例子请看《码处高效》P191-P192 ，这里不多做赘述。 类名与属性1234567891011121314151617181920public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable,java.io.Serializable&#123; //排序时用的比较器，put源码解析时会用到 private final Comparator&lt;? super K&gt; Comparator; //根节点，put源码时会提到 private transient Entry&lt;K,V&gt; root; //定义成为字面含义的常量。下方fixAfterInsertion()解析时会用到 private static final boolean RED = false; private static final boolean BLACK = true; //TreeMap 的内部类， 存储红黑树节点的载体类 ，在整个TreeMap 中高频出现 static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; V value; Entry&lt;K,V&gt; left; //指向左子树的引用 Entry&lt;K,V&gt; right; //指向右子树的引用 Entry&lt;K,V&gt; parent; //指向父节点的引用 //节点颜色信息是红黑树的精髓所在，默认是黑色 &#125;&#125; TreeMap 通过 put() 和 deleteEntry() 实现红黑树的增加和删除节点操作，下面的源码分析以插入主流程为例。再插入新节点之前，要明确三个前提条件： 需要调整的新节点总是红色的。 如果插入新节点的父节点是黑的，无需调整，因为依然能符合红黑树的5个约束条件。 如果插入新节点的父节点是红色的，因为红黑树规定不能出现相邻的两个红色节点，所以进入循环判断，或重新着色，或左右旋转，最终达到红黑树的五个约束条件，退出条件如下： 1while(x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) put 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public V put(K key, V value) &#123; // t 表示当前节点，记住这个很重要！ 先把 TreeMap 的根节点root引用赋值给当前节点 Entry&lt;K,V&gt; t = root; // 如果当前节点为 null ，即是空树，新增的 KV 形成的节点就是根节点 if (t == null) &#123; //看似多此一举， 实际上预检了Key是否可以比较 compare(key, key); //使用 KV 构造出的新的 Entry 对象， 其中第三个参数是 parent，根节点没有父节点 root = new Entry&lt;K,V&gt;(key, value, null); size = 1; modCount++; return null; &#125; // 记录比较结果 int cmp; Entry&lt;K,V&gt; parent; // 构造方法中置入的外部比较器 Comparator&lt;? super K&gt; cpr = comparator ; // 重要步骤：根据二叉树的性质， 找到新节点插入合适的位置 if (cpr != null) &#123; // 循环的目标：根据参数 Key 与当前节点的 Key 不断进行对比 do &#123; // 当前节点赋值给父节点， 故从根节点开始遍历比较 parent = t; // 比较输入参数 Key 和当前节点 Key 的大小 cmp = cpr.compare(key, t. key); // 参数的 Key 更小，向左面走，把当前接待你引用移动到他的左子节点上 if (cmp &lt; 0) t = t. left; // 新插入的key大的话，则以当前节点的右孩子节点为新的比较节点 else if (cmp &gt; 0) t = t. right; else // 如果当前节点的key和新插入的key相等的话，则覆盖map的value，返回 return t.setValue(value); // 如果没有相等的 Key， 一直会遍历到 NIL 节点为止 &#125; while (t != null); &#125; //在没有指定比较器的情况下， 调用自然排序的 Comparable 比较 else &#123; // 这里要求key不能为空，并且必须实现Comparable接口 if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 和上面一样，喜欢查找新节点要插入的位置 do &#123; parent = t; cmp = k.compareTo(t. key); if (cmp &lt; 0) t = t. left; else if (cmp &gt; 0) t = t. right; else return t.setValue(value); &#125; while (t != null); &#125; // 找到新节点的父节点后，创建节点对象 Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(key, value, parent); // 如果新节点key的值小于父节点key的值，则插在父节点的左侧 if (cmp &lt; 0) parent. left = e; // 如果新节点key的值大于父节点key的值，则插在父节点的右侧 else parent. right = e; // 插入新的节点后，为了保持红黑树平衡，对红黑树进行调整（重新着色、旋转操作） fixAfterInsertion(e); // map元素个数+1 size++; modCount++; return null;&#125; 重点：fixAfterInsertion() 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** 新增节点后对红黑树的调整方法 */private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; // 虽然内部类 Entry 的属性 color 默认为黑色， 但新节点一律先赋值为红色 x. color = RED; // 新节点是根节点或者其父节点（简称父亲）为黑色， // 插入红色节点并不会破坏红黑树的性质，无需调整。 // x 值的改变已被特别标记为(*)，改变的过程是在不断地向上游遍历（或内部调整） // 直到父亲为黑色， 或者到达根节点 while (x != null &amp;&amp; x != root &amp;&amp; x. parent.color == RED) &#123; // 如果新插入节点x的父节点是祖父节点的左孩子 if (parentOf(x) == leftOf(parentOf (parentOf(x)))) &#123; // 取得新插入节点x的叔叔节点 Entry&lt;K,V&gt; y = rightOf(parentOf (parentOf(x))); // 如果新插入x的父节点是红色-------------------① if (colorOf(y) == RED) &#123; // 将x的父节点设置为黑色 setColor(parentOf (x), BLACK); // 将x的叔叔节点设置为黑色 setColor(y, BLACK); // 将x的祖父节点设置为红色 setColor(parentOf (parentOf(x)), RED); // 将x指向祖父节点，如果x的祖父节点的父节点是红色，按照上面的步奏继续循环 x = parentOf(parentOf (x)); &#125; else &#123; // 如果新插入x的叔叔节点是黑色或缺少，且x的父节点是祖父节点的右孩子-------------------② if (x == rightOf( parentOf(x))) &#123; // 左旋父节点 x = parentOf(x); rotateLeft(x); &#125; // 如果新插入x的叔叔节点是黑色或缺少，且x的父节点是祖父节点的左孩子-------------------③ // 将x的父节点设置为黑色 setColor(parentOf (x), BLACK); // 将x的祖父节点设置为红色 setColor(parentOf (parentOf(x)), RED); // 右旋x的祖父节点 rotateRight( parentOf(parentOf (x))); &#125; &#125; else &#123; // 如果新插入节点x的父节点是祖父节点的右孩子，下面的步奏和上面的相似，只不过左旋右旋的区分，不再细讲 Entry&lt;K,V&gt; y = leftOf(parentOf (parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf (x), BLACK); setColor(y, BLACK); setColor(parentOf (parentOf(x)), RED); x = parentOf(parentOf (x)); &#125; else &#123; if (x == leftOf( parentOf(x))) &#123; x = parentOf(x); rotateRight(x); &#125; setColor(parentOf (x), BLACK); setColor(parentOf (parentOf(x)), RED); rotateLeft( parentOf(parentOf (x))); &#125; &#125; &#125; // 最后将根节点设置为黑色，不管当前是不是红色，反正根节点必须是黑色 root.color = BLACK;&#125; 这里只展开说一下左旋： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 对红黑树的节点(x)进行左旋转 * * 左旋示意图(对节点x进行左旋)： * px px * / / * x y * / \\ --(左旋)-- / \\ * lx y x ry * / \\ / \\ * ly ry lx ly * */private void rotateLeft(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; // 取得要选择节点p的右孩子 Entry&lt;K,V&gt; r = p. right; // \"p\"和\"r的左孩子\"的相互指向... // 将\"r的左孩子\"设为\"p的右孩子\" p. right = r.left ; // 如果r的左孩子非空，将\"p\"设为\"r的左孩子的父亲\" if (r.left != null) r. left.parent = p; // \"p的父亲\"和\"r\"的相互指向... // 将\"p的父亲\"设为\"y的父亲\" r. parent = p.parent ; // 如果\"p的父亲\"是空节点，则将r设为根节点 if (p.parent == null) root = r; // 如果p是它父节点的左孩子，则将r设为\"p的父节点的左孩子\" else if (p.parent. left == p) p. parent.left = r; else // 如果p是它父节点的左孩子，则将r设为\"p的父节点的左孩子\" p. parent.right = r; // \"p\"和\"r\"的相互指向... // 将\"p\"设为\"r的左孩子\" r. left = p; // 将\"p的父节点\"设为\"r\" p. parent = r; &#125;&#125; 调整图示 具体例子请看《码出高效》P197-P199 更多数据结构请访问我的博客-数据结构分类","tags":[{"name":"树","slug":"树","permalink":"http://www.allenmistake.top/tags/树/"}]},{"title":"Leetcode日记：62&63：独一无二的路径","date":"2019-05-11T03:02:50.000Z","path":"2019/05/11/leetcode62/","text":"62题目一个只能向右走或向下走的机器人位于左上角，要到右下角，有多少种唯一的路径？ 机器人路径 Example 1: 1234567Input: m = 3, n = 2Output: 3Explanation:From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:1. Right -&gt; Right -&gt; Down2. Right -&gt; Down -&gt; Right3. Down -&gt; Right -&gt; Right Example 2: 12Input: m = 7, n = 3Output: 28 62分析62这道题可以完全不用动态规划， 利用简单的排列组合也能解决问题 。 但是为了引出63， 还是给出动态规划的解法。 排列组合通过观察， 总结规律， 我们可以知道， 结果和行、列关系如下 $$result = \\frac{(m-1+n-1)!}{(m-1)!(n-1)!}$$ 可能你看这个公式会有点懵， 但是， 结合图片可以分析到， 当迷宫是7*3时，我们势必要走两个 down($n-1$)和 6($m-1$) 个 right ，于是就变成了$C_8^2$或者你也可以认为$C_8^6$ 下面排列组合的代码中， 可以关注一下关于排列组合的运算代码 动态规划在前面的动态规划我们提到， 动态规划需要有一个存储结构， 即所谓的“记忆性”， 应用在这道题目上面， 记忆性便是指当前方格的唯一路径数。在程序上，我们首先遍历两个边界，也就是第一行和第一列，将他们全部置为 1（由于机器人只能向下和向右，所以边界的不重复路径只有一条），然后我们遍历其他方块， 方块的可达路径数等于他上面的方块路径数 + 他左面的方块的路径数， 即 $$res[i][j]=res[i-1][j]+res[i][j]$$ 计算到右下角， 右下角的路径数即为最终结果 代码排列组合代码1234567891011121314151617181920public class Solution &#123; public int uniquePaths(int m, int n) &#123; if(m == 1 || n == 1) return 1; m--; n--; if(m &lt; n) &#123; // Swap, so that m is the bigger number m = m + n; n = m - n; m = m - n; &#125; long res = 1; int j = 1; for(int i = m+1; i &lt;= m+n; i++, j++)&#123; // Instead of taking factorial, keep on multiply &amp; divide res *= i; res /= j; &#125; return (int)res; &#125;&#125; 动态规划代码1234567891011121314151617public class Solution &#123; public int uniquePaths(int m, int n) &#123; Integer[][] map = new Integer[m][n]; for(int i = 0; i&lt;m;i++)&#123; map[i][0] = 1; &#125; for(int j= 0;j&lt;n;j++)&#123; map[0][j]=1; &#125; for(int i = 1;i&lt;m;i++)&#123; for(int j = 1;j&lt;n;j++)&#123; map[i][j] = map[i-1][j]+map[i][j-1]; &#125; &#125; return map[m-1][n-1]; &#125;&#125; 63题目这次题目在 62 的基础上稍微有些修改 ，机器人的走法不变， 但是地图会出现障碍物， 给定一个 m*n 二维数组， 0 表示没有障碍物， 1 表示此路不通。 Example 1: 123456789101112Input:[ [0,0,0], [0,1,0], [0,0,0]]Output: 2Explanation:There is one obstacle in the middle of the 3x3 grid above.There are two ways to reach the bottom-right corner:1. Right -&gt; Right -&gt; Down -&gt; Down2. Down -&gt; Down -&gt; Right -&gt; Right 63分析这种情况下，显然我们的排列组合方法就不适用了， 继续用动态规划问题解决， 我们仍然采取“记忆法”： 首先，检查左上角元素是不是阻挡快 ，如果不是阻挡块（0），则更新为 1 ，这个 1 的含义就是 62 中的可达路径数（下面简称路径数）。 然后 ，遍历两个边界， 这个时候比 62 题多了一个判断， 如果前一个是 1（路径数）（注意：这个 1 不是阻挡块的 1 而是更新后的路径数 ，而自己是 0 （未更新，非阻挡块），则将它置为 1，否则置为 0 。 过程图： 初始状态 遍历行边界 遍历列边界 遍历全部 代码123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int R = obstacleGrid.length; int C = obstacleGrid[0].length; // If the starting cell has an obstacle, then simply return as there would be // no paths to the destination. if (obstacleGrid[0][0] == 1) &#123; return 0; &#125; // Number of ways of reaching the starting cell = 1. obstacleGrid[0][0] = 1; // Filling the values for the first column for (int i = 1; i &lt; R; i++) &#123; obstacleGrid[i][0] = (obstacleGrid[i][0] == 0 &amp;&amp; obstacleGrid[i - 1][0] == 1) ? 1 : 0; &#125; // Filling the values for the first row for (int i = 1; i &lt; C; i++) &#123; obstacleGrid[0][i] = (obstacleGrid[0][i] == 0 &amp;&amp; obstacleGrid[0][i - 1] == 1) ? 1 : 0; &#125; // Starting from cell(1,1) fill up the values // No. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1] // i.e. From above and left. for (int i = 1; i &lt; R; i++) &#123; for (int j = 1; j &lt; C; j++) &#123; if (obstacleGrid[i][j] == 0) &#123; obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]; &#125; else &#123; obstacleGrid[i][j] = 0; &#125; &#125; &#125; // Return value stored in rightmost bottommost cell. That is the destination. return obstacleGrid[R - 1][C - 1]; &#125;&#125; 更多动态规划问题更多动态规划问题关注标签：动态规划","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.allenmistake.top/tags/动态规划/"}]},{"title":"4月总结 and 5月计划","date":"2019-05-07T02:27:06.000Z","path":"2019/05/07/monthlysummary/","text":"4月份工作4月份是一个忙碌的月份 ，这个月发表的文章只有可怜的 4 篇 ，主要是清明、老爸生日、羽毛球比赛、五一假期这一系列 ，可以说是树欲静而风不止了 ，其实还是懒 ，不想着怎么提高技术 ，总是找借口。 Leetcode ： 哈希表相关总结 动态规划相关总结 Java： 关于并发的一些知识 其他 读书任务：《万历十五年》、《骆驼祥子》这两本都是在读 ，并没有读完。 仅此而已 ，和充实的三月比简直惭愧 。 5月份计划Leetcode 巩固三大模块：回溯、哈希表、动态规划 ，每个模块不少于 3 道新题 总共至少 15 道题目 《Java开发手册》 看红黑树（含 b 数）、哈希表等几个数据结构 垃圾回收规范 并发 5月是调整的一月 ，慢慢把自己的节奏找回来 ，继续奋斗。 其他感悟最近看了两部电影 ，都让我感觉很惊喜 。 调音师说是调音师 ，但实际上和调音一点关系都没有 ，貌似是致敬法国的短片《调音师》 ，影片中故事不多讲述了 ，给我印象最深的有两个 你听到的不一定是真的 ，就算是真的 ，也只是一部分 ，带有主观色彩 没有绝对的善恶 ，每个人都是复杂的 。 第二点我不想多说 ，这点在很多小说或者电影都有体现。 第一点 ，我觉得这部电影为什么是 “调音师” ，因为当别人给你讲述故事的时候 ，会不自觉的将原本的事实 ，像调音师一样 ，变成带有自己主观色彩的 “变音” ，或添油加醋，或夸大对自己有利的 ，忽略对自己不利的 ，而作为聆听者 ，我们要做的 ，只能是保留自己的一份怀疑 ，毕竟我们也不知道事实是怎样的 。 老师好这部电影有点后悔没去电影院看 ，应该去支持一下的 ，谦大爷的演技感觉还是不错的 ，并没有说相声的感觉 ，《老师·好》有一种清新感 ，感觉很纯粹 ，有的时候你确实需要一部这样的电影放松放松了。","tags":[]},{"title":"Leetcode日记：32：最长有效括号","date":"2019-04-22T03:23:15.000Z","path":"2019/04/22/leetcode32/","text":"题目给定一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 123输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot; 示例 2: 123输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot; 题目分析暴力法在这种方法中，我们考虑给定字符串中每个可能的非空偶数长度子字符串，并检查它是否是有效的括号字符串。为了检查有效性，我们使用堆栈方法。 每当我们遇到一个$\\text{‘(‘} $，我们就把它推到堆栈上。对于遇到的每个$\\text{‘)’} $，我们都会从堆栈中弹出一个$\\text{‘(‘} $。如果$\\text{‘(‘} $在堆栈上不可随时弹出，或者如果堆栈在处理完完整的子字符串后包含一些元素，括号中的子字符串无效。这样，我们对每一个可能的子串重复这个过程，并继续存储迄今为止找到的最长有效字符串的长度。 1234567891011121314151617181920212223242526public class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == '(') &#123; stack.push('('); &#125; else if (!stack.empty() &amp;&amp; stack.peek() == '(') &#123; stack.pop(); &#125; else &#123; return false; &#125; &#125; return stack.empty(); &#125; public int longestValidParentheses(String s) &#123; int maxlen = 0; for (int i = 0; i &lt; s.length(); i++) &#123; for (int j = i + 2; j &lt;= s.length(); j+=2) &#123; if (isValid(s.substring(i, j))) &#123; maxlen = Math.max(maxlen, j - i); &#125; &#125; &#125; return maxlen; &#125;&#125; 复杂度分析： 时间复杂度：$O(n^3)$ , 从长度为 $n$ 的字符串产生可能的子串需要$O(n^2)$ , 检查长度有效性需要 $O(n)$ 空间复杂度：$O(n)$ , 栈的长度为 $n$ 动态规划这个问题可以通过使用动态规划来解决。我们使用 $\\text{dp}$ 数组，其中 $\\text{dp}$ 的第 $i$ 元素表示以 $i$ 索引结尾的最长有效子字符串的长度。我们用0初始化完整的 $\\text{dp}$ 数组。现在，很明显，有效的子字符串必须以 $\\text{‘)’} $ 结尾。这进一步导致以 $\\text{‘(‘} $ 结尾的子字符串在其对应的 $\\text{dp}$ 索引处总是包含’ 0 ‘。因此，我们仅在遇到 $\\text{‘)’} $ 时更新 $\\text{dp}$ 数组。 要填充 $\\text{dp}$ 数组，我们将每两个连续字符检查一次字符串，如果 $\\text{s}[i]=’)’ $ 、 $\\text{s}[i - 1] = \\text{‘(’}$, 例如这种字符串 “……()” $\\Rightarrow$ ​ $\\text{dp}[i]=\\text{dp}[i-2]+2$ 我们这样做是因为结尾 “()” 部分无论如何都是有效的子串，并导致前一个有效子串的长度增加2。 $\\text{s}[i] = \\text{‘)’}$、 $\\text{s}[i - 1] = \\text{‘)’}$ 例如这种字符串…….))” $\\Rightarrow$ 如果 $\\text{s}[i - \\text{dp}[i - 1] - 1] = \\text{‘(’}$ 那么 ​ $\\text{dp}[i]=\\text{dp}[i-1]+\\text{dp}[i-\\text{dp}[i-1]-2]+2$ $\\text{dp}[i]$ 表示以当前位置为终点的最长长度，则只能在 ）处更新， 如果 $\\text{s}[i - \\text{dp}[i - 1] - 1] = \\text{‘(’}$，则说明当前位置可以和 $i-1-\\text{dp}[i-1]$ 位置匹配，$\\text{dp}[i]=\\text{dp}[i-1]+2$ 然后还要加上匹配位置之前的最长长度 $\\text{dp}[i]+=\\text{dp}[i-\\text{dp}[i]]$ 代码： 1234567891011121314151617public class Solution &#123; public int longestValidParentheses(String s) &#123; int maxans = 0; int dp[] = new int[s.length()]; for (int i = 1; i &lt; s.length(); i++) &#123; if (s.charAt(i) == ')') &#123; if (s.charAt(i - 1) == '(') &#123; dp[i] = (i &gt;= 2 ? dp[i - 2] : 0) + 2; &#125; else if (i - dp[i - 1] &gt; 0 &amp;&amp; s.charAt(i - dp[i - 1] - 1) == '(') &#123; dp[i] = dp[i - 1] + ((i - dp[i - 1]) &gt;= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2; &#125; maxans = Math.max(maxans, dp[i]); &#125; &#125; return maxans; &#125;&#125; 利用栈我们可以在扫描给定字符串时使用堆栈来检查到目前为止扫描的字符串是否有效，以及最长有效字符串的长度，而不是查找每个可能的字符串并检查其有效性。为了做到这一点，我们首先将-1 -1推到堆栈上。 对于遇到的每一个 $\\text{‘(‘}$ ，我们将其索引推送到堆栈上。 对于遇到的每一个$\\text{‘)’} $，我们弹出最顶端的元素，并从堆栈的顶端元素中减去当前元素的索引，这将给出当前遇到的有效括号字符串的长度。如果弹出元素时，堆栈变空，我们将当前元素的索引推到堆栈上。这样，我们继续计算有效子字符串的长度，并在末尾返回最长有效字符串的长度。 代码： 123456789101112131415161718192021public class Solution &#123; public int longestValidParentheses(String s) &#123; int maxans = 0; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(-1); for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == '(') &#123; stack.push(i); &#125; else &#123; stack.pop(); if (stack.empty()) &#123; stack.push(i); &#125; else &#123; maxans = Math.max(maxans, i - stack.peek()); &#125; &#125; &#125; return maxans; &#125;&#125; 不需要额外空间12345678910111213141516171819202122232425262728293031public class Solution &#123; public int longestValidParentheses(String s) &#123; int left = 0, right = 0, maxlength = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if (s.charAt(i) == '(') &#123; left++; &#125; else &#123; right++; &#125; if (left == right) &#123; maxlength = Math.max(maxlength, 2 * right); &#125; else if (right &gt;= left) &#123; left = right = 0; &#125; &#125; left = right = 0; for (int i = s.length() - 1; i &gt;= 0; i--) &#123; if (s.charAt(i) == '(') &#123; left++; &#125; else &#123; right++; &#125; if (left == right) &#123; maxlength = Math.max(maxlength, 2 * left); &#125; else if (left &gt;= right) &#123; left = right = 0; &#125; &#125; return maxlength; &#125;&#125; 更多动态规划问题更多动态规划问题关注标签：动态规划","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.allenmistake.top/tags/动态规划/"},{"name":"栈","slug":"栈","permalink":"http://www.allenmistake.top/tags/栈/"}]},{"title":"Leetcode日记：55.跳跃游戏 & 动态规划","date":"2019-04-20T04:01:40.000Z","path":"2019/04/20/leetcode55dp/","text":"jump 题目给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1: 123输入: [2,3,1,1,4]输出: true解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。 示例 2: 123输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 题目分析这是一个动态规划问题，通常，解决并完全理解动态规划问题需要以下 4 步： 从递归回溯解决方案开始 通过使用带有记忆属性的表进行优化(自上而下的[2]动态规划) 移除递归(自下而上的动态规划) 应用最后的技巧来降低时间/内存的复杂性 以下所有方法都可适用，只是时间复杂度和空间复杂度不同。 解题方法回溯法这是一个低效的解决方案，我们尝试从第一个位置到最后一个位置的每一个跳跃模式。我们从第一个位置开始，跳到每个可以到达的索引。我们重复这个过程，直到达到最后一个索引。卡住时，后退。 代码： 1234567891011121314151617181920public class Solution &#123; public boolean canJumpFromPosition(int position, int[] nums) &#123; if (position == nums.length - 1) &#123; return true; &#125; int furthestJump = Math.min(position + nums[position], nums.length - 1); for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++) &#123; if (canJumpFromPosition(nextPosition, nums)) &#123; return true; &#125; &#125; return false; &#125; public boolean canJump(int[] nums) &#123; return canJumpFromPosition(0, nums); &#125;&#125; 对于上面的代码，我们可以做的一个快速优化是从右向左检查nextPosition。理论上最坏的情况性能是一样的，但是实际上，对于愚蠢的例子，代码可能运行得更快。直观上来讲，这意味着我们总是试图跳得最大，以便尽快到达终点 所需的更改是: 1234// Oldfor (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++)// Newfor (int nextPosition = furthestJump; nextPosition &gt; position; nextPosition--) 假定，在下面这个例子中，如果我们从 index 0开始，跳得越远越好，达到1，跳得越远越好，达到6。通过这样做，我们分三步确定0是一个好的索引。 Index 0 1 2 3 4 5 6 nums 1 5 2 1 0 2 0 为了说明这种优化不起作用的最坏情况，以下面的例子为例。无法从任何位置到达索引6，但将尝试所有组合。 Index 0 1 2 3 4 5 6 nums 5 4 3 2 1 0 0 上面这个例子回溯的前几步是: 0 -&gt; 4 -&gt; 5 -&gt; 4 -&gt; 0 -&gt; 3 -&gt; 5 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; etc. 复杂度分析 Time complexity : $O(2^n)$. 从初始位置走到最后位置，有 $2^n$(upper bound) 种方法, $n$ 是数组 nums 的长度. Space complexity : $O(n)$. 递归需要额外的空间分配给栈. 自上至下的动态规划自上而下的动态规划可以被认为是优化的回溯。它依赖于这样的观察，即一旦我们确定某个指数是好的/坏的，这个结果永远不会改变。这意味着我们可以存储结果，而不需要每次都重新计算。 因此，对于数组中的每个位置，我们都记得 index 是好是坏。让我们调用这个数组 memo ，并让它的值为:好、坏、未知之一。这种技术被称为记忆化。 输入数组 nums = [2，4，2，1，0，2，0] 的记忆表示例如下图所示。我们用 G 代表好位置，用 B 代表坏位置。我们可以看到，我们不能从索引2、3或4开始，最终到达最后一个索引(6)，但我们可以从索引0、1、5和(一般)6开始。 Index 0 1 2 3 4 5 6 nums 2 4 2 1 0 2 0 memo G G B B B G G Steps 最初，记忆表中所有元素是 UNKNOWN, 除了最后一个, (一般情况下) 是 GOOD (他一定能到达自己) 修改回溯算法，以便递归步骤首先检查索引是否已知(好/坏) 如果已知（KNOWN） 则返回 True / False 否则像以前一样执行回溯步骤 一旦我们确定了当前索引的值，我们就将其存储在 memo 表中 代码： 123456789101112131415161718192021222324252627282930313233enum Index &#123; GOOD, BAD, UNKNOWN&#125;public class Solution &#123; Index[] memo; public boolean canJumpFromPosition(int position, int[] nums) &#123; if (memo[position] != Index.UNKNOWN) &#123; return memo[position] == Index.GOOD ? true : false; &#125; int furthestJump = Math.min(position + nums[position], nums.length - 1); for (int nextPosition = position + 1; nextPosition &lt;= furthestJump; nextPosition++) &#123; if (canJumpFromPosition(nextPosition, nums)) &#123; memo[position] = Index.GOOD; return true; &#125; &#125; memo[position] = Index.BAD; return false; &#125; public boolean canJump(int[] nums) &#123; memo = new Index[nums.length]; for (int i = 0; i &lt; memo.length; i++) &#123; memo[i] = Index.UNKNOWN; &#125; memo[memo.length - 1] = Index.GOOD; return canJumpFromPosition(0, nums); &#125;&#125; 复杂度分析 时间复杂度 : $O(n^2)$. 对于数组中的每一个元素 ， 比如 i ， 我们将会从他的右面查找下一个 nums[i] 元素 ，以找到 GOOD 索引 ， nums[i]最大可能是 $n$ ，$n$ 是数组长度。 空间复杂度 : $O(2n) = O(n)$. 第一个 $n$ 来自于递归 ， 第二个 $n$ 来自于 memo 表的存储。 自下至上的动态规划自上而下到自下而上的转换是通过消除递归来完成的。实际上，这实现了更好的性能，因为我们不再有方法堆栈开销，甚至可能从一些缓存中受益。更重要的是，这一步为未来的优化开辟了可能性。递归通常是通过尝试颠倒自顶向下方法的步骤顺序来消除的。 这里要做的观察是，我们只跳到右边。这意味着，如果我们从数组的右边开始，每次我们查询右边的位置时，该位置已经被确定为 GOOD 或 BAD. 这意味着我们不需要再重复了，因为我们总是会碰撞 memo 表. 代码： 12345678910111213141516171819202122232425enum Index &#123; GOOD, BAD, UNKNOWN&#125;public class Solution &#123; public boolean canJump(int[] nums) &#123; Index[] memo = new Index[nums.length]; for (int i = 0; i &lt; memo.length; i++) &#123; memo[i] = Index.UNKNOWN; &#125; memo[memo.length - 1] = Index.GOOD; for (int i = nums.length - 2; i &gt;= 0; i--) &#123; int furthestJump = Math.min(i + nums[i], nums.length - 1); for (int j = i + 1; j &lt;= furthestJump; j++) &#123; if (memo[j] == Index.GOOD) &#123; memo[i] = Index.GOOD; break; &#125; &#125; &#125; return memo[0] == Index.GOOD; &#125;&#125; 贪心算法一旦我们的代码处于自下而上的状态，我们就可以进行最后一次重要的观察。从一个给定的位置，当我们试图看是否能跳到一个 GOOD 位置时，我们只使用一个——第一个(见 break 语句)。换句话说，最左边的一个。如果我们把这个最左边的 GOOD 位置作为一个单独的变量来跟踪，我们可以避免在数组中搜索它。不仅如此，我们还可以完全停止使用数组。 从右向左迭代，对于每个位置，我们检查是否有潜在的跳跃达到 GOOD 的 index (currPosition + nums[currPosition] &gt;= leftmostGoodIndex )。如果我们能达到一个好的指数，那么我们的位置本身就是好的。此外，这个新的好位置将是新的最左边的好索引。迭代一直持续到数组的开始。如果第一个位置是好指数，那么我们可以从第一个位置到达最后一个指数。 为了说明这个场景，我们将使用下图，对于输入数组 nums = [9，4，2，1，0，2，0] 。我们写 G 代表好，B 代表坏，U 代表未知。假设我们一直迭代到位置 0，我们需要决定索引0是否是好的。因为指数1被确定为 GOOD ，所以跳到那里就足够了，然后确保我们最终能达到指数6。大到足以一路跳到最后一个指数并不重要。我们只需要一种方法。 Index 0 1 2 3 4 5 6 nums 9 4 2 1 0 2 0 memo U G B B B G G 代码： 1234567891011public class Solution &#123; public boolean canJump(int[] nums) &#123; int lastPos = nums.length - 1; for (int i = nums.length - 1; i &gt;= 0; i--) &#123; if (i + nums[i] &gt;= lastPos) &#123; lastPos = i; &#125; &#125; return lastPos == 0; &#125;&#125; 动态规划问题总结动态规划问题常用步骤通常，解决并完全理解动态规划问题需要以下 4 步： 从递归回溯解决方案开始 通过使用带有记忆属性的表进行优化(自上而下的[2]动态规划) 移除递归(自下而上的动态规划) 应用最后的技巧来降低时间/内存的复杂性 动态规划特点动态规划仍带有一些递归特性，也可以改成回溯的形式，但是和较为傻瓜，一条路走到黑的回溯相比，动态规划有着自己的最优解决策： 它利用一张带有记忆属性的表来存储最优情况。 动态规划适用问题能采用动态规划求解的问题的一般要具有3个性质： 最优化原理：假设问题的最优解所包括的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。 无后效性：即某阶段状态一旦确定。就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响曾经的状态。仅仅与当前状态有关； 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到（该性质并非动态规划适用的必要条件，可是假设没有这条性质。动态规划算法同其它算法相比就不具备优势）。 更多动态规划问题更多动态规划问题关注标签：动态规划","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.allenmistake.top/tags/动态规划/"},{"name":"回溯","slug":"回溯","permalink":"http://www.allenmistake.top/tags/回溯/"},{"name":"贪心算法","slug":"贪心算法","permalink":"http://www.allenmistake.top/tags/贪心算法/"}]},{"title":"Leetcode日记：49.错位词组队&哈希表相关操作","date":"2019-04-09T08:24:33.000Z","path":"2019/04/09/leetcode49hash/","text":"题目给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 1234567输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],输出:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 问题分析题目中可以看出，我们要找出满足某一种条件的字符串集合，这个条件是：字母全对，只是错位针对这种情况，我们可以利用算法，先将字符串排序，再比较(排序之后的两个错位字符串会变成一样的)。或者统计每个字符串所出现字母次数，放入哈希表进行比较。 方法一：排序数组分类 思路 当且仅当它们的排序字符串相等时，两个字符串是字母异位词。 算法 维护一个映射 ans : {String -&gt; List}，其中每个键 $K$ 是一个排序字符串，每个值是初始输入的字符串列表，排序后等于 $K$。 在 Java 中，我们将键存储为字符串，例如，code。 方法二：计数分类1.思路 当且仅当它们的字符计数（每个字符的出现次数）相同时，两个字符串是字母异位词。 算法 我们可以将每个字符串 $\\text{s}$ 转换为字符数 $\\text{count}$，由26个非负整数组成，表示 $ \\text{a} $，$\\text{b}$，$\\text{c}​$ 的数量等。我们使用这些计数作为哈希映射的基础。 在 Java 中，我们的字符数 count 的散列化表示将是一个用 ＃ 字符分隔的字符串。 例如，abbccc 将表示为 ＃1＃2＃3＃0＃0＃0 …＃0（表示 a 出现了1次， b 出现了2次），其中总共有26个条目。。 代码-排序123456789101112131415class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; if (strs.length == 0) return new ArrayList(); Map&lt;String, List&gt; ans = new HashMap&lt;String, List&gt;(); for (String s : strs) &#123; //将每个字符串转换成字符数组 char[] ca = s.toCharArray(); Arrays.sort(ca); String key = String.valueOf(ca); if (!ans.containsKey(key)) ans.put(key, new ArrayList()); ans.get(key).add(s); &#125; return new ArrayList(ans.values()); &#125;&#125; 代码-计数123456789101112131415161718192021222324class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; if (strs.length == 0) return new ArrayList(); Map&lt;String, List&gt; ans = new HashMap&lt;String, List&gt;(); int[] count = new int[26]; for (String s : strs) &#123; //初始化字母表 Arrays.fill(count, 0); //统计一个字符串中字幕出现情况 for (char c : s.toCharArray()) count[c - 'a']++; //将统计的情况转换成StringBuilder key = 统计情况 value = 同一个错位词Group StringBuilder sb = new StringBuilder(\"\"); for (int i = 0; i &lt; 26; i++) &#123; sb.append('#'); sb.append(count[i]); &#125; String key = sb.toString(); if (!ans.containsKey(key)) ans.put(key, new ArrayList()); //如果key相同，说明统计情况一样，便为错位词Group，添加到List ans.get(key).add(s); &#125; return new ArrayList(ans.values()); &#125;&#125; 哈希表相关操作哈希表实现原理关于hash的具体实现规则，Java源代码请看之前Java基础集合篇。 Hash家族 Hashtable 是一个包含单向链表的二维数组，其数据结构的数组中是 Entry&lt;K,V&gt; 存储， entry 对象。 Hashtable 有洁癖，不允许存入其中的 key 或者 value 为 null。Hashtable 是线程安全的，所有的方法均用 synchronized 修饰，这样在任一时刻，只有一个线程可以写 Hashtable，因此，对于频繁写操作的业务逻辑，速度会非常慢。 HashMap 是最常用的 Map 型数据结构，它根据键的 hashCode() 值存储数据。HashMap 允许一个 key 为 null ,允许多个 value 为空，HashMap 不支持线程的同步，即可能会出现在同一时刻有多个线程同时写 HashMap ,会产生数据的不一致。如果在修改代码的过程中，需要给 HashMap 限制为线程同步的，可以采用 Collections.synchronizedMap(map); 方法使得HashMap 可以同步。 ConcurrentHashMap是基于这样的考虑：降低锁的粒度。在 Hashtable 中的关键字是使用 synchronized 基于整张表结构的，锁的粒度太大，它每次通过锁住整张表让线程独占，来保证安全性。 LinkedHashMap 保存了记录的插入顺序，在使用 Iterator 遍历 LinkedHashMap 的时候，先得到的记录肯定是先插入的。在遍历的时候会比 HashMap 慢，因为 HashMap 是以O(1)来设计存取的。并且 LinkedHashMap 继承自 HashMap ，拥有它的全部特性。 TreeMap是基于红黑树实现的，它是一种有序的存储结构，并且程序员可以自己定义排序器。TreeMap 默认会按存入的键值 key 来排序，默认是按升序排序，当然也可以指定排序的比较器。 TreeMap 同样有洁癖，不允许存入 null 值。使用 Iterator 遍历出来的 TreeMap 往往是有序的。 总结：常用HashMap，允许null插入；有两个子类：ConcurrentHashMap和LinkedHashMap。前者用来弥补线程安全，后者用来弥补有序。此外还有Hashtable和TreeMap。虽然CouncurrentHashMap性能明显优于Hashtable，但是并不能完全取代Hashtable，因为遍历ConcurrentHashMap的迭代器是弱一致的。TreeMap数据结构则可以帮助我们得到一个有序的结果，适用于需要输出排序结果的场景。 注意：Java 8 改进特性 Java 8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。在 Java 8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。 几个常用hash函数一般做题的时候，通常是用 HashMap 解决问题。 创建一个hashMap 1Map&lt;String, List&gt; ans = new HashMap&lt;String, List&gt;(); 在尖括号里，第一个类型是 KEY , 第二个类型是 VALUE 。 判断元素是否存在 12boolean containsKey(Object key)boolean containsValue(Object value) 根据 key 找 value 1V get(Object key) 添加一对新的键值组合 1V put(K key, V value) 删除对应的key 1V remove(Object key) 其他函数 12345678void clear()Object clone()Set&lt;Entry&lt;K, V&gt;&gt; entrySet()boolean isEmpty()Set&lt;K&gt; keySet()void putAll(Map&lt;? extends K, ? extends V&gt; map)int size()Collection&lt;V&gt; values() hashmap应用场景在实际应用中，hashMap数据结构 适用以下几个情况 需要遍历许多次才能解决的问题，hashMap 可以大大减小算法的时间复杂度 需要记忆性的问题，像这道题，我们需要记住每个字符的所属情况，并给他们打一个专属标记。 更多关于哈希表的问题更多关于哈希表的问题请转到链表标签","tags":[{"name":"哈希","slug":"哈希","permalink":"http://www.allenmistake.top/tags/哈希/"},{"name":"字符串","slug":"字符串","permalink":"http://www.allenmistake.top/tags/字符串/"}]},{"title":"Leetcode日记：138.复制带随机指针的链表","date":"2019-04-08T03:56:07.000Z","path":"2019/04/08/leetcode138/","text":"题目给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。 要求返回这个链表的深拷贝。 示意图 示例： 123456输入：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;next&quot;:null,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:2&#125;,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:1&#125;解释：节点 1 的值是 1，它的下一个指针和随机指针都指向节点 2 。节点 2 的值是 2，它的下一个指针指向 null，随机指针指向它自己。 节点数据结构如下 123456789101112131415// Definition for a Node.class Node &#123; public int val; public Node next; public Node random; public Node() &#123;&#125; public Node(int _val,Node _next,Node _random) &#123; val = _val; next = _next; random = _random; &#125;&#125;; 题目分析其实我一开始没太看懂，所以题目特意用的中文版的。大概意思就是，有这么一个链表，其中的节点不止有 next 指针，还有一个指向随机节点的 random 指针，要求我们复制一个它的深拷贝，即重新开辟一个空间，传值而不是传引用。 哈希表解题思路代码1：哈希表12345678910111213141516171819202122public Node copyRandomList(Node head) &#123; if (head == null) return null; Map&lt;Node, Node&gt; map = new HashMap&lt;&gt;(); // loop 1. copy所有节点 RandomListNode cur = head; while (cur != null) &#123; map.put(cur, new Node(cur.val, null, null)); cur = cur.next; &#125; // loop 2. 分配所有的指针( next 和 random ) cur = head; while (cur != null) &#123; map.get(cur).next = map.get(cur.next); map.get(cur).random = map.get(cur.random); cur = cur.next; &#125; return map.get(head);&#125; 优化——常数空间复杂度一个直观的解决方案是为列表中的每个节点保留一个哈希表，通过这个哈希表，我们只需要分别在两轮中迭代列表来创建节点并为它们的随机指针分配值。结果，这个解的空间复杂度是0(N)，尽管具有线性时间复杂度。 作为一个优化的解决方案，我们可以将空间复杂度降低到常数。想法是将原始节点与其副本节点关联在一个链接列表中。这样，我们不需要额外的空间来跟踪新节点。 该算法由以下三个步骤组成，也是三轮迭代。 迭代原始列表并复制每个节点。每个节点的副本会立即跟随其原始副本。迭代新列表，并为每个复制的节点分配随机指针。恢复原始列表并提取重复的节点。该算法实现图示如下: 示意图1 示意图2 代码2：常数空间复杂度1234567891011121314151617181920212223242526272829public Node copyRandomList(Node head) &#123; if (head == null) return null; Node cur = head; //第一步：copy一份，并放在原版后面 while (cur != null) &#123; Node next = cur.next; cur.next = new Node(cur.val, next, null); cur = next; &#125; //第二步：令copy的随机指针指向应该指向的copy cur = head; while (cur != null) &#123; if (cur.random != null) cur.next.random = cur.random.next; cur = cur.next.next; &#125; //第三步：把cpoy分离出来 cur = head; Node copyHead = head.next; while (cur != null) &#123; Node next = cur.next.next; Node copy = cur.next; cur.next = next; if (next != null) copy.next = next.next; cur = next; &#125; return copyHead;&#125; 更多关于链表的问题更多关于链表的问题请转到链表标签 更多关于哈希表的问题更多关于哈希表的问题请转到链表标签","tags":[{"name":"哈希","slug":"哈希","permalink":"http://www.allenmistake.top/tags/哈希/"},{"name":"链表","slug":"链表","permalink":"http://www.allenmistake.top/tags/链表/"}]},{"title":"Leetcode日记：92&206.反转链表","date":"2019-04-01T12:20:44.000Z","path":"2019/04/01/leetcode92-206/","text":"Leetcode日记：92&amp;206.反转链表92.反转链表其中一段Reverse a linked list from position m to n. Do it in one-pass.Note: 1 ≤ m ≤ n ≤ length of list.Example: 12Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 92-题目分析也不知道Leetcode是怎么排布的题的顺序，但是唯一的可能是按题出现的频率，因为这个92题是II，206才是I。所以我们主要分析这道题。无非就是给你两个数，让你翻转第 M 个到底 N 个链表上的元素。 反转问题确实也是链表中常见的一种类型。而且这种题看似简单，但思考起来很容易搞乱。下面从代码的角度分析一下： 92-代码-1代码一：节点插入 12345678910111213141516171819202122232425262728public ListNode reverseBetween(ListNode head, int m, int n) &#123; if(head == null) return null; // create a dummy node to mark the head of this list ListNode dummy = new ListNode(0); dummy.next = head; // make a pointer pre as a marker for the node before reversing ListNode pre = dummy; for(int i = 0; i&lt;m-1; i++) pre = pre.next; // a pointer to the beginning of a sub-list that will be reversed ListNode start = pre.next; // a pointer to a node that will be reversed ListNode then = start.next; // 1 - 2 -3 - 4 - 5 ; m=2; n =4 ---&gt; pre = 1, start = 2, then = 3 // dummy-&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 for(int i=0; i&lt;n-m; i++)&#123; start.next = then.next; then.next = pre.next; pre.next = then; then = start.next; &#125; // first reversing : dummy-&gt;1 - 3 - 2 - 4 - 5; pre = 1, start = 2, then = 4 // second reversing: dummy-&gt;1 - 4 - 3 - 2 - 5; pre = 1, start = 2, then = 5 (finish) return dummy.next;&#125; 92-代码分析首先，我们利用给的 M ，找出第M个元素的位置，并将 M-1 位置标记为 pre ，M 标记为 start ，M+1 位置标记为 then ，然后执行第二个循环。第二个循环的逻辑是交换节点，但是，我们并不是交换相邻的两个元素，而是将 then 换到 pre.next 的位置，这样才能达到翻转部分链表的目的： 循环找到第 M 个元素 第一次循环后 将 then 换到 pre.next 第二个循环执行一次 将then后移一个 后移 继续循环 第二个循环执行两次 为了达到这个目的，我们要声明三个指针 第一个指向最后一个不需要反转的节点（第 M-1 个节点），相当于要反转链表部分的 dummy ，它负责找到头。 第二个指向第 M 个节点，它将是反转链表部分的最后一个节点，它负责找到尾。 以上这两个指针不应该移动，因为他们类似于 dummy 一头一尾，可以确定翻转边界。 第三个指针循环中移动，来使链表翻转。它负责元素移动。 92-代码-2代码二：递归 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123; // Object level variables since we need the changes // to persist across recursive calls and Java is pass by value. private boolean stop; private ListNode left; public void recurseAndReverse(ListNode right, int m, int n) &#123; // base case. Don't proceed any further if (n == 1) &#123; return; &#125; // Keep moving the right pointer one step forward until (n == 1) right = right.next; // Keep moving left pointer to the right until we reach the proper node // from where the reversal is to start. if (m &gt; 1) &#123; this.left = this.left.next; &#125; // Recurse with m and n reduced. this.recurseAndReverse(right, m - 1, n - 1); // In case both the pointers cross each other or become equal, we // stop i.e. don't swap data any further. We are done reversing at this // point. if (this.left == right || right.next == this.left) &#123; this.stop = true; &#125; // Until the boolean stop is false, swap data between the two pointers if (!this.stop) &#123; int t = this.left.val; this.left.val = right.val; right.val = t; // Move left one step to the right. // The right pointer moves one step back via backtracking. this.left = this.left.next; &#125; &#125; public ListNode reverseBetween(ListNode head, int m, int n) &#123; this.left = head; this.stop = false; this.recurseAndReverse(head, m, n); return head; &#125;&#125; 92-代码-3代码三：代码复用这个方法是将部分链表翻转，转化为已知问题，也就是206转化一个完整链表问题。这样就可以将位置问题转化为已知问题，第二个循环完全是代码的复用。 1234567891011121314151617181920212223242526272829303132333435363738public ListNode reverseBetween(ListNode head, int m, int n) &#123; // Empty list if (head == null) &#123; return null; &#125; // Move the two pointers until they reach the proper starting point // in the list. ListNode cur = head, prev = null; while (m &gt; 1) &#123; prev = cur; cur = cur.next; m--; n--; &#125; // The two pointers that will fix the final connections. ListNode con = prev, tail = cur; // Iteratively reverse the nodes until n becomes 0. ListNode third = null; while (n &gt; 0) &#123; third = cur.next; cur.next = prev; prev = cur; cur = third; n--; &#125; // Adjust the final connections as explained in the algorithm if (con != null) &#123; con.next = prev; &#125; else &#123; head = prev; &#125; tail.next = cur; return head;&#125; 总结这次的讲的是链表的翻转，可以用的思路有 递归、回溯 循环插入 链表问题在面试中被提问的可能性很大，而且题目变化种类不多，希望每讲一个问题，每个方法都记住。 更多关于链表的问题更多关于链表的问题请转到链表标签","tags":[{"name":"链表","slug":"链表","permalink":"http://www.allenmistake.top/tags/链表/"}]},{"title":"3月总结 and 4月计划","date":"2019-03-31T02:22:13.000Z","path":"2019/03/31/monthlysummary/","text":"3月总结 and 4月计划3月已完成的工作汇总Leetcode截止到现在，Leetcode完成题目已经完成了56道，其中3月份完成了40+，个人对这个进度还是很满意的，我们这个月着重学习了一下几个比较大的知识点（按讲解类型从多到少排序） 回溯问题 + DFS 链表问题 + 双指针 树的遍历（递归与非递归） 字符串 String and StringBuffer 而以上只是总结出来的部分，还有一些觉得没有必要或者说不是很具有代表性，就被跳过。 JAVA关于Java的进展也是很快，完成了月初的计划，把并发多线程和虚拟机的部分都看完了，并做了总结，但是理解得还不够深入，还要反复去看总结笔记。关于原理性的概念，要反复看，不能急于求成。而且关于多线程的部分还要参照《Thinking in Java》来看，反复咀嚼。 其他工作这个月看了好几本书，但是没有看完，感觉非虚构类文学作品还是很难啃的，这种难啃并非像专业书籍那样，每句话在给你讲解原理，而是它一直在陈述一些事实，但是其背后的逻辑关系，需要你有一些历史、政治、地理知识才能看懂、看下去。看完的书 动物农场未看完的书 事实改变之后 病菌、枪炮和钢铁 感觉自己对于这种社会科学尤其涉及历史方面的书不是很能看得下去，还是要先把手头上的全球通史看完。。 总感觉英语不能落下太多，但又不知道怎么才能提高，这个事还是挺烦的，目前来讲，词汇量我觉得不是最大敌人，反而是发音和听力是两大难关，而且这两个在日常生活中是最常用的。 4月计划Busy in April四月是奔波忙碌的一个月份，各种假。所以留给学习的时间感觉会有所减少，不过还是应该坚持的。 四月计划 Leetcode 继续刷题，目标：40（总结与没总结加一起） 复习回溯与链表（再联系几道题） 下面的重点：哈希表、数组 Java 复习多线程部分（Thinking in Java） 查漏补缺（深浅拷贝、多种数据结构的具体特点与实现「日志上已有，注意更新不要新增」） Github项目 OneAccount 其他感悟说了那么多正经的，下面聊一点不是那么正式的。前两天看了《新喜剧之王》、重温了一下《飞驰人生》。 先说《新》吧，一开始过年的时候我是没有去看它的，因为宣传实在太 low 了，而且女主长得实在喜欢不起来，不过现在回头看，感觉还是有点意思的，王宝宝的搞笑实力还是有点。影片更多的还是对小人物的刻画，众人皆为咸鱼，如何翻身？片中的女主最后成为影后我觉得有点理想化，但是努力肯定还是有用的，在这个社会上不断挣扎吧，从中找到乐趣。 韩寒的电影我是每次都会去看的，这次他终于拍了完全关于赛车的电影，这次的飞驰人生是一个喜剧片，但是喜剧往往是有着悲剧内核的，张弛一行人的中年危机，呼应着片子最后的《奉献》，很是感触，不知道我们到了4、50岁会不会有这些疑问。对自我存在的价值发生怀疑，但是你我都是片中20多岁的林臻东，年轻真好，我们可以不考虑以后，只管往前冲。 剧照 就像片中两个人的对话“你就这么想赢么”“我不是想赢，我是不想输”这句话看似没什么区别，但是可以感受到中年人开始有了负担，他害怕失败，而我们，还可以失败。 以上，与诸君共勉。","tags":[]},{"title":"Leetcode日记：141&142.链表中的环","date":"2019-03-30T02:43:05.000Z","path":"2019/03/30/leetcode141-142/","text":"Leetcode日记：141&amp;142.链表中的环141题目：判断是否存在环Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Example 1: 123Input: head = [3,2,0,-4], pos = 1Output: trueExplanation: There is a cycle in the linked list, where tail connects to the second node. !(leetcode141-1.png) Example 2: 123Input: head = [1,2], pos = 0Output: trueExplanation: There is a cycle in the linked list, where tail connects to the first node. !(leetcode141-2.png) Example 3: 123Input: head = [1], pos = -1Output: falseExplanation: There is no cycle in the linked list. !(leetcode141-3.png) 141问题分析这道题意思很简单，判断输入的链表是否存在环。上次刚讲到快慢指针的应用问题，这次就遇到了链表中的环。那么如何将二者结合起来呢？ 其实答案很简单，快指针一下走两步，慢指针一下走一步，如果链表存在环，那么快慢指针一定会在环的某个位置相遇。 141代码12345678910111213141516public boolean hasCycle(ListNode head) &#123; ListNode slow = new ListNode(0); ListNode fast = new ListNode(0); slow.next = head; fast.next = head; if(head==null) return false; while(fast!=null&amp;&amp;fast.next!=null)&#123; //如果快慢指针相遇，说明存在环 if(slow==fast) return true; slow = slow.next; fast = fast.next.next; &#125; return false;&#125; 142题目：找出链表中环的起始位置Given a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Note: Do not modify the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1Output: tail connects to node index 1Explanation: There is a cycle in the linked list, where tail connects to the second node. !(leetcode141-1.png)Example 2: 123Input: head = [1,2], pos = 0Output: tail connects to node index 0Explanation: There is a cycle in the linked list, where tail connects to the first node. !(leetcode141-2.png)Example 3: 123Input: head = [1], pos = -1Output: no cycleExplanation: There is no cycle in the linked list. !(leetcode141-3.png) 142题目分析这道题在141的基础上多了一个找出环的初始位置，这个需要用到一个常识或者说小技巧，我们要知道。快慢指针相遇的位置和环起点的位置，以及链表头节点位置关系： 第一次碰撞点Pos到连接点Join的距离=头指针到连接点Join的距离，因此，分别从第一次碰撞点 Pos、头指针 head 开始走，相遇的那个点就是连接点。 circle 在环上相遇后，记录第一次相遇点为 Pos，连接点为 Join，假设头结点到连接点的长度为LenA，连接点到第一次相遇点的长度为x，环长为 R。第一次相遇时，slow 走的长度 S = LenA + x;第一次相遇时，fast 走的长度 2S = LenA + n*R + x;所以可以知道，LenA + x = n*R; LenA = n*R -x; 142代码123456789101112131415161718public ListNode detectCycle(ListNode head) &#123; ListNode slow = head; ListNode fast = head; while (fast!=null &amp;&amp; fast.next!=null)&#123; fast = fast.next.next; slow = slow.next; //相遇之后，从头节点出发 if (fast == slow)&#123; ListNode slow2 = head; while (slow2 != slow)&#123; slow = slow.next; slow2 = slow2.next; &#125; return slow; &#125; &#125; return null;&#125; 补充：求有环单链表的环长 在环上相遇后，记录第一次相遇点为Pos，之后指针slow继续每次走1步，fast每次走2步。在下次相遇的时候fast比slow正好又多走了一圈，也就是多走的距离等于环长。 circle 设从第一次相遇到第二次相遇，设slow走了len步，则fast走了 2*len 步，相遇时多走了一圈：环长 = 2*len-len。 更多关于链表的问题更多关于链表的问题请转到链表标签","tags":[{"name":"链表","slug":"链表","permalink":"http://www.allenmistake.top/tags/链表/"}]},{"title":"Leetcode日记：19&24.链表相关操作","date":"2019-03-28T11:41:06.000Z","path":"2019/03/28/leetcodelinkedlist/","text":"Leetcode日记：19&amp;24&amp;84.链表相关操作19.删除倒数第N个元素19题目Given a linked list, remove the n-th node from the end of list and return its head. Example: 123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. 19题目分析首先，题目要求删除链表中倒数第n个元素。其实很简单，我们只需要遍历一遍链表，知道链表的元素个数。再次遍历，找到length-n个元素就可以了。但是题目有进阶要求，能不能只遍历一次？ 答案是肯定的。请看下面代码： 19代码1234567891011121314151617public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode start = new ListNode(0); ListNode slow = start, fast = start; slow.next = head; //Move fast in front so that the gap between slow and fast becomes n for(int i=1; i&lt;=n+1; i++) &#123; fast = fast.next; &#125; //Move fast to the end, maintaining the gap while(fast != null) &#123; slow = slow.next; fast = fast.next; &#125; //Skip the desired node slow.next = slow.next.next; return start.next;&#125; 19代码分析这里用到了一个很巧妙的方法，我将它命名为“双指针分离法”，主要思想就是先让这两个指针岔开n个元素，然后两个指针同时向前步进。当前面的元素到最后时，后面那个元素刚好指向倒数第n个元素。算法示意图： 双指针分离法示意图 24.成对交换节点24题目Given a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list’s nodes, only nodes itself may be changed. Example: 1Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. 24题目分析结点交换，是链表中老生常谈的一个话题，看似简单，编写程序的时候，容易被节点绕晕，那么我们就看看这个程序时如何编写的吧！ 24代码12345678public ListNode swapPairs(ListNode head) &#123; if ((head == null)||(head.next == null)) return head; ListNode n = head.next; head.next = swapPairs(head.next.next); n.next = head; return n;&#125; 24代码分析这里采用了递归，是因为如果从前往后交换的话，前面一对链接的一定要是已经交换好的下一对，所以程序的运行顺序是先将最后的交换好，然后逐渐往回过渡。 成对交换 如图所示，每一层递归，我们都会创建new一个新节点，这个节点首先保存为head.next的信息，然后进行递归，递归返回输入链表的交换后的头节点，随后将返回的头节点设置为head.next。最后，将n.next指向head完成交换，此时原来的head.next完全被隔离，被系统回收。 这道题看似容易，实际上还是需要一番思考的。 82.删除链表重复元素II82题目Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Example 1: 12Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5Output: 1-&gt;2-&gt;5 Example 2: 12Input: 1-&gt;1-&gt;1-&gt;2-&gt;3Output: 2-&gt;3 82题目分析之前有一道题是保留一个重复元素，删除多余的，那道题比较简单，这道题的意图是：只要是重复的元素，都删除，一个不留。这就牵扯到，你要有两个指针，一个指针用于记录上一个不重复元素，另一个指针负责向前步进检测并删除重复元素。 82代码1234567891011121314151617181920public ListNode deleteDuplicates(ListNode head) &#123; if(head==null) return null; ListNode FakeHead=new ListNode(0); FakeHead.next=head; ListNode pre=FakeHead; ListNode cur=head; while(cur!=null)&#123; while(cur.next!=null&amp;&amp;cur.val==cur.next.val)&#123; cur=cur.next; &#125; if(pre.next==cur)&#123; pre=pre.next; &#125; else&#123; pre.next=cur.next; &#125; cur=cur.next; &#125; return FakeHead.next;&#125; 82代码分析从代码中我们可以看出，代码用了两个指针，第一个指针pre用来记录最后一个不重复的指针（这个指针一定不会被删除掉）。第二个指针cur用来记录当前位置，用它来判断是否该元素为重复元素(cur.next!=null&amp;&amp;cur.val==cur.next.val)，利用一个循环，直接找到下一个出现的不重复元素，这里有两种情况，一种是循环没有被执行（即cur为一个不重复元素），那么cur没有移动，我们让pre=pre.next，来更新最后一个不重复元素。如果是重复元素，则跨过cur，执行pre.next=cur.next。 链表问题总结链表问题在所有数据结构里面所示较为简单的一种。而且相对来说问题的变数比较少，我们着重关注以下几个问题 dummy哑节点 我们可以看到，上面题目中，第一题的 ListNode start = new ListNode(0); 最后一道题的 ListNode FakeHead=new ListNode(0); 都首先创建了一个新节点，这个结点的下一个往往是输入的头节点，为什么会这么设置呢？ 哑节点设置的主要原因： 避免头节点可能由于某种原因被删除等一系列问题而导致的边界问题，简化代码。 双指针设计 链表的很多问题用双指针都会降低一些时间复杂度。比如leetcode24等很多问题可以应用在很多场景中： 删除链表中元素 拆分链表 找出中点或中位数 寻找链表是否存在环 寻找范围 还有更多应用，但是思想都是不变的，指针一快一慢，具体快多少，看题目中具体要求。这便是著名的“快慢指针” 更多关于链表的问题更多关于链表的问题请转到链表标签","tags":[{"name":"链表","slug":"链表","permalink":"http://www.allenmistake.top/tags/链表/"}]},{"title":"Java日常学习总结JVM之垃圾收集器与内存分配策略","date":"2019-03-26T04:17:05.000Z","path":"2019/03/26/JVM1/","text":"JVM经典内存布局 内存布局这一块很重要，要着重看！（在JVM这本书里面有更详细的介绍） 方法区（公有）： 用户存储已被虚拟机加载的类信息，常量，静态常量，即时编译器编译后的代码等数据。 其中包含常量池：用户存放编译器生成的各种字面量和符号引用。 堆（公有）： 是JVM所管理的内存中最大的一块。唯一目的就是存放实例对象，几乎所有的对象实例都在这里分配。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。 堆分为两大块：新生代和老年代。 虚拟机栈（线程私有）： 描述的是java方法执行的内存模型：每个方法在执行时都会创建一个栈帧，用户存储局部变量表，操作数栈，动态连接，方法出口等信息。每一个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。对这个区域定义了两种异常状态OutOfMemoryError、StackOverflowError 本地方法栈（线程私有）: 与虚拟机栈所发挥的作用相似。它们之间的区别不过是虚拟机栈为虚拟机执行java方法，而本地方法栈为虚拟机使用到的Native方法服务。 程序计数器（线程私有）： 一块较小的内存，当前线程所执行的字节码的行号指示器。字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。 Java内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。 对象已死？引用计数器主流的JVM里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象间的互循环引用的问题。 可达性分析算法在Java语言中，可以作为GC Roots的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象； 方法区中类静态属性引用的对象； 方法区中常量引用的对象； 本地方法栈中JNI（即一般说的Native方法）引用的对象； 在可达性分析算法中，要真正宣告一个对象死亡，至少要经历两次标记过程： 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()，或者finalize()已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。 如果这个对象被判定为有必要执行finalize()，那么这个对象将会放置在一个叫做F-Queue队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。finalize()是对象逃脱死亡命运的最后一次机会，稍候GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalie()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将会被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。 注意：Java并不推荐使用finalize()函数，Java中这个表示建议回收，实际开发者并不能掌握到底什么时候JVM才会回收这部分内存，这和c++的析构不一样，运行代价高昂、不确定性大。 引用再划分 强引用 特点：我们平常典型编码Object obj = new Object()中的 obj 就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM 宁愿抛出 OutOfMemoryError 运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。 软引用 特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用 ReferenceQueue 的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个 null ,否则该方法返回队列中前面的一个 Reference 对象。 应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。 弱引用 特点：弱引用通过 WeakReference 类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 应用场景：弱应用同样可用于内存敏感的缓存。 虚引用 特点：虚引用也叫幻象引用，通过 PhantomReference 类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 ﬁnalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 12ReferenceQueue queue = new ReferenceQueue ();PhantomReference pr = new PhantomReference (object, queue); 程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。 应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。 垃圾回收算法标记-清除算法最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段。 首先标记出所有需要回收的对象 在标记完成后统一回收所有被标记的对象。不足：效率问题：标记和清除两个过程的效率都不高空间问题：标记清除之后产生大量不连续的内存碎片，空间碎片太多可能会导致以后程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 复制算法目的：为了解决效率问题。将可用内存按容量大小划分为大小相等的两块，每次只使用其中的一块。当一块内存使用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况。缺点：将内存缩小为了原来的一半。 标记-整理算法复制收集算法在对象存活率较高时，就要进行较多的复制操作，效率就会变低。根据老年代的特点，提出了“标记-整理”算法。标记过程仍然与”标记-清除“算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。 分代收集算法一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法。在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须采用“标记-清除”或“标记-整理”算法来进行回收。 垃圾回收机制知识点JVM中的年代JVM中分为年轻代（Young generation）和老年代(Tenured generation)。HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。 JVM年代内存图 一般情况下，新创建的对象都会被分配到 Eden 区(注意1：一些大对象特殊处理)，这些对象经过第一次Minor GC后，如果仍然存活，将会被移到 Survivor 区。对象在 Survivor 区中每熬过一次 Minor GC ，年龄就会增加 1 岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。 在 GC 开始的时候，对象只会存在于Eden区和名为“From”的 Survivor 区，Survivor 区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过 -XX:MaxTenuringThreshold 来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次 GC 前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。 ![对象分配与简要GC流程图] 注意1：所谓大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是很长的字符串以及数组。 不同年代的GC新生代GC(Minor GC):指发生在新生代的垃圾收集动作，该动作非常频繁。老年代GC(Full GC/Major GC):指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC。Major GC的速度一般会比Minor GC慢10倍以上。 空间分配担保在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则将尝试进行一次Minor GC，尽管这个 Minor GC 是有风险的。如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次Full GC。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.allenmistake.top/tags/JVM/"}]},{"title":"Leetcode日记：94&144&145.前序、中序、后序遍历二叉树树（递归与非递归）","date":"2019-03-24T03:04:53.000Z","path":"2019/03/24/leetcodetreetraversal/","text":"Leetcode日记：94&amp;144&amp;145.前序、中序、后序遍历二叉树（递归与非递归）问题介绍这个不用多说，就是对二叉树的遍历，只用前序遍历举个例子。 12345678Input: [1,null,2,3] 1 \\ 2 / 3Output: [1,3,2] 基本就是按照遍历顺序打印结点。 递归解决方案递归前序12345678public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; pre = new LinkedList&lt;Integer&gt;(); if(root==null) return pre; pre.add(root.val); pre.addAll(preorderTraversal(root.left)); pre.addAll(preorderTraversal(root.right)); return pre;&#125; 递归中序12345678910111213141516171819public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); // method 1: recursion helper(root, res); return res; //helper function for method 1 private void helper(TreeNode root, List&lt;Integer&gt; res) &#123; if (root != null) &#123; if (root.left != null) &#123; helper(root.left, res); &#125; res.add(root.val); if (root.right != null) &#123; helper(root.right, res); &#125; &#125; &#125; 递归后序12345678910111213public List&lt;Integer&gt; postorderTraversal1(TreeNode root) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); dfs(root, ret); return ret;&#125;private void dfs(TreeNode root, List&lt;Integer&gt; ret) &#123; if (root != null) &#123; dfs(root.left, ret); dfs(root.right, ret); ret.add(root.val); &#125;&#125; 递归总结其实就是打印语句或者说要求的操作摆放位置： 前序：先执行操作，再访问左，再访问右 中序：先访问左，再执行操作，再访问右 后序：先访问左，再访问右，最后执行操作 非递归（利用栈）非递归前序12345678910111213141516public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); TreeNode p = root; while(!stack.isEmpty() || p != null) &#123; if(p != null) &#123; stack.push(p); result.add(p.val); // Add before going to children p = p.left; &#125; else &#123; TreeNode node = stack.pop(); p = node.right; &#125; &#125; return result;&#125; 非递归中序12345678910111213141516public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); TreeNode p = root; while(!stack.isEmpty() || p != null) &#123; if(p != null) &#123; stack.push(p); p = p.left; &#125; else &#123; TreeNode node = stack.pop(); result.add(node.val); // Add after all left children p = node.right; &#125; &#125; return result;&#125; 我们用中序遍历来做个图示：首先我们假定给定的树如下 二叉树遍历 随后，代码用到了栈的数据结构，利用栈的性质来按顺序压栈出栈每一个结点。 栈 结果 可以看出，主要思路是只要节点不为空，就压栈，当节点为空时，弹出当前栈顶端元素，然后访问其右节点。顺序的改变在于操作位于压栈还是弹栈，前序遍历是先进行操作（打印），再访问左元素。 非递归后序12345678910111213141516public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; LinkedList&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); TreeNode p = root; while(!stack.isEmpty() || p != null) &#123; if(p != null) &#123; stack.push(p); result.addFirst(p.val); // Reverse the process of preorder p = p.right; // Reverse the process of preorder &#125; else &#123; TreeNode node = stack.pop(); p = node.left; // Reverse the process of preorder &#125; &#125; return result;&#125; 这里的后序遍历利用了一个很巧妙的转换，把它看作一个对于右子树的先序遍历，然后反转result。具体实现方式即，优先访问右节点p = p.right，访问到的每个不为空的节点压入栈，当访问节点为空时，弹出栈的顶端元素。再访问其左节点。 总结树的遍历问题是非常基础的问题，这个要牢记，无论是递归还是非递归，之后做其他类的题目会很有帮助。","tags":[{"name":"树","slug":"树","permalink":"http://www.allenmistake.top/tags/树/"}]},{"title":"Leetcode日记：15&16.三数之和","date":"2019-03-23T05:54:21.000Z","path":"2019/03/23/leetcode15-16/","text":"Leetcode日记：15&amp;16.三数之和题目15：三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 分析这道题让我们求三数之和，比之前那道Two Sum要复杂一些，博主考虑过先fix一个数，然后另外两个数使用Two Sum那种HashMap的解法，但是会有重复结果出现，就算使用set来去除重复也不行，会TLE，看来此题并不是考我们Two Sum的解法。那么我们来分析一下这道题的特点，要我们找出三个数且和为0，那么除了三个数全是0的情况之外，肯定会有负数和正数，我们还是要先fix一个数，然后去找另外两个数，我们只要找到两个数且和为第一个fix数的相反数就行了，既然另外两个数不能使用Two Sum的那种解法来找，如果能更有效的定位呢？我们肯定不希望遍历所有两个数的组合吧，所以如果数组是有序的，那么我们就可以用双指针以线性时间复杂度来遍历所有满足题意的两个数组合。 我们对原数组进行排序，然后开始遍历排序后的数组，这里注意不是遍历到最后一个停止，而是到倒数第三个就可以了。这里我们可以先做个剪枝优化，就是当遍历到正数的时候就break，为啥呢，因为我们的数组现在是有序的了，如果第一个要fix的数就是正数了，那么后面的数字就都是正数，就永远不会出现和为0的情况了。然后我们还要加上重复就跳过的处理，处理方法是从第二个数开始，如果和前面的数字相等，就跳过，因为我们不想把相同的数字fix两次。对于遍历到的数，用0减去这个fix的数得到一个target，然后只需要再之后找到两个数之和等于target即可。我们用两个指针分别指向fix数字之后开始的数组首尾两个数，如果两个数和正好为target，则将这两个数和fix的数一起存入结果中。然后就是跳过重复数字的步骤了，两个指针都需要检测重复数字。如果两数之和小于target，则我们将左边那个指针i右移一位，使得指向的数字增大一些。同理，如果两数之和大于target，则我们将右边那个指针j左移一位，使得指向的数字减小一些，代码如下： 15代码12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; nums.length-2; i++) &#123; if (i == 0 || (i &gt; 0 &amp;&amp; nums[i] != nums[i-1])) &#123;//防止重复元素计入 int lo = i+1, hi = nums.length-1, sum = 0 - nums[i]; while (lo &lt; hi) &#123; if (nums[lo] + nums[hi] == sum) &#123; res.add(Arrays.asList(nums[i], nums[lo], nums[hi])); while (lo &lt; hi &amp;&amp; nums[lo] == nums[lo+1]) lo++; while (lo &lt; hi &amp;&amp; nums[hi] == nums[hi-1]) hi--; lo++; hi--; &#125; else if (nums[lo] + nums[hi] &lt; sum) lo++; else hi--; &#125; &#125; &#125; return res;&#125; 题目16：最接近的三数之和Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: 123Given array nums = [-1, 2, 1, -4], and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 类似的思想类似于3求和问题，使用3个指针指向当前元素、下一个元素和最后一个元素。如果总和小于目标值，这意味着我们必须添加一个更大的元素，这样下一个元素就会移到下一个。如果总和更大，这意味着我们必须添加一个更小的元素，所以最后一个元素移到第二个最后一个元素。一直坚持到最后。每次比较总和和目标之间的差异，如果到目前为止它小于最小差异，那么用它替换结果，否则继续迭代。 16代码12345678910111213141516171819public int threeSumClosest(int[] num, int target) &#123; int result = num[0] + num[1] + num[num.length - 1]; Arrays.sort(num); for (int i = 0; i &lt; num.length - 2; i++) &#123; int start = i + 1, end = num.length - 1; while (start &lt; end) &#123; int sum = num[i] + num[start] + num[end]; if (sum &gt; target) &#123; end--;//最后一个元素向前移动一位 &#125; else &#123; start++;//下一个元素向后移动 &#125; if (Math.abs(sum - target) &lt; Math.abs(result - target)) &#123; result = sum; &#125; &#125; &#125; return result;&#125; 个人总结当涉及到给定乱序数组，要求在其中按照要求找到所需内容时，我们先想排序能不能简化问题，如果能，我们选用库自带函数sort()，这道题一开始我尝试用最暴力的解法，但是O(N^3)的时间复杂度实在是太高了，会TLE，那么我们能不能同时引导两个指针的移动呢，但是可以的，这样虽然只会线性增长，不会指数增长。 核心思想，一个数组，三个指针，一个从第一个开始可以称之为根（root），移动到最后（倒数第三个），另外两个，一个指向最大元素（end），另一个指向第一个指针的后面的元素（start）","tags":[{"name":"数组","slug":"数组","permalink":"http://www.allenmistake.top/tags/数组/"}]},{"title":"Leetcode日记：114.展平一个二叉树","date":"2019-03-20T12:48:30.000Z","path":"2019/03/20/leetcode114/","text":"Leetcode日记：114.展平一个二叉树题目Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 12345 1 / \\ 2 5 / \\ \\3 4 6 The flattened tree should look like: 12345678910111 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 题目分析这道题我刚拿到手里是一脸懵逼的，这怎么做啊。直到看见官方提示： 12If you notice carefully in the flattened tree, each node&apos;s right child points to the next node of a pre-order traversal.如果仔细观察展开后的树，每个节点的右子节点指向一个先序遍历的下一个节点。 这意味着，我们需要有先序遍历的思路 代码一般思路代码123456789101112131415 public class Solution &#123; public void flatten(TreeNode root) &#123; if(root==null) return; flatten(root.left); flatten(root.right); TreeNode left = root.left; TreeNode right = root.right; root.left = null; root.right = left; while(root.right!=null) root = root.right; root.right = right; &#125;&#125; 超简洁版代码123456789101112public class Solution &#123; private TreeNode prev = null; public void flatten(TreeNode root) &#123; if (root == null) return; flatten(root.right); flatten(root.left); root.right = prev; root.left = null; prev = root; &#125;&#125; 解题思路代码1解析很明显的DFS思想，假设原来的树是： 1234567 1 1 / \\ / \\ 2 5 2 5 / \\ \\ \\ \\3 4 6 3 6 \\ 4 然后，进入第一次flatten(root.left);，这时，首先创建两个新节点left和right，分别把当前左节点和右节点赋给他们，防止覆盖，然后直接令当前左节点为null，当前右节点换成左节点，随后顺着右面的岔路一直向右，在右路的尽头添加右节点。变成下面的样子： 其实我们看上去5和6直接是相连的，但是我们在程序上仍然对他们两个进行了排序，只不过排序之前和排序之后是一样的。所以接下来直接执行最后一条，这样我们可以看出来，我们已经把下面所有的树都已经排好序（展开），只差最上面一层了 所以代码1的思路是先利用DFS的思路找到最左子节点，然后回到其父节点，把其父节点和右子节点断开，将原左子结点连上父节点的右子节点上，然后再把原右子节点连到新右子节点的右子节点上，然后再回到上一父节点做相同操作。 更加优雅的代码2有没有发现，代码2是从右面开始DFS的？这就是他优雅的所在，因为他遍历的是右面，导致省了一个循环。这个循环本是应该正向搜索时寻找右节点的放置位置。 123root.right = prev;root.left = null;prev = root; 这几行代码保证了将最右的节点永远是他前面节点的右节点。 具体流程是这样的： 1234567 1 1 / \\ / \\ 2 5 2 5 / \\ \\ \\ \\3 4 6 3 6 \\ 4 总结这道题在没有前序遍历，后序遍历，中序遍历树的知识前遇见是挺难受的，一直不想面对树这个数据结构，有点阴影，但是没有办法，回溯到DFS都和树这个结构有着很大的联系，下面可能要学习一下遍历的知识了。等到学完，再更新补全。","tags":[{"name":"DFS","slug":"DFS","permalink":"http://www.allenmistake.top/tags/DFS/"},{"name":"树","slug":"树","permalink":"http://www.allenmistake.top/tags/树/"},{"name":"遍历","slug":"遍历","permalink":"http://www.allenmistake.top/tags/遍历/"}]},{"title":"Leetcode日记：112&113.路径之和与DFSvs回溯","date":"2019-03-19T11:59:40.000Z","path":"2019/03/19/leetcode112-113/","text":"Leetcode日记：112&amp;113.路径之和与DFSvs回溯 路径走到头，深度搜索优。路径回头走，回溯其中由 112路径之和I112问题Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 1234567 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\7 2 1 return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. 112问题分析Leetcode上有很多关于树的问题，而关于树的问题很多需要DFS，这个我们下面会详细讲到，总之问题很明确，判断这个树有没有一条从头到尾的路径，这条路径上所有元素之和等于目标值。 112代码下面是我写的复杂版，还要多出一个全局变量，明显可改进。 1234567891011121314151617181920class Solution &#123; boolean isFirst = true; public boolean hasPathSum(TreeNode root, int sum) &#123; if(root==null)&#123; return false; &#125; if(root.left==null&amp;&amp;root.right==null)&#123; if(root.val==sum) return true; else return false; &#125; if(root.left==null)&#123; return hasPathSum(root.right, sum - oot.val); &#125; if(root.right==null) return hasPathSum(root.left, sum - root.val); return hasPathSum(root.left, sum - root.val)||hasPathSum(root.right, sum - root.val); &#125;&#125; 下面是大神给出的简洁方案 123456789public class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; if(root == null) return false; if(root.left == null &amp;&amp; root.right == null &amp;&amp; sum - root.val == 0) return true; return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); &#125;&#125; 113路径之和II113问题Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 1234567 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\7 2 5 1 Return: 1234[ [5,4,11,2], [5,8,4,5]] 113问题分析和112差不多，但是这次让我们找出所有符合要求的路径 113代码123456789101112131415161718192021222324class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; result = new LinkedList(); List&lt;Integer&gt; sub = new LinkedList(); backtrack(result, sub, root, sum); return result; &#125; private void backtrack(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; sub, TreeNode root, int sum) &#123; if (root == null) &#123; return; &#125; sub.add(root.val); if (root.left == null &amp;&amp; root.right == null) &#123; if (root.val == sum) &#123; result.add(new LinkedList(sub)); &#125; sub.remove(sub.size() - 1); return; &#125; backtrack(result, sub, root.left, sum - root.val); backtrack(result, sub, root.right, sum - root.val); sub.remove(sub.size() - 1); &#125;&#125; DFSvs回溯DFS还是回溯？第一道题，仔细分析他的算法流程，就会发现，他和之前我们介绍过的回溯一样，先一路走到黑，走不动了，就返回上一个路口，走另一条路。而有趣的是，第二道题的代码，看着熟不熟悉，对，他的代码形式像极了之前的回溯。 那么说了那么半天，什么是DFS？ DFS，Depth first search，即深度优先遍历（或者说深度优先搜索），当我们学习完回溯再回过头来卡看DFS时，发现他俩极其类似。 区别在于：DFS从不剪枝。 具体地说，回溯可以看作一种更通用的DFS，在某些情况下，可以放弃一些路径的深度遍历；而对于DFS而言，对于它适用的数据结构树和图来讲，都是需要从头遍历到尾的，不能有一丝遗漏，这便是这二者之间的区别。 问题分析之所以这两道题的标签是DFS， 是因为这道题说的是从头到尾的路径，既然是从头到尾，肯定不能有一丝遗漏。我们只需要在迭代中判断结点是否已经到低就可以，对于112，如果是则判断路径之和符不符合，如果没到底继续迭代；对于113，如果已经到底则判断路径之和符不符合，如果符合，将得到的数组添加到已有库中，如果不符合回退数组，如果没到底，则继续迭代。 更多DFS算法更多关于DFS算法的问题请转到回溯算法标签","tags":[{"name":"DFS","slug":"DFS","permalink":"http://www.allenmistake.top/tags/DFS/"}]},{"title":"Leetcode日记：77.组合","date":"2019-03-17T12:11:35.000Z","path":"2019/03/17/leetcodedaily77/","text":"Leetcode日记：77.组合，回溯问题的优化问题Given two integers n and k, return all possible combinations of k numbers out of 1 … n. Example: 12345678910Input: n = 4, k = 2Output:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 问题分析给定一个数字n，给定一个数量k，求1-n中k个数的组合。标准的回溯问题，下面直接看代码，这道题是让我们看看如何优化回溯问题的代码。 个人答案123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); backtrack(list, new ArrayList&lt;&gt;(), n, k, 1); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, int n,int k, int start)&#123; if(tempList.size()==k)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = start; i &lt;=n ;i++)&#123; tempList.add(i); backtrack(list, tempList, n,k, i + 1); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; 思路和之前的回溯都是一样的，效果是运行时间42ms，算是相当慢的了，那么如何进行优化呢，下面来看一下大神给的方法。 优化方法12345678910111213141516public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;List&lt;Integer&gt;&gt; list = new LinkedList&lt;&gt;(); backtrack(list,n,k,1,new ArrayList&lt;Integer&gt;()); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, int n, int k, int start, List&lt;Integer&gt; tempList)&#123; if(k==0) &#123; list.add(new LinkedList&lt;&gt;(tempList)); return; &#125; for(int i = start;i&lt;=n-k+1;i++)&#123; tempList.add(i); backtrack(list,n,k-1,i+1,tempList); tempList.remove(tempList.size()-1); &#125;&#125; 社区大神给出的解决方法与我的很类似，毕竟都是经典回溯代码，差不太多，那么，优化后的方法耗时多长时间呢？ 答案是2ms 足以见得优化的重要性，当我们编写leetcode时候，不仅要关注算法的准确，对于算法的复杂度、内存的分析优化往往更能提高我们的编程技巧，对以后的发展会很有帮助。 废话不多说，我们来看一下42ms和2ms在思路代码上的区别： 优化分析主要区别在于进行迭代的时候，每次递归我的方法传入的是k个数，其实我们知道，当进行一次递归后，我们只需要添加k-1个数就好，因为在这之前必定有一个数已经被添加，而我并没有考虑到这一优化情况。我的循环会在数组tempList已满后继续进行迭代，但是这些情况下的迭代都会检测到已满之后立即返回，耗费大量时间。 优化关键代码： 循环中的i&lt;=n-k+1判断条件 迭代中随着迭代层数不断变换带入的k-1 归纳起来，便是一点：当进行递归深入时，确定好进行迭代的量，判断好哪些变量需要根据递归深度增加而变化，避免循环固定化、冗余化。 更多回溯算法更多关于回溯算法的问题请转到回溯算法标签","tags":[{"name":"回溯","slug":"回溯","permalink":"http://www.allenmistake.top/tags/回溯/"}]},{"title":"Leetcode日记：51&52.N皇后问题","date":"2019-03-16T02:31:17.000Z","path":"2019/03/16/leetcode51-52/","text":"Leetcode日记：51&amp;52.N皇后问题题目The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. 八皇后问题的一个解法 Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively. Example: 12345678910111213Input: 4Output: [ [&quot;.Q..&quot;, // Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]]Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above. 题目分析这就是这次回溯问题的最终难题————经典的八皇后问题，题目主要的要求就是在摆N个皇后之后，皇后之间不能相互碰到。这也要求我们利用回溯思想解决问题，当然不用回溯也是可以的，但是回溯的精妙之处在于其简洁，明了。让我们看看代码是如何实现的吧。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; boolean[] visited = new boolean[n]; //2*n-1个斜对角线 boolean[] dia1 = new boolean[2*n-1]; boolean[] dia2 = new boolean[2*n-1]; fun(n, new ArrayList&lt;String&gt;(),visited,dia1,dia2,0); return result; &#125; private void fun(int n,List&lt;String&gt; list,boolean[] visited,boolean[] dia1,boolean[] dia2,int rowIndex)&#123; if(rowIndex == n)&#123; result.add(new ArrayList&lt;String&gt;(list)); return; &#125; for(int i=0;i&lt;n;i++)&#123; //这一行、正对角线、反对角线都不能再放了，如果发现是true，停止本次循环 if(visited[i] || dia1[rowIndex+i] || dia2[rowIndex-i+n-1]) continue; //init一个长度为n的一维数组，里面初始化为'.' char[] charArray = new char[n]; Arrays.fill(charArray,'.'); charArray[i] = 'Q'; String stringArray = new String(charArray); list.add(stringArray); visited[i] = true; dia1[rowIndex+i] = true; dia2[rowIndex-i+n-1] = true; fun(n,list,visited,dia1,dia2,rowIndex+1); //reset 不影响回溯的下个目标 list.remove(list.size()-1); charArray[i] = '.'; visited[i] = false; dia1[rowIndex+i] = false; dia2[rowIndex-i+n-1] = false; &#125; &#125; &#125; 代码分析回溯思想这道题的回溯思想和之前我们两道题基本一致，并没有过于难的地方： 结构：： 递归（迭代）：这道题本身就是DFS问题，首先从第一行第一个开始，试着放一个皇后，接下来把相关信息放入，继续迭代(层数加一，rowIndex+1)，当发现满足条件时存入数组并返回。 条件：当放入的皇后数量等于目标数便可存入，当无解后会自动结束。在每一次布局时，共同维护着三个Boolean数组，来判断是否皇后会打架。（详细见下文） 结束：当一次迭代执行完毕之后，不管这个方法成功与否，都把当前得到的排布的最后一行删掉list.remove(list.size()-1)，并初始化这一行，并且还原Boolean数组，重新安排这一行的下一种布局（回溯）。 关于打架的判断上文提到，每一次布局都会有与之对应的三个Boolean数组，这个数组便是检测在这一列、副对角线，主对角线上的皇后是否产生打架，这个规则不容易想，首先，我们以数组的形式来模拟棋盘： 12345[0,0][0,1][0,2][0,3][0,4][1,0][1,1][1,2][1,3][1,4][2,0][2,1][2,2][2,3][2,4][3,0][3,1][3,2][3,3][3,4][4,0][4,1][4,2][4,3][4,4] 我们来找一下：visited[i] 是与之对应的列，这个很显然。dia1[rowIndex+i]说的是副对角线，可以观察到副对角线上，行（rowIndex）与列（i）之和是一样的。dia2[rowIndex-i+n-1]说的是副对角线，仔细观察发现主对角线上，行（rowIndex）与列（i）之差是一样的，但是为了避免出现数组索引为负数的情况，代码特意在后面+n-1。 关于回溯时的状态重置回溯状态重置这个问题已经是老生常谈了，但是仍然要引起重视，这是很容易遗漏的一点。 首先，回溯之前，要把之前迭代的不符合要求或者已经存入的上一层内容清空重置（谨记只是上一层内容），反映到此题上就是 12list.remove(list.size()-1);charArray[i] = '.'; 相比之前几道题已经讲过很多次了。 还有就是要把判断状态表重置，反映在此题就是 123visited[i] = false;dia1[rowIndex+i] = false;dia2[rowIndex-i+n-1] = false; 52题简要说明这道题比第一个简单很多，只要求输出有多少种摆法。只需要在原看来代码的基础上删去不必要的List&lt;List&lt;String&gt;&gt; result，然后添加一个int型变量，得到满足条件的结果就+1就可以了。 更多回溯算法更多关于回溯算法的问题请转到回溯算法标签","tags":[{"name":"回溯","slug":"回溯","permalink":"http://www.allenmistake.top/tags/回溯/"}]},{"title":"Java日常学习总结并发进阶之volatile与Java内核","date":"2019-03-15T14:04:41.000Z","path":"2019/03/15/javadailyplus3/","text":"volatile关键词(2019-7-15更新)内存模型JMMJava内存模型(JMM)规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，每个线程创建时 JVM 都会为其创建一个工作内存（有些地方称之为栈空间）。线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回到主内存。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。 JMM关于同步的规定： 线程解锁前，必须把共享变量的值刷回主内存 线程加锁前，必须读取主内存的最新值到自己的工作内存 加锁解锁是同一把锁 在多线程中，执行下面这个语句 1i = 10; 顺序是执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。 这便造成在多个线程执行这句话的时候，一个线程执行之后，还未把结果写入主内存，而其他线程就已经从内存中读取，从而产生“脏读”。 如何解决这个问题，我们就要谈到并发编程的三大概念：原子性，有序性，可见性。 原子性 定义 即一个操作或者多个操作，要么全部执行，并且执行的过程不会被任何因素打断，要么就都不执行。 Java中的原子性 在 Java 中，对基本数据类型的变量的读取和赋值操作是原子性操作。下面举个例子深入理解： 1234x = 10; //语句1y = x; //语句2x++; //语句3x = x + 1; //语句4 这四句只有语句1具有原子性。 语句 1 是直接将数值 10 赋值给 x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。 语句 2 实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及将x的值写入工作内存，这2个操作都是原子性操作，但是合起来就不是原子性操作了。 同样的，x++ 和 x = x+1 包括3个操作：读取 x 的值，进行加1操作，写入新的值。 可见性 定义 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 Java中的可见性 对于可见性，Java 提供了 volatile 关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 有序性 指令重排序 一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。 重排序对单线程没有任何影响，但是对于多线程来说，会影响执行的正确性。 Java中有序性 可以通过 volatile 关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。 另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。 ①程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作 ②锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作 ③volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作 ④传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C 注意，这里的第一条只是保证了单线程的正确性，多线程并不能保证。 第三条规则是一条比较重要的规则。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。 深入理解volatile一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 但是volatile不能保证原子性因为volatile只是让变量每次读取到的都是最新的值，但是至于赋值，写入内存、后面的操作仍不能保证是原子性，解决的办法还是synchronized或者lock。 volatile保证有序性volatile关键字禁止指令重排序有两层意思： 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 在进行指令优化时，不能将在对volatile变量的读操作或者写操作的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 实现原理如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。 应用场景synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件： 对变量的写操作不依赖于当前值 该变量没有包含在具有其他变量的不变式中 梳理总结 保证可见性 不保证原子性 禁止指令重排 多线程更多关于Java并发多线程请点击Java进阶学习多线程","tags":[{"name":"多线程","slug":"多线程","permalink":"http://www.allenmistake.top/tags/多线程/"}]},{"title":"Leetcode日记：78&90.子集","date":"2019-03-13T11:02:43.000Z","path":"2019/03/13/leetcode78-90/","text":"Leetcode日记：78&amp;90.子集78.子集问题1Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: 123456789101112Input: nums = [1,2,3]Output:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 代码1123456789101112131415public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; 90.有重复子集问题2Given a collection of integers that might contain duplicates nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: 12345678910Input: [1,2,2]Output:[ [2], [1], [1,2,2], [2,2], [1,2], []] 代码212345678910111213141516public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, 0); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, int start)&#123; list.add(new ArrayList&lt;&gt;(tempList)); for(int i = start; i &lt; nums.length; i++)&#123; if(i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue; // skip duplicates tempList.add(nums[i]); backtrack(list, tempList, nums, i + 1); tempList.remove(tempList.size() - 1); &#125;&#125; 分析树状图 算法流程树状图 回溯算法 思路 这道题也是一个很明显的穷举类型的题目，搜索空间可以用树表示，而且可以采用递归，所以我们决定采用回溯算法。 结构 条件：数组从第一个元素读到最后一个元素 迭代：一个元素放好之后递归继续进行迭代，过程如树状图所示 结束：当读到最后一个元素，说明之前所有子集已收集完毕。 关于重复元素，判断语句多了一个start &amp;&amp; nums[i] == nums[i-1]因为是子集问题，不用像考虑排列组合那样，这道题直接将重复元素略过就可以了。 更多回溯算法更多关于回溯算法的问题请转到回溯算法标签","tags":[{"name":"回溯","slug":"回溯","permalink":"http://www.allenmistake.top/tags/回溯/"}]},{"title":"Leetcode日记：46&47.排列组合与回溯（backtrack）","date":"2019-03-12T08:38:45.000Z","path":"2019/03/12/leetcode46-47/","text":"回溯与迷宫 46排列组合1题目Given a collection of distinct integers, return all possible permutations. Example: 12345678910Input: [1,2,3]Output:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 分析这道题目的很明确，就是要求出数组所有排列组合情况，重点是不重复的数字，也就是说我们并不用考虑重复排列的情况 代码112345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // Arrays.sort(nums); // not necessary backtrack(list, new ArrayList&lt;&gt;(), nums); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(tempList.contains(nums[i])) continue; // element already exists, skip tempList.add(nums[i]); backtrack(list, tempList, nums); tempList.remove(tempList.size() - 1); &#125; &#125;&#125; 47排列组合2问题Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example: 1234567Input: [1,1,2]Output:[ [1,1,2], [1,2,1], [2,1,1]] 代码2123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); backtrack(list, new ArrayList&lt;&gt;(), nums, new boolean[nums.length]); return list;&#125;private void backtrack(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, int [] nums, boolean [] used)&#123; if(tempList.size() == nums.length)&#123; list.add(new ArrayList&lt;&gt;(tempList)); &#125; else&#123; for(int i = 0; i &lt; nums.length; i++)&#123; if(used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i - 1]) continue; used[i] = true; tempList.add(nums[i]); backtrack(list, tempList, nums, used); used[i] = false; tempList.remove(tempList.size() - 1); &#125; &#125;&#125; 回溯算法步骤用回溯算法解决问题的一般步骤： 针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。 确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。 以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。 基本思想回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。比如走迷宫问题，就是这条路走不通，然后返回前一个路口，继续下一条路。回溯算法说白了就是穷举法。不过回溯算法使用剪枝函数，剪去一些不可能到达 最终状态（即答案状态）的节点，从而减少状态空间树节点的生成。 回溯与动态规划这道题让我想起之前的爬楼问题，都是一个问题由一个或者几个子问题构成，不断划分他们之间的区别在于：动态规划往往是寻找一个最优解，而回溯问题则是穷举，深度遍历所有情况，当然也存在不符合要求的情况，但是仍然要遍历到相应的节点上。 适用情况 穷举问题，例如在某个范围内求所有可能情况 搜索空间均可以表示成树的样子 用回溯思想解决问题回到问题排列组合1首先，我们来看，这是一种不需要剪枝的问题，得到的所有解一定唯一，那我们看一看程序是怎么实现回溯的： 图示: 回溯算法 首先明确回溯是一个递归性质的问题，这道题模型是传一个待排列数组和原数组。 从0位置依次加入待排列数组，由于每次递归都要从0位置开始判断，所以传入之后要先判断这个数组是否已经出现过这个位置上的数，如果不曾出现，把这个数加入到数组中，再次递归。 直到依照这个方法将数组填满(tempList.size() == nums.length)，把这样计算出来的数组加入到结果中。这样其中的一个分枝就完成了。 完成之后自然进行回溯(跳出该层递归)，寻找下个排列组合。 排列组合2这个问题和上面区别不是很大，首先关键点是先用sort函数将数组排序，使重复的元素都放在一起，下面主要说一下剪枝判断的设计首先，用used[i]布尔型数组来判断是否该元素是否已经被排列组合过。判断语句if(used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i - 1]) 前一个used[i]相当与问题1中的判断，即当前待排列数组中是否包含了其本身（这种情况并不是重复，而是其本身）； 后面i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i - 1])其实想表明的意思是该元素与前面的元素重复，并且等于这个值的元素已被排列好； 这两种情况便可跳过排列组合，也就是剪枝 注意的问题1tempList.remove(tempList.size() - 1); 注意这个语句，由于我们待排列数组只有一个，我们不断更新，加入的标志是已满，如果得到第一种满足条件的情况直接返回，那么这个排列数组一直保持满的状态，不在会被更新，所以回溯的时候要注意，把带排列数组元素-1，才能有新排列组合情况进来。其他问题也同样，如果维持的是同一个数据结构，注意回溯的时候回退数据结构中的内容。 总结讲了那么多，我们需要注意回溯的几个关键要素 迭代 回溯问题体现在程序设计上大多数是递归，而每一层递归又会有一个循环来遍历这层递归的所有情况 条件 对于每个特定的解的某一步，他必然要符合某个解要求符合的条件，如果不符合条件，就要回溯，其实回溯也就是递归调用的返回。 结束 当到达一个特定结束条件时候，就认为这个一步步构建的解是符合要求的解了。把解存下来或者打印出来。对于这一步来说，有时候也可以另外写一个issolution函数来进行判断。注意，当到达第三步后，有时候还需要构建一个数据结构，把符合要求的解存起来，便于当得到所有解后，把解空间输出来。这个数据结构必须是全局的，作为参数之一传递给递归函数。而且要注意：如果维持的是同一个数据结构，注意回溯的时候回退数据结构中的内容。 后面几天我会多找一些关于回溯算法的题来品尝。 更多关于回溯的问题更多关于回溯算法的问题请转到回溯算法标签","tags":[{"name":"回溯","slug":"回溯","permalink":"http://www.allenmistake.top/tags/回溯/"}]},{"title":"Java日常学习总结并发进阶之线程池","date":"2019-03-12T08:29:44.000Z","path":"2019/03/12/javadailyplus2/","text":"线程池例如在Android中，由于主线程的诸多限制，像网络请求等一些耗时的操作我们必须在子线程中运行。我们往往会通过new Thread来开启一个子线程，待子线程操作完成以后通过Handler切换到主线程中运行。这么以来我们无法管理我们所创建的子线程，并且无限制的创建子线程，它们相互之间竞争，很有可能由于占用过多资源而导致死机或者OOM。所以在Java中为我们提供了线程池来管理我们所创建的线程。 线程池的优势 降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗； 提高系统响应速度，当有任务到达时，无需等待新线程的创建便能立即执行； 方便线程并发数的管控，线程若是无限制的创建，不仅会额外消耗大量系统资源，更是占用过多资源而阻塞系统或oom等状况，从而降低系统的稳定性。线程池能有效管控线程，统一分配、调优，提供资源使用率； 更强大的功能，线程池提供了定时、定期以及可控线程数等功能的线程池，使用方便简单。 线程池创建1ExecutorService service = new ThreadPoolExecutor(....); 构造方法 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) ThreadPoolExecutor参数含义 corePoolSize线程池中的核心线程数，默认情况下，核心线程一直存活在线程池中，即便他们在线程池中处于闲置状态。除非我们将ThreadPoolExecutor的allowCoreThreadTimeOut属性设为true的时候，这时候处于闲置的核心线程在等待新任务到来时会有超时策略，这个超时时间由keepAliveTime来指定。一旦超过所设置的超时时间，闲置的核心线程就会被终止。 maximumPoolSize线程池中所容纳的最大线程数，如果活动的线程达到这个数值以后，后续的新任务将会被阻塞。包含核心线程数+非核心线程数。 keepAliveTime非核心线程闲置时的超时时长，对于非核心线程，闲置时间超过这个时间，非核心线程就会被回收。只有对ThreadPoolExecutor的allowCoreThreadTimeOut属性设为true的时候，这个超时时间才会对核心线程产生效果。 unit用于指定keepAliveTime参数的时间单位。他是一个枚举，可以使用的单位有天（TimeUnit.DAYS），小时（TimeUnit.HOURS），分钟（TimeUnit.MINUTES），毫秒(TimeUnit.MILLISECONDS)，微秒(TimeUnit.MICROSECONDS, 千分之一毫秒)和毫微秒(TimeUnit.NANOSECONDS, 千分之一微秒); workQueue 线程池中保存等待执行的任务的阻塞队列。通过线程池中的execute方法提交的 Runable对象都会存储在该队列中。我们可以选择下面几个阻塞队列。 阻塞队列 说明 ArrayBlockingQueue 基于数组实现的有界的阻塞队列,该队列按照FIFO（先进先出）原则对队列中的元素进行排序。 LinkedBlockingQueue 基于链表实现的阻塞队列，该队列按照FIFO（先进先出）原则对队列中的元素进行排序。 SynchronousQueue 内部没有任何容量的阻塞队列。在它内部没有任何的缓存空间。对于SynchronousQueue中的数据元素只有当我们试着取走的时候才可能存在。 PriorityBlockingQueue 具有优先级的无限阻塞队列。 threadFactory线程工厂，为线程池提供新线程的创建。ThreadFactory是一个接口，里面只有一个newThread方法。默认为DefaultThreadFactory类。 handler是RejectedExecutionHandler对象，RejectedExecutionHandler面只有一个rejectedExecution方法。当任务队列已满并且线达到所限定的最大值或者是无法成功执行任务，这时候ThreadPoolExecutor用RejectedExecutionHandler中的rejectedExecution方法ThreadPoolExecutor中有四个内部类实现了RejectedExecutionHandler程池中它默认是AbortPolicy，在无法处理新任务时抛出RejectedExecutionException异常。下面是在ThreadPoolExecutor中提供的四个可选值。 可选值 说明 CallerRunsPolicy 只用调用者所在线程来运行任务。 AbortPolicy 直接抛出RejectedExecutionException异常。 DiscardPolicy 丢弃掉该任务，不进行处理。 DiscardOldestPolicy 丢弃队列里最近的一个任务，并执行当前任务。 ThreadPoolExecutor的使用 1ExecutorService service = new ThreadPoolExecutor(5, 10, 10, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;()); 对于ThreadPoolExecutor有多个构造方法，对于上面的构造方法中的其他参数都采用默认值。可以通过execute和submit两种方式来向线程池提交一个任务。execute 当我们使用execute来提交任务时，由于execute方法没有返回值，所以说我们也就无法判定任务是否被线程池执行成功。 12345service.execute(new Runnable() &#123; public void run() &#123; System.out.println(\"execute方式\"); &#125;&#125;); 线程池执行流程 线程池流程 如果在线程池中的线程数量没有达到核心的线程数量，这时候就回启动一个核心线程来执行任务。 如果线程池中的线程数量已经超过核心线程数，这时候任务就会被插入到任务队列中排队等待执行。 由于任务队列已满，无法将任务插入到任务队列中。这个时候如果线程池中的线程数量没有达到线程池所设定的最大值，那么这时候就会立即启动一个非核心线程来执行任务。 如果线程池中的数量达到了所规定的最大值，那么就会拒绝执行此任务，这时候就会调用RejectedExecutionHandler中的rejectedExecution方法来通知调用者。 四种线程池 newFixedThreadPool 通过Executors中的newFixedThreadPool方法来创建，该线程池是一种线程数量固定的线程池。 1ExecutorService service = Executors.newFixedThreadPool(4); 在这个线程池中所容纳最大的线程数就是我们设置的核心线程数。如果线程池的线程处于空闲状态的话，它们并不会被回收，除非是这个线程池被关闭。 由于newFixedThreadPool只有核心线程，并且这些线程都不会被回收，也就是它能够更快速的响应外界请求。 从下面的newFixedThreadPool方法的实现可以看出，newFixedThreadPool只有核心线程，并且不存在超时机制，采用LinkedBlockingQueue，所以对于任务队列的大小也是没有限制的。 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; newCachedThreadPool 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 通过s上面的newCachedThreadPool方法在这里我们可以看出它的核心线程数为0，线程池的最大线程数Integer.MAX_VALUE。而Integer.MAX_VALUE是一个很大的数，也差不多可以说这个线程池中的最大线程数可以任意大。当线程池中的线程都处于活动状态的时候，线程池就会创建一个新的线程来处理任务。该线程池中的线程超时时长为60秒，所以当线程处于闲置状态超过60秒的时候便会被回收。这也就意味着若是整个线程池的线程都处于闲置状态超过60秒以后，在newCachedThreadPool线程池中是不存在任何线程的，所以这时候它几乎不占用任何的系统资源。 对于newCachedThreadPool他的任务队列采用的是SynchronousQueue，上面说到在SynchronousQueue内部没有任何容量的阻塞队列。SynchronousQueue内部相当于一个空集合，我们无法将一个任务插入到SynchronousQueue中。所以说在线程池中如果现有线程无法接收任务,将会创建新的线程来执行任务。 newScheduledThreadPool 1234567public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());&#125; 它的核心线程数是固定的，对于非核心线程几乎可以说是没有限制的，并且当非核心线程处于限制状态的时候就会立即被回收。 ScheduledExecutorService功能强大，对于定时执行的任务，建议多采用该方法。 newSingleThreadExecutor通过Executors中的newSingleThreadExecutor方法来创建，在这个线程池中只有一个核心线程，对于任务队列没有大小限制，也就意味着这一个任务处于活动状态时，其他任务都会在任务队列中排队等候依次执行。newSingleThreadExecutor将所有的外界任务统一到一个线程中支持，所以在这个任务执行之间我们不需要处理线程同步的问题。 线程池的使用技巧需要针对具体情况而具体处理，不同的任务类别应采用不同规模的线程池，任务类别可划分为CPU密集型任务、IO密集型任务和混合型任务。(N代表CPU个数)|任务类别|说明||—|:—||CPU密集型任务|线程池中线程个数应尽量少，如配置N+1个线程的线程池。||IO密集型任务|由于IO操作速度远低于CPU速度，那么在运行这类任务时，CPU绝大多数时间处于空闲状态，那么线程池可以配置尽量多些的线程，以提高CPU利用率，如2*N。||混合型任务|可以拆分为CPU密集型任务和IO密集型任务，当这两类任务执行时间相差无几时，通过拆分再执行的吞吐率高于串行执行的吞吐率，但若这两类任务执行时间有数据级的差距，那么没有拆分的意义。| 多线程更多关于Java并发多线程请点击Java进阶学习多线程","tags":[{"name":"多线程","slug":"多线程","permalink":"http://www.allenmistake.top/tags/多线程/"}]},{"title":"Java日常学习总结并发进阶之线程初步、锁与同步篇","date":"2019-03-09T12:53:19.000Z","path":"2019/03/09/javadailyplus1/","text":"线程状态 线程状态图 新创建刚new出来的Thread还没有被运行，创建线程的三种方式 可运行一旦调用start 方法，线程处于runnable状态。一个可运行的线桿可能正在运行也可能没有运行， 这取决于操作系统给线程提供运行的时间。 被阻塞线程和等待线程当线程处于被阻塞或等待状态时， 它暂时不活动。它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。细节取决于它是怎样达到非活动状态的 当一个线程试图获取一个内部的对象锁（而不是javiutiUoncurrent 库中的锁)，而该锁被其他线程持有， 则该线程进人阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。 当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。在调用Object.wait方法或Thread.join方法，或者是等待java,util.concurrent 库中的Lock 或Condition 时，就会出现这种情况。实际上，被阻塞状态与等待状态是有很大不同的。 有几个方法有一个超时参数。调用它们导致线程进人计时等待(timed waiting) 状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有Thread.sleep 和Object.wait、Thread.join、Lock,tryLock以及Condition.await的计时版。 被终止的线程线程因如下两个原因之一而被终止： 因为run方法正常退出而自然死亡。 因为一个没有捕获的异常终止了run方法而意外死亡。 同一个线程被 start() 两次(2019-7-13更新)Java 的线程是不允许启动两次的，第二次调用必然会抛出 IllegalThreadStateException，这是一种运行时异常，多次调用 start 被认为是编程错误。在第二次调用 start() 方法的时候，线程可能处于终止或者其他（非 NEW）状态，但是不论如何，都是不可以再次启动的。 线程状态之间相互转化 创建一个新线程的三种方法通过Runnable接口创建线程类 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 调用线程对象的start()方法来启动该线程。 123456789101112131415161718public class RunnableThreadTest implements Runnable &#123; private int i; public void run() &#123; for (i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName()+ \" \" + i); &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName()+ \" \" + i); if (i == 20) &#123; RunnableThreadTest rtt = new RunnableThreadTest(); new Thread(rtt, \"新线程1\").start(); new Thread(rtt, \"新线程2\").start(); &#125; &#125; &#125;&#125; 继承Thread类创建线程类 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。 创建Thread子类的实例，即创建了线程对象。 调用线程对象的start()方法来启动该线程。 123456789101112131415161718public class FirstThreadTest extends Thread &#123; int i = 0; //重写run方法，run方法的方法体就是现场执行体 public void run() &#123; for (; i &lt; 100; i++) &#123; System.out.println(getName() + \" \" + i); &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName()+ \" : \" + i); if (i == 20) &#123; new FirstThreadTest().start(); new FirstThreadTest().start(); &#125; &#125; &#125;&#125; Callable 接口Callable 与 Runable 有两点不同： 可以通过 call() 获得返回值。 call() 可以抛出异常 Thread 和 Runnable 的区别如果一个类继承 Thread， 则不适合资源共享。但是如果实现了 Runnable 接口的话，则很容易实现资源共享。 总结：实现 Runnable 接口比继承 Thread 类具有的优势： 适合多个和相同的程序代码的线程去共享同一个资源。 可以避免 java 中的单继承的局限性。 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。 线程池只能放入实现 Runnable或 Callable 类线程，不能直接放入继承Thread 的类。 中断线程没有任何语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。某些线程是如此重要以至于应该处理完异常后， 继续执行， 而不理会中断。但是，更普遍的情况是，线程将简单地将中断作为一个终止的请求。 线程属性线程优先级每当线程调度器有机会选择新线程时，它首先选择具有较高优先级的线程。但是，线程优先级是高度依赖于系统的。当虚拟机依赖于宿主机平台的线程实现机制时，Java 线程的优先级被映射到宿主机平台的优先级上，优先级个数也许更多，也许更少。 static void yield( )导致当前执行线程处于让步状态。如果有其他的可运行线程具有至少与此线程同样高的优先级，那么这些线程接下来会被调度。注意，这是一个静态方法。 守护线程(2019-7-13更新)有的时候应用中需要一个长期驻留的服务程序，但是不希望其影响应用退出，就可以将其设置为守护线程，如果 JVM 发现只有守护线程存在时，将结束进程，具体可以参考下面代码段。注意，必须在线程启动之前设置。 123Thread daemonThread = new Thread();daemonThread.setDaemon(true);daemonThread.start(); 同步为了避免多线程引起的对共享数据的讹误，必须学习如何同步存取。 竞争条件详解当两个线程试图同时更新同一个账户的时候，这个问题就出现了。假定两个线程同时执行指令accounts[to] += amount;问题在于这不是原子操作。该指令可能被处理如下： 将accounts[to]加载到寄存器。 增加amount 。 将结果写回accounts[to]。 现在，假定第1个线程执行步骤1和2, 然后，它被剥夺了运行权。假定第2个线程被唤醒并修改了accounts 数组中的同一项。然后，第1个线程被唤醒并完成其第3步。这样，这一动作擦去了第二个线程所做的更新。于是，总金额不再正确。因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。 锁同步锁Lock有两种机制防止代码块受并发访问的干扰。Java语言提供一个 synchronized 关键字达到这一目的，并且Java SE 5.0引入了ReentrantLock 类。 123456789101112131415161718public class Bank&#123; private Lock bankLock = new ReentrantLock0 ；// ReentrantLock implements the Lock interface public void transfer(int from, intto, int amount)&#123; bankLock.lock(); try &#123; System.out.print(Thread.currentThread0); accounts[from] -= amount; System.out.printf(\" %10.2f from %A to %d\", amount, from, to); accounts[to] += amount; System.out.printf(\" Total Balance: %10.2f%n\",getTotalBalance()); &#125; finally &#123; banklock.unlockO; &#125; &#125;&#125; 重入Lock是一个更强大的工具，他有一个重入功能————当一个线程得到一个对象后，再次请求该对象锁时是可以再次得到该对象的锁的。具体概念就是：自己可以再次获取自己的内部锁。因为线程可以重复地获得已经持有的锁。锁保持一个持有计数（holdcount) 来跟踪对lock 方法的嵌套调用。线程在每一次调用lock 都要调用unlock 来释放锁。由于这一特性，被一个锁保护的代码可以调用另一个使用相同的锁的方法。假定一个线程调用transfer, 在执行结束前被剥夺了运行权。假定第二个线程也调用transfer, 由于第二个线程不能获得锁，将在调用lock 方法时被阻塞。它必须等待第一个线程完成transfer 方法的执行之后才能再度被激活。当第一个线程释放锁时，那么第二个线程才能开始运行 公平锁CPU在调度线程的时候是在等待队列里随机挑选一个线程，由于这种随机性所以是无法保证线程先到先得的（synchronized控制的锁就是这种非公平锁）。但这样就会产生饥饿现象，即有些线程（优先级较低的线程）可能永远也无法获取CPU的执行权，优先级高的线程会不断的强制它的资源。那么如何解决饥饿问题呢，这就需要公平锁了。公平锁可以保证线程按照时间的先后顺序执行，避免饥饿现象的产生。但公平锁的效率比较低，因为要实现顺序执行，需要维护一个有序队列。 条件对象Condition假定一个线程已经获得锁，将要执行，但是他所需要的条件还没有满足（例如在余额不足的情况下取钱），便会造成有锁却不执行，其他能够提供满足条件的线程（例如存钱）却只能等待，陷入僵局。一个锁对象可以有一个或多个相关的条件对象。你可以用newCondition 方法获得一个条件对象。习惯上给每一个条件对象命名为可以反映它所表达的条件的名字。例如，在此设置一个条件对象来表达“ 余额充足”条件。 12345678class Bank&#123; private Condition sufficientFunds; ··· public Bank()&#123; ··· sufficientFunds=bankLock.newCondition(); &#125;&#125; 如果transfer方法发现余额不足，它调用下面这个方法sufficientFunds.await();当前线程现在被阻塞了，并放弃了锁。我们希望这样可以使得另一个线程可以进行增加账户余额的操作。等待获得锁的线程和调用await 方法的线程存在本质上的不同。一旦一个线程调用await方法，它进人该条件的等待集。当锁可用时，该线程不能马上解除阻塞。相反，它处于阻塞状态，直到另一个线程调用同一条件上的signalAll 方法时为止。 synchronized关键字在前面一节中，介绍了如何使用 Lock 和 Condition 对象。在进一步深人之前，总结一下有关锁和条件的关键之处： 锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码。 锁可以管理试图进入被保护代码段的线程。 锁可以拥有一个或多个相关的条件对象。 每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程。 Lock 和 Condition 接口为程序设计人员提供了高度的锁定控制。然而，大多数情况下，并不需要那样的控制，并且可以使用一种嵌人到Java 语言内部的机制。 如果一个方法用synchronized 关键字声明，那么对象的锁将保护整个方法。也就是说，要调用该方法，线程必须获得内部的对象锁。换句话说 1234public synchronized void method()&#123; method body&#125; 其实方法锁其实锁的是实例对象，可以等价于 123456public void method()&#123; //相当于锁实例 synchronized(this)&#123; //需要同步的代码块 &#125;&#125; 将静态方法声明为synchronized 也是合法的。如果调用这种方法，该方法获得相关的类对象的内部锁。例如，如果Bank类有一个静态同步的方法，那么当该方法被调用时，Bankxlass对象的锁被锁住。因此，没有其他线程可以调用同一个类的这个或任何其他的同步静态方法。 123456public static void method()&#123; //相当于锁的整个类 synchronized(xxx.class)&#123; //需要同步的代码块 &#125;&#125; 静态方法同步与非静态方法同步区别： 静态同步：因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。 非静态同步：锁住的是该对象,类的其中一个实例，当该对象(仅仅是这一个对象)在不同线程中执行这个同步方法时，线程之间会形成互斥。达到同步效果，但如果不同线程同时对该类的不同对象执行这个同步方法时，则线程之间不会形成互斥，因为他们拥有的是不同的锁。 内部锁和条件存在一些局限。包括： 不能中断一个正在试图获得锁的线程。 试图获得锁时不能设定超时。 每个锁仅有单一的条件，可能是不够的 synchronized和ReentrantLock的比较区别： Lock是一个接口，是通过 JDK 来实现的，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现，是 JVM 实现的； synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock() 去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁； Lock可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断； 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 Lock可以提高多个线程进行读操作的效率。 两者在锁的相关概念上区别： 可中断锁 顾名思义，就是可以响应中断的锁。 在Java中，synchronized就不是可中断锁，而Lock是可中断锁。如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。 lockInterruptibly()的用法体现了Lock的可中断性。 公平锁 公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该锁（并不是绝对的，大体上是这种顺序），这种就是公平锁。 非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。 在Java中，synchronized 就是非公平锁，它无法保证等待的线程获取锁的顺序。ReentrantLock可以设置成公平锁。 读写锁 读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。 正因为有了读写锁，才使得多个线程之间的读操作可以并发进行，不需要同步，而写操作需要同步进行，提高了效率。 ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。 可以通过readLock()获取读锁，通过writeLock()获取写锁。 绑定多个条件 一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多余一个条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这么做，只需要多次调用new Condition()方法即可。 在新版的 JDK 中， synchronize 也逐渐有了很多优化，除非我们需要用到 ReentrantLock 的高级功能(比如上述几个锁)，我们尽量选用 synchronize 关键词。 final还有一种情况可以安全地访问一个共享域，即这个域声明为final 时。考虑以下声明： 1final Map&lt;String, Double〉accounts = new HashMap&lt;&gt;() ； 其他线程会在构造函数完成构造之后才看到这个accounts变量。 线程间协作join在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。 wait、notify、notifyall调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。 它们都属于 Object 的一部分，而不属于 Thread。 只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。 使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。 死锁产生条件 互斥条件：一个资源每次只能被一个线程使用。 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。 有3种典型的死锁类型： 静态的锁顺序死锁a和b两个方法都需要获得A锁和B锁。一个线程执行a方法且已经获得了A锁，在等待B锁；另一个线程执行了b方法且已经获得了B锁，在等待A锁。这种状态，就是发生了静态的锁顺序死锁。 经典面试问题：写一个死锁 1234567891011121314151617181920class StaticLockOrderDeadLock&#123; private final Object lockA = new Object(); private final Object lockB = new Object(); public void a()&#123; synchronized(lockA)&#123; synchronized(lockB)&#123; System.out.println(\"function a\"); &#125; &#125; &#125; public void b()&#123; synchronized(lockB)&#123; synchronized(lockA)&#123; System.out.println(\"function b\"); &#125; &#125; &#125;&#125; 解决静态的锁顺序死锁的方法就是：所有需要多个锁的线程，都要以相同的顺序来获得锁。 动态的锁顺序死锁动态的锁顺序死锁是指两个线程调用同一个方法时，传入的参数颠倒造成的死锁。如下代码，一个线程调用了transferMoney方法并传入参数accountA,accountB；另一个线程调用了transferMoney方法并传入参数accountB,accountA。此时就可能发生在静态的锁顺序死锁中存在的问题，即：第一个线程获得了accountA锁并等待accountB锁，第二个线程获得了accountB锁并等待accountA锁。 动态的锁顺序死锁解决方案如下：使用System.identifyHashCode来定义锁的顺序。确保所有的线程都以相同的顺序获得锁。 协作对象之间发生的死锁有时，死锁并不会那么明显，比如两个相互协作的类之间的死锁，比如下面的代码：一个线程调用了Taxi对象的setLocation方法，另一个线程调用了Dispatcher对象的getImage方法。此时可能会发生，第一个线程持有Taxi对象锁并等待Dispatcher对象锁，另一个线程持有Dispatcher对象锁并等待Taxi对象锁。 上面的代码中，我们在持有锁的情况下调用了外部的方法，这是非常危险的（可能发生死锁）。为了避免这种危险的情况发生，我们使用开放调用。如果调用某个外部方法时不需要持有锁，我们称之为开放调用。解决协作对象之间发生的死锁：需要使用开放调用，即避免在持有锁的情况下调用外部的方法。 锁优化多线程更多关于Java并发多线程请点击Java进阶学习多线程","tags":[{"name":"多线程","slug":"多线程","permalink":"http://www.allenmistake.top/tags/多线程/"}]},{"title":"Leetcode日记：67.二进制数相加&字符串相关操作总结","date":"2019-03-07T13:15:20.000Z","path":"2019/03/07/leetcode67/","text":"问题Given two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0. Example 1: 12Input: a = &quot;11&quot;, b = &quot;1&quot;Output: &quot;100&quot; Example 2: 12Input: a = &quot;1010&quot;, b = &quot;1011&quot;Output: &quot;10101&quot; 分析这道题本来不想放上来的，不涉及多少算法上的问题，但是记录一些必要的字符串方法是很有必要的 StringBuffer、StringBuilder与String这三兄弟看似一样，实则区别很小，但是终归还是有区别的 运行速度方面：StringBuilder &gt; StringBuffer &gt; String前两个我们抛开不谈，说说为什么 String 最慢，因为 String 为字符串常量，而 StringBuilder 和 StringBuffer 均为字符串变量，即 String 对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。 1234String str=\"abc\";System.out.println(str);str=str+\"de\";System.out.println(str); 如果运行这段代码会发现先输出 “abc”，然后又输出 “abcde” ，好像是 str 这个对象被更改了，其实，这只是一种假象罢了，JVM 对于这几行代码是这样处理的，首先创建一个 String 对象 str ，并把 “abc” 赋值给 str ，然后在第三行中，其实 JVM 又创建了一个新的对象也名为 str ，然后再把原来的 str 的值和 “de” 加起来再赋值给新的 str ，而原来的 str 就会被 JVM 的垃圾回收机制（GC）给回收掉了，所以， str 实际上并没有被更改，也就是前面说的 String 对象一旦创建之后就不可更改了。所以， Java 中对 String 对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。 线程安全方面 StringBuffer 线程安全，而 StringBuilder 非线程安全，主要由于 Builder 中不带锁方法。这里我们不详细讨论。 方法String的方法 1234567String a = \"Hello World\"a.charAt(1);//寻找第1个元素byte b[] = a.getBytes();//转换成比特数组char[]b = a.toCharArray();//转换成字符数组b.concat(a);//连接两个字符串a.indexOf(\"o\"));//“o”第一次出现的位置a.lastIndexOf(\"o\");//“o”最后一次出现的位置 StringBuffer的方法 12345sb1.append(\" World\");//在尾部添加字符串sb1.insert(1, \"ME\");//在指定位置后面添加字符串sb1.deleteCharAt(0)；//删除指定位置元素sb1.reverse();//反转字符串sb1.toString();//转换成String类型 将字符串中的字符型数字转换成int 1int number = b.charAt(i) - '0'; String 为什么要设计成不可变的？(2019-5-14 更新) 字符串常量池的需要 字符串常量池(String pool, String intern pool, String保留池) 是Java堆内存中一个特殊的存储区域, 当创建一个String对象时,假如此字符串值已经存在于常量池中,则不会创建一个新的对象,而是引用已经存在的对象。还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。 如下面的代码所示,将会在堆内存中只创建一个实际String对象. 12String s1 = \"abcd\";String s2 = \"abcd\"; 示意图如下所示: 假若字符串对象允许改变,那么将会导致各种逻辑错误,比如改变一个对象会影响到另一个独立对象. 严格来说，这种常量池的思想,是一种优化手段. String 不可变性天生具备线程安全，可以在多个线程中安全地使用。 允许String对象缓存HashCode Java中String对象的哈希码被频繁地使用, 比如在hashMap 等容器中。 字符串不变性保证了hash码的唯一性,因此可以放心地进行缓存.这也是一种性能优化手段,意味着不必每次都去计算新的哈希码. 在String类的定义中有如下代码: 1private int hash;//用来缓存HashCode 回到这道题这道题说两个二进制数相加，得到一个二进制数，首先顺序肯定是从后向前，按位计算，其次要选择一个变量来判断是否应该进位（carry）。我们将每位算出的结果取余保存在一个StringBuffer中，然后将得到的数除以2来判断下一个是否进位。最后返回StringBuffer的反转。 代码123456789101112131415public class Solution &#123; public String addBinary(String a, String b) &#123; StringBuilder sb = new StringBuilder(); int i = a.length() - 1, j = b.length() -1, carry = 0; while (i &gt;= 0 || j &gt;= 0) &#123; int sum = carry; if (j &gt;= 0) sum += b.charAt(j--) - '0'; if (i &gt;= 0) sum += a.charAt(i--) - '0'; sb.append(sum % 2); carry = sum / 2; &#125; if (carry != 0) sb.append(carry); return sb.reverse().toString(); &#125;&#125; 源代码","tags":[{"name":"字符串","slug":"字符串","permalink":"http://www.allenmistake.top/tags/字符串/"}]},{"title":"Leetcode日记：70.爬楼梯&动态规划小结","date":"2019-03-06T12:49:23.000Z","path":"2019/03/06/ClimbingStairs/","text":"Leetcode日记：70.爬楼梯 爬呀爬呀爬楼梯 题目You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example 1: 12345Input: 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps Example 2: 123456Input: 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step 分析题目很容易理解，可以选择一次爬两节台阶，也可以爬一节，问究竟有多少种情况（不能忽略顺序）。这道题和53题的最长子串题有异曲同工之妙，为什么这么说呢？首先我们来看：最长字串要对前面计算的子串长度进行更新，在更新的过程中，势必要得出在之前的最长字串是多少。而爬楼梯这道题，同样和前一状态有关，比如爬n节台阶，就会分为两种情况： 在n-1的台阶处爬一层台阶 在n-2的台阶处爬两层台阶 继续向下延伸思考，到达每一次层一共有几种方法这个问题就变成了2个子问题： 到达n-1层台阶有几种方法 到达n-2层台阶有几种方法 动态规划通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，这就是动态规划。动态规划常常适用于有重叠子问题和最优子结构性质的问题。我们要明确，动态规划是一种思想，并不是一种具体的算法。 那么适用于动态规划的问题都有哪些特征呢？ 最优子结构：当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。 重叠子问题：在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只解一次，而后将其解保存在一个表格中，在以后尽可能多地利用这些子问题的解。 回到原问题让我们回归这道题，我们总结一下之前分析的结果： 第n个结果=第n-1个结果+第n-2个结果 好的，我们抛开我们熟悉的斐波那契数列不谈（事实上，在只能走1，2节的时候该题的结果就是斐波那契数列。。），我们可以建立一个dp数组，先将1和2两种情况求出来，之后的3、4、…、n+1都可以用前两个已经计算出的子结果得到。 这就是我们这道题利用到动态规划的核心算法。 代码1234567891011121314public class Solution &#123; public int climbStairs(int n) &#123; if (n == 1) &#123; return 1; &#125; int[] dp = new int[n + 1]; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n]; &#125;&#125; 代码源文件 总结动态规划问题算法多变，需要多做题熟练掌握这种思想。","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://www.allenmistake.top/tags/动态规划/"}]},{"title":"你好，Hexo","date":"2019-03-06T03:12:01.000Z","path":"2019/03/06/hellohexo/","text":"你好，Hexohexo的使用技巧插入图片 喝杯咖啡休息一下 评论来日方长","tags":[{"name":"其他","slug":"其他","permalink":"http://www.allenmistake.top/tags/其他/"}]},{"title":"Leetcode日记：66.加一","date":"2019-03-04T17:00:00.000Z","path":"2019/03/05/leetcode66/","text":"题目Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: 123Input: [1,2,3]Output: [1,2,4]Explanation: The array represents the integer 123. Example 2: 123Input: [4,3,2,1]Output: [4,3,2,2]Explanation: The array represents the integer 4321. 分析题目很明显就是让你把这些数组当成一个数，然后让你返回把这个数+1之后的数组形式，坑爹的是两个例子都没有体现出这道题的特殊值； 事实上，我们遇到这种+1问题，首先要考虑进位，如果都是题目给的这种例子，末位直接+1，返回OK了，但是如果出现[9]或者是[9,9,9]又该怎么处理呢？ 答案12345678910111213public int[] plusOne(int[] digits) &#123; int n = digits.length-1; for(int i=n;i!=-1;i--)&#123; if(digits[i]&lt;9)&#123; ++digits[i]; return digits; &#125; digits[i]=0; &#125; int[] a = new int[n+2]; a[0]=1; return a; &#125; 从这里可以看出，对付进位，位数溢出的方法，其结果必定是首位是1，后面全是0，明确了这一点，就可以理解最后三行的意图了。","tags":[{"name":"数组","slug":"数组","permalink":"http://www.allenmistake.top/tags/数组/"}]},{"title":"Java日常学习总结之继承、抽象与接口","date":"2019-03-03T17:00:00.000Z","path":"2019/03/04/javadaily3/","text":"类，超类，子类super super与this有些人认为 super 与 this 引用是类似的概念， 实际上， 这样比较并不太恰当。这是因为super 不是一个对象的引用， 不能将 super 赋给另一个对象变量， 它只是一个指示编译器调用超类方法的特殊关键字。 super与构造当子类构造的时候，由于不能对其超类的私有成员进行访问，只能调用超类的构造器。如果子类的构造器没有显式地调用超类的构造器， 则将自动地调用超类默认（没有参数)的构造器。 超类与子类引用关系超类可以引用子类，但是，不能将一个超类的引用赋给子类变量。在下面的例子中，超类虽然引用了子类，变量staff[0]与boss引用同一个对象。但编译器将staff[0]看成Employee对象。 12345Manager boss = new Manager(. . .);Employee[] staff = new Employee[3];staff[0] = boss;//Correct Employee超类可以引用其子类Mangerboss = staff[0];//Errorstaff[0].setBonus(5000);//Error 在Java 中，子类数组的引用可以转换成超类数组的引用， 而不需要采用强制类型转换。例如，下面是一个经理数组 1Manager[] managers = new Manager[10]; 将它转换成Employee[]数组完全是合法的： 1Employee[] staff = managers; // OK 这样做肯定不会有问题，请思考一下其中的缘由。毕竟，如果manager[i] 是一个Manager, 也一定是一个Employee。然而， 实际上，将会发生一些令人惊讶的事情。要切记managers和staff引用的是同一个数组。现在看一下这条语句： 1staff[0] = new Employee(\"Harry Hacker\", . . .) ; 编译器竟然接纳了这个赋值操作。但在这里， staff[0]与manager[0]引用的是同一个对象，似乎我们把一个普通雇员擅自归入经理行列中了。这是一种很忌讳发生的情形，当调用managers[0].setBonus(1000) 的时候，将会导致调用一个不存在的实例域， 进而搅乱相邻存储空间的内容。为了确保不发生这类错误， 所有数组都要牢记创建它们的元素类型，并负责监督仅将类型兼容的引用存储到数组中。例如，使用new managers[10]创建的数组是一个经理数组。如果试图存储一个Employee 类型的引用就会引发ArrayStoreException异常。 类型转换 只能在继承层次内进行类型转换。 在将超类转换成子类之前，应该使用instanceof 进行检查。 在一般情况下，应该尽量少用类型转换和instanceof 运算符。 抽象类abstract提示：许多程序员认为，在抽象类中不能包含具体方法。建议尽量将通用的域和方法（不管是否是抽象的）放在超类（不管是否是抽象类）中。 继承抽象类可以有两种选择。一种是在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类；另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。抽象类不能被实例化。可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象，这个时候，利用这个对象变量调用抽象类的抽象方法，会自动向下寻找，也就是实际调用的是其子类的方法。 抽象与接口抽象类和接口的区别： 接口里只能包含抽象方法，静态方法和默认方法，不能为普通方法提供具体的实现。抽象类可以为普通方法提供具体的实现。所以，当一个子类继承抽象类的时候，并不一定要覆盖抽象类的方法（抽象方法除外），而一个类继承一个接口时，必须要重写接口的所有方法（毕竟接口中的方法只是个声明） 接口里只能定义静态常量，不能定义普通成员变量。抽象类可以定义普通成员变量和静态变量。在接口中定义成员变量会被自动转化成静态 final 变量，也就是在接口中，下面两个语句等价 1int i = 10; 1public static final int i = 10; 接口里不包含构造器。抽象类可以包含构造器（抽象类里的构造器不是用于创建对象的，而是让其子类调用这些构造器来完成类的初始化）。 接口里不能包含初始化块，而抽象类里可以包含初始化块。 一个类最多只能有一个直接父类，包括抽象类，而一个类可以实现多个接口，通过实现多个接口来弥补Java单继承的不足。抽象类中的成员可以是 private、默认、protected、public 的，而接口中的成员全都是 public 的。 Object所有类的超类equals在Object 类中，这个方法将判断两个对象是否具有相同的引用。 泛型数组列表ArrayList 构造形式 1ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;(); Java SE 7 中， 可以省去右边的类型参数： 1ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;()； 添加元素add方法如果调用add且内部数组已经满了， 数组列表就将自动地创建一个更大的数组，并将所有的对象从较小的数组中拷贝到较大的数组中。警告：分配数组列表， 如下所示： 1new ArrayList&lt;&gt;(lOO) // capacity is 100 它与为新数组分配空间有所不同： 1new Employee[100] // size is 100 数组列表的容量与数组的大小有一个非常重要的区别。如果为数组分配100 个元素的存储空间，数组就有100 个空位置可以使用。而容量为100 个元素的数组列表只是拥有保存100 个元素的潜力（ 实际上，重新分配空间的话，将会超过100), 但是在最初，甚至完成初始化构造之后，数组列表根本就不含有任何元素。 C++ 注释： ArrayList类似于C++ 的vector 模板。ArrayList 与vector 都是泛型类型。但是C++ 的vector 模板为了便于访问元素重栽了[ ] 运算符。由于Java 没有运算符重栽，所以必须调用显式的方法。此外，C++ 向量是值拷贝。如果a 和b 是两个向量，赋值操作a = b 将会构造一个与b 长度相同的新向量a，并将所有的元素由b 拷贝到a, 而在Java 中，这条赋值语句的操作结果是让a和b引用同一个数组列表。 总结 不必指出数组的大小。 使用add 将任意多的元素添加到数组中。 使用size() 替代length 计算元素的数目。 使用a.get(i) 替代a[i] 访问元素。 这就是Java 中不尽如人意的参数化类型的限制所带来的结果。鉴于兼容性的考虑， 编译器在对类型转换进行检査之后， 如果没有发现违反规则的现象， 就将所有的类型化数组列表转换成原始ArrayList 对象。在程序运行时， 所有的数组列表都是一样的， 即没有虚拟机中的类型参数。因此，类型转换ArrayList 和ArrayList&lt;Employee&gt; 将执行相同的运行时检查。 对象包装器与自动装箱 对象包装器有时， 需要将int这样的基本类型转换为对象。所有的基本类型都冇一个与之对应的类。通常，这些类称为包装器(wrapper) 。这些对象包装器类拥有很明显的名字：Integer、Long、Float、Double、Short、Byte、Character 、Void 和Boolean 下面是声明一个ArrayList里面存放int型 1ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;()； 这种方式适用于小型集合，因为其效率比整型数组int[]要低得多，但是添加成员的方便程度要比整型数组要高。 自动装箱 幸运的是， 有一个很有用的特性， 从而更加便于添加int 类型的元素到ArrayList&lt;lnteger&gt;中。下面这个调用 1list.add(3); 将自动地变换成 1list.add(Integer.value0f(3)) ; 这种变换被称为自动装箱（autoboxing)。 枚举类内部类(2019-7-12更新)内部类中变量的使用如果希望访问所在方法的局部变量，那么这个局部变量必须是有效 final 的。 1234567891011public class MyOuter&#123; public void methodOuter&#123; int num = 10;//所在方法中的局部变量 class MyInner&#123; public void methodfInner()&#123; System.out.println(num); &#125; &#125; &#125;&#125; new 出来的对象在堆内存中 局部变量是跟着方法走的，在栈内存当中. 方法运行结束之后，立即出栈，局部变量就会立即消失. 但是 new 出来的对象会在堆持续存在，直到垃圾回收消失。 最终当内部类需要使用局部变量时吗，会复制一份到自己的堆内存中，如果这个变量是不确定的，与你形式会带来不确定的后果。 匿名内部类如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用匿名内部类。 谈谈反射(2019-7-17更新)每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。 类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forName(“com.mysql.jdbc.Driver”) 这种方式来控制类的加载，该方法会返回一个 Class 对象。 反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。 Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类： Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；Constructor ：可以用 Constructor 的 newInstance() 创建新的对象。 反射的优点可扩展性 ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。类浏览器和可视化开发环境 ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。调试器和测试工具 ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。 反射的缺点尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。 性能开销 ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。 安全限制 ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。 内部暴露 ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。","tags":[{"name":"基础","slug":"基础","permalink":"http://www.allenmistake.top/tags/基础/"}]},{"title":"Leetcode日记：53.最大子串","date":"2019-03-03T17:00:00.000Z","path":"2019/03/04/leetcode53/","text":"题目Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: 123Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. 解题自己的方法利用数据结构：无利用算法：动态规划复杂度O(n) 代码： 123456789public int maxSubArray(int[] nums) &#123; int max=nums[0]; int temp=max; for(int i=1;i&lt;nums.length;i++)&#123; temp=Math.max(nums[i]+temp,nums[i]); max=Math.max(temp, max); &#125; return max; &#125; 思路：无非就是用一个值(temp)储存中间连续元素的和，在用另外一个值(max)表示到目前为止的最大值，首先比较temp加上后一个元素和那个元素不加temp谁大，如果不加temp说明nums[i]更大，便把它的值赋给temp，继续累加，期间不断更新max值；这种记录中间产生变量，并在循环后加以运用的思想被称作动态规划 总结动态规划在这里刚刚浮出水面，我将在后面做一些专门的补充，来说明动态规划的特点和做题时的应用场景","tags":[{"name":"数组","slug":"数组","permalink":"http://www.allenmistake.top/tags/数组/"},{"name":"动态规划","slug":"动态规划","permalink":"http://www.allenmistake.top/tags/动态规划/"}]},{"title":"新学期总结与3月计划","date":"2019-03-02T17:00:00.000Z","path":"2019/03/03/weeklysummary/","text":"三月的主题是治愈一些感悟最近去电影院看了绿皮书，拍的不错，原谅我只能用很贫瘠的词汇量来形容它，这是一部反映种族歧视问题的电影，很轻松，不沉重，上次看到一个黑人和一个白人为雇主关系还是《触不可及》，但是《触不可及》偏重讲男人之间的友情，而《绿皮书》更侧重于反映不同种族之间的不理解。看的时候鼻子酸酸的，感觉被治愈了，这个月还有一部《夏目友人帐》也是出名的治愈番电影化，恰巧三月是回暖的一个月份，都说西安没有春天，珍惜这份没有被太阳烤热的时间吧。 回顾这是今年写的第一篇总结，其实应该早就写了的，但是总觉得假期并没做很多东西，带到家里的两本书都没看，全都花时间折腾自己的电脑，不得不说备份的重要性。唯一觉得这个暑假的收获可能就是去北京转了转，恰巧那天下雪了，可惜并不知道故宫要提前预约，要不然就能看看雪中的故宫了。但是银装素裹的北海和什刹海也是一种不错的意境。假期本来也就没几天，回来还要干活，自己也给自己放了个假，希望暑假多学习学习。回到学校来就开始帮老师忙项目，忙里偷闲的回顾了一下Java基础知识，然后就开始学习并发，不得不说，并发还是挺难理解的，各种锁，估计要多看几遍了。 展望前端前两天在Github看见微软前端2天学习课程，clone到了本地也学习了一下，其实就是今天的事情，奈何自己语言水平不过关，看起来比较吃力，一天才看了本该半天就学完了的东西，而且也谈不上深入理解，希望在三月份能把这份课程学习完。前端我一直比较感兴趣，能做到略知一二就行，会一些基本的语言语法就ok。 Java三月是Java月（自己编的），这个月要把java并发和jvm全部搞定，参考书籍有： 《Java并发编程艺术》 深入理解JVM虚拟机 这个月主要就和这两本书玩命了 Leetcode感觉现在刷easy有点感觉了，但是讨论区大神有时候给出的方案真的太优美了，什么时候能像他们一样优秀。3月份定的目标是20道leetcode，加油吧！ 写在最后今天天气不错，给自己点一首《面具》。每当这个时候都斗志满满呀","tags":[]},{"title":"Java日常学习总结之类与对象篇","date":"2019-02-27T17:00:00.000Z","path":"2019/02/28/javadaily2/","text":"类构造器 一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。在Java 中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new 操作符的返回值也是一个引用。 构造器产生机制很多人错误地认为Java 对象变量与C++ 的引用类似。然而，在C++中没有空引用， 并且引用不能被赋值。可以将Java 的对象变量看作C++ 的对象指针。例如， 1Date birthday; // Java 实际上， 等同于 1Date* birthday; // C++ 一旦理解了这一点， 一切问题就迎刃而解了。当然， 一个Date* 指针只能通过调用new进行初始化。就这一点而言，c++与Java 的语法几乎是一样的。 1Date* birthday = new Date() ; // C++ 如果把一个变量的值賦给另一个变量， 两个变量就指向同一个日期， 即它们是同一个对象的指针。在 Java 中的null 引用对应 C++ 中的 NULL 指针。所有的 Java 对象都存储在堆中。当一个对象包含另一个对象变量时， 这个变量依然包含着指向另一个堆对象的指针。 在 C++ 中，指针十分令人头疼，并常常导致程序错误。稍不小心就会创建一个错误的指针，或者造成内存溢出。在 Java 语言中， 这些问题都不复存在。如果使用一个没有初始化的指针，运行系统将会产生一个运行时错误，而不是生成一个随机的结果，同时，不必担心内存管理问题，垃圾收集器将会处理相关的事宜。 C++ 确实做了很大的努力，它通过拷贝型构造器和复制操作符来实现对象的自动拷贝。例如，一个链表（ linked list ) 拷贝的结果将会得到一个新链表，其内容与原始链表相同， 但却是一组独立的链接。这使得将同样的拷贝行为内置在类中成为可能。在 Java 中， 必须使用 clone 方法获得对象的完整拷贝。 使用静态工厂方法来代替构造器这个技巧或者说注意事项在effective java中的第一章第一节就强调过，他有很多便捷之处，其中一个重要的就是可以根据产生的具体对象的特征来对方法命名，而构造器只能有一种名字（即类的名字） 访问器和更改器 访问器：只访问对象元素，不会对对象本身进行修改 修改器：会对对象本身进行修改 在C++ 中，带有 const 后缀的方法是访问器方法；默认为更改器方法。但是，在Java 语言中，访问器方法与更改器方法在语法上没有明显的区别， 自定义的类 构造器使用注意事项Java 构造器的工作方式与 C++ 一样。但是，要记住所有Java 对象都是在堆中构造的，构造器总是伴随着 new 操作符一起使用。请注意，不要在构造器中定义与实例域重名的局部变量。例如，下面的构造器将无法设置 salary 。 123456public Employee(St ring n, double s, . .&#123; String name = n; // Error double salary = s; // Error...&#125; this与隐式参数在每一个方法中， 关键字 this 表示隐式参数。C++ 注释： 在 C++ 中， 通常在类的外面定义方法： 1234void Employee::raiseSalary(double byPercent) // C++, not Java&#123; ...&#125; 如果在类的内部定义方法，这个方法将自动地成为内联（inline)方法 12345class Employee&#123;int getNameQ&#123; return name; &#125; // inline in C++ 在 Java 中，所有的方法都必须在类的内部定义，但并不表示它们是内联方法。是否将某个方法设置为内联方法是Java 虚拟机的任务。即时编译器会监视调用那些简洁、经常被调用、没有被重载以及可优化的方法。 静态域与静态方法 静态域如果将域定义为 static , 每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。 静态方法静态方法是一种不能向对象实施操作的方法。静态方法不能有实例域， 因为它不能操作对象。但是，静态方法可以访问自身类中的静态域。在下面两种情况下使用静态方法： 一方法不需要访问对象状态，其所需参数都是通过显式参数提供（例如：Math.pow) 一个方法只需要访问类的静态域（例如：Employee.getNextld) 静态工厂方法静态工厂的功能和构造器基本一致，都是产生一个对象实例。为什么这些类不利用构造器完成这些操作呢？这主要有两个原因： 无法命名构造器。构造器的名字必须与类名相同。但是，这里希望将得到的不同特征的实例采用不用的名字 当使用构造器时，无法改变所构造的对象类型。只能是自己类型，不能是其子类 父类的静态方法能不能被重写？（2019-5-14 更新）答案是不能。因为静态方法从程序开始运行后就已经分配了内存，也就是说已经写死了。所有引用到该方法的对象（父类的对象也好子类的对象也好）所指向的都是同一块内存中的数据，也就是该静态方法。子类中如果定义了相同名称的静态方法，并不会重写，而应该是在内存中又分配了一块给子类的静态方法，没有重写这一说。 方法参数 Java 程序设计语言总是采用按值调用 也就是说，方法得到的是所有参数值的一个拷贝特别是，方法不能修改传递给它的任何参数变量的内容。 在这里对象是个特殊情况，可以改变传入对象中成员变量的值，但是基本类型例如int、boolean并不能改变（不会报错，但跳出方法外值不变，因为变得是拷贝，而不是其本身） 然而，虽然对象是特殊情况，但对象仍然是按值调用，不是引用调用； 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。 一个方法可以改变一个对象参数的状态。 一个方法不能让对象参数引用一个新的对象。 对象与其他对象构造 调用另一个构造器 如果构造器的第一个语句形如this(…) ，这个构造器将调用同一个类的另一个构造器。下面是一个典型的例子： 12345public Employee(double s)&#123; // calls Employee(String, double) this(\"Employee #\" + nextld, s); nextld++;&#125; 当调用 new Employee(60000) 时，Employee(double) 构造器将调用 Employee(String ，double) 构造器。采用这种方式使用 this 关键字非常有用，这样对公共的构造器代码部分只编写一次即可。 对象析构与 finalize 方法 在析构器中，最常见的操作是回收分配给对象的存储空间。由于 Java 有自动的垃圾回收器，不需要人工回收内存，所以 Java 不支持析构器。 包 包的导入在C++中，与包机制类似的是命名空间（namespace) 。在Java 中，package 与 import 语句类似于 C++ 中的 namespace 和 using 指令。 类的设计技巧 一定要保证数据私有 一定要对数据初始化 不要在类中使用过多的基本类型 不是所有的域都需要独立的域访问器和域更改器 将职责过多的类进行分解 类名和方法名要能够体现它们的职责","tags":[{"name":"基础","slug":"基础","permalink":"http://www.allenmistake.top/tags/基础/"}]},{"title":"Java日常学习总结之基础程序设计篇","date":"2019-02-23T17:00:00.000Z","path":"2019/02/24/javadairy1/","text":"基础程序设计篇布尔类型 Java中，布尔值并不能转换成为数字，数字也不能转化为布尔； 枚举类在第5章的时候介绍；声明的时候enum关键词； 字符串 Java字符串并不是字符型数组 1char greeting[]=\"Hello\" 这种认识是错误的，Java字符串大致类似于char*指针 1char* greeting=\"Hello\" 空串是长度为0，内容为空的字符串；null串目前没有任何对象与该对象关联；更多请看第四章 String类的一些常用方法 检测两个字符串是否相等 区分大小写”Hello”.equals(greetintg) 不区分大小写”Hello”.equalsIgnoreCase(“hello”) 不能用==来判断，这样对比的是存储位置，而不是具体的值； 其他 char charAt(inr index)返回指定位置的字符 int compareTo(String other)按照字典顺序，如果字符串位于other之前，返回一个负数；如果字符串位于other之前，返回一个正数，相等返回0； boolean equals(Object other) int indexOf(String str)返回与字符串str或代码点cp匹配的第一个字串开始的位置。位置从0开始计算； String substring( int beginlndex, int endlndex )返回一个新字符串。这个字符串包含原始字符串中从beginlndex 到串尾或endlndex-l的所有代码单元。 StringBuilder如果需要用许多小段的字符串构建一个字符串， 那么应该按照下列步骤进行。 首先， 构建一个空的字符串构建器： 1StringBuilder builder = new StringBuilderO; 当每次需要添加一部分内容时， 就调用append 方法。 12builder.append(ch); // appends a single characterbui1der.append(str); // appends a string 在需要构建字符串时就凋用toString 方法， 将可以得到一个String 对象， 其中包含了构建器中的字符序列。String completedString = builder.toStringO ; 输入与输出 可见输入与不可见输入 12//可见输入Scanner in = new Scanner(System.in); nextLine 方法将输入一行。 12System.out.print(\"What is your name? \");String name = in.nextLine(); 在这里，使用nextLine 方法是因为在输人行中有可能包含空格。要想读取一个单词（以空白符作为分隔符)，就调用 1String firstName = in.nextO； 要想读取一个整数， 就调用nextlnt 方法。 12System.out.print(\"How old are you? \")；int age = in.nextlntO; 因为输入是可见的， 所以Scanner 类不适用于从控制台读取密码。Java SE 6 特别引入了Console 类实现这个目的。要想读取一个密码， 可以采用下列代码： 123Console cons = System.console();String username = cons.readLine(\"User name: \")；cha「[] passwd = cons.readPassword(\"Password:\"); 为了安全起见， 返回的密码存放在一维字符数组中， 而不是字符串中。在对密码进行处理之后， 应该马上用一个填充值覆盖数组元素 流程控制 块作用域 c++支持在嵌套的块中声明同一变量，但是Java不允许这么做 数组 声明并创建一个数组 1int[] a = new int[100]; 创建一个数字数组时， 所有元素都初始化为0。boolean 数组元素会初始化为false,对象数组的元素则初始化为一个特殊值null, 这表示这些元素（还）未存放任何对象。初学者对此可能有些不解。例如， 1String[] names = new String[10]; 会创建一个包含10 个字符串的数组， 所有字符串都为null。 打印数组中元素可以利用toString()方法，转化为字符串直接输出；也可以利用循环一个个打印 拷贝数组C++ 注释： Java 数组与C++ 数组在堆栈上有很大不同， 但基本上与分配在堆（heap) 上的数组指针一样。也就是说， 1int[] a = new int[100]; // Java 不同于 1int a[100]; // C++ 而等同于 1int* a = new int[100]; // C++ 注意：Java 中的[ ]运算符被预定义为检查数组边界，而且没有指针运算，即不能通过a加1得到数组的下一个元素。 多维数组Java 实际上没有多维数组， 只有一维数组。多维数组被解释为“ 数组的数组。”C++ 注释： 在C++ 中， Java 声明 1doublet] [] balances = new double[10] [6]; // 3ava 不同于 1double balances[10] [6] ; // C++ 也不同于 1double (*balances) [6] = new double[10] [6] ; // C++ 而是分配了一个包含10 个指针的数组： 1double** balances = new double*[10]; // C++","tags":[{"name":"基础","slug":"基础","permalink":"http://www.allenmistake.top/tags/基础/"}]},{"title":"Leetcode日记：39.组合之和","date":"2018-12-05T17:00:00.000Z","path":"2018/12/06/leetcode39/","text":"题目给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1:123456输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 示例 2:1234567输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 分析又是一个所有满足条件的排列组合，还是用我们熟悉的递归，我的递归是弱项，所以我会多练习一些这方面的题。这里我们新加入三个变量，start记录当前的递归到的下标，out为一个解，res保存所有已经得到的解，每次调用新的递归函数时，此时的target要减去当前数组的的数，具体看代码如下： 我们也可以用迭代的解法来做，建立一个三维数组dp，这里dp[i]表示目标数为i的所有解法集合。这里的i就从1遍历到target即可，对于每个i，我们都新建一个二维数组cur，然后遍历candidates数组，如果遍历到的数字大于i，说明当前及之后的数字都无法组成i，直接break掉。否则如果相等，那么把当前数字自己组成一个数组，并且加到cur中。否则就遍历dp[i - candidates[j] - 1] 中的所有数组，如果当前数字大于数组的首元素，则跳过，因为我们的结果要求是要有序的。否则就将当前数字加入数组的开头，并且将数组放入cur之中即可，参见代码如下 代码初始代码12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt; &amp;candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(candidates.begin(), candidates.end()); combinationSumDFS(candidates, target, 0, &#123;&#125;, res); return res; &#125; void combinationSumDFS(vector&lt;int&gt; &amp;candidates, int target, int start, vector&lt;int&gt; out, vector&lt;vector&lt;int&gt;&gt; &amp;res) &#123; if (target &lt; 0) return; else if (target == 0) &#123; res.push_back(out); return; &#125; for (int i = start; i &lt; candidates.size(); ++i) &#123; out.push_back(candidates[i]); combinationSumDFS(candidates, target - candidates[i], i, out, res); out.pop_back(); &#125; &#125;&#125;; 迭代三维数组123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt; &amp;candidates, int target) &#123; vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp; sort(candidates.begin(), candidates.end()); for (int i = 1; i &lt;= target; ++i) &#123; vector&lt;vector&lt;int&gt;&gt; cur; for (int j = 0; j &lt; candidates.size(); ++j) &#123; if (candidates[j] &gt; i) break; else if (candidates[j] == i) &#123;cur.push_back(&#123;candidates[j]&#125;); continue;&#125; for (auto a : dp[i - candidates[j] - 1]) &#123; if (candidates[j] &gt; a[0]) continue; a.insert(a.begin(), candidates[j]); cur.push_back(a); &#125; &#125; dp.push_back(cur); &#125; return dp[target - 1]; &#125;&#125;; 分析其实思路都是一样的，主要找准利用移位操作来实现除法操作。详细见思路部分。","tags":[{"name":"递归","slug":"递归","permalink":"http://www.allenmistake.top/tags/递归/"},{"name":"数组","slug":"数组","permalink":"http://www.allenmistake.top/tags/数组/"},{"name":"DFS","slug":"DFS","permalink":"http://www.allenmistake.top/tags/DFS/"}]},{"title":"11月学习总结","date":"2018-12-01T17:00:00.000Z","path":"2018/12/02/monthlysummary/","text":"所做工作这个月月初搭建了自己的个人博客，用的jekyll静态网页来布局Github Page，也感受到了前端魔法般的魅力。好多人都说前端未来会被AI所代替，但好的UI和交互设计AI是学不来的，只有人才会了解人。在这之后就开始慢慢的总结一些Leetcode刷题日记，这些代码大多数并不是本人写的，都是在网上借鉴的，但能把别人的东西消化吸收，总结出自己的一份感悟，也是一种收获吧。总结心得还是原创的，目的还是为了吸收知识。 11月份总共写了11篇博客，其中两篇是关于jekyll中的体会与心得，其他9篇是Leetcode日记，分析并总结了共11道题，进度很慢，但是刚刚起步，总要有一个过程，时间还早。 其实进度拖沓的原因是因为月末生了场病，而且现在还没有恢复，导致没有精力顾暇Leetcode这边。 内容分析 3.最长不重复子串 是一个关于字符串的问题，其中的算法逻辑与哈希表的数据结构运用都很巧妙 4.求中位数是这个月唯一的一道hard题，考察了对递归的运用和二分法的掌握情况 6.z字形变换和12&amp;13.罗马数字转换偏向于观察逻辑关系，考察对数组/字符串的理解和巧妙用法 15.三数之和是两数之和的升级版，如何将位置问题转化成已知问题，这里调用自带函数sort显得尤为重要。 24.括号匹配是一道很重要的题目，牵扯到了很多知识点，例如递归与回溯剪枝、DFS，要多多回味。 29.两数相除是一道很特别的题，核心思想是位操作，如何利用位操作完成四则运算，需要把握其中的逻辑。 最后，总结一下本个月重要的三道题 三数之和、求中位数、括号匹配 展望12月份是期末备战的一个月，Lettcode的时间估计又要有所缩减，不过在什么阶段就要做什么事情，休息一下未尝是件坏事。 winter is coming…","tags":[]},{"title":"Leetcode日记：29.两数相除","date":"2018-11-30T17:00:00.000Z","path":"2018/12/01/leetcode29/","text":"题目给定两个整数，被除数dividend和除数divisor。将两数相除，要求不使用乘法、除法和mod运算符。 返回被除数dividend除以除数divisor得到的商。 示例 1:12输入: dividend = 10, divisor = 3输出: 3 示例 2:12输入: dividend = 7, divisor = -3输出: -2 说明: 被除数和除数均为 32 位有符号整数。 除数不为 0。 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。 分析这道题让我们求两数相除，而且规定我们不能用乘法，除法和取余操作，那么我们还可以用另一神器——位操作（Bit Operation）。 思路是，如果被除数大于或等于除数，则进行如下循环，定义变量t等于除数，定义计数p，当t的两倍小于等于被除数时，进行如下循环，t扩大一倍，p扩大一倍，然后更新res和m。这道题的OJ给的一些test case非常的讨厌，因为输入的都是int型，比如被除数是-2147483648，在int范围内，当除数是-1时，结果就超出了int范围，需要返回INT_MAX，所以对于这种情况我们就在开始用if判定，将其和除数为0的情况放一起判定，返回INT_MAX。然后我们还要根据被除数和除数的正负来确定返回值的正负，这里我们采用长整型long来完成所有的计算，最后返回值乘以符号即可，代码如下： 代码初始代码12345678910111213141516171819class Solution &#123;public: int divide(int dividend, int divisor) &#123; if (divisor == 0 || (dividend == INT_MIN &amp;&amp; divisor == -1)) return INT_MAX; long long m = abs((long long)dividend), n = abs((long long)divisor), res = 0; int sign = ((dividend &lt; 0) ^ (divisor &lt; 0)) ? -1 : 1; if (n == 1) return sign == 1 ? m : -m; while (m &gt;= n) &#123; long long t = n, p = 1; while (m &gt;= (t &lt;&lt; 1)) &#123; t &lt;&lt;= 1; p &lt;&lt;= 1; &#125; res += p; m -= t; &#125; return sign == 1 ? res : -res; &#125;&#125;; 简化后的代码123456789101112131415161718class Solution &#123;public: int divide(int dividend, int divisor) &#123; long long m = abs((long long)dividend), n = abs((long long)divisor), res = 0; if (m &lt; n) return 0; while (m &gt;= n) &#123; long long t = n, p = 1; while (m &gt; (t &lt;&lt; 1)) &#123; t &lt;&lt;= 1; p &lt;&lt;= 1; &#125; res += p; m -= t; &#125; if ((dividend &lt; 0) ^ (divisor &lt; 0)) res = -res; return res &gt; INT_MAX ? INT_MAX : res; &#125;&#125;; 递归法12345678910111213141516class Solution &#123;public: int divide(int dividend, int divisor) &#123; long long res = 0; long long m = abs((long long)dividend), n = abs((long long)divisor); if (m &lt; n) return 0; long long t = n, p = 1; while (m &gt; (t &lt;&lt; 1)) &#123; t &lt;&lt;= 1; p &lt;&lt;= 1; &#125; res += p + divide(m - t, n); if ((dividend &lt; 0) ^ (divisor &lt; 0)) res = -res; return res &gt; INT_MAX ? INT_MAX : res; &#125;&#125;; 分析其实思路都是一样的，主要找准利用移位操作来实现除法操作。详细见思路部分。","tags":[{"name":"位操作","slug":"位操作","permalink":"http://www.allenmistake.top/tags/位操作/"}]},{"title":"Leetcode日记：24.括号的生成","date":"2018-11-22T17:00:00.000Z","path":"2018/11/23/leetcode24/","text":"题目给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为：1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 分析方法一：暴力法（递归）思路 我们可以生成所有 $2^{2n}$ 个 &#39;(&#39; 和&#39;)&#39; 字符构成的序列。然后，我们将检查每一个是否有效。 算法 为了生成所有序列，我们使用递归。长度为 n 的序列就是&#39;(&#39;加上所有长度为 n-1 的序列，以及&#39;)&#39;加上所有长度为 n-1 的序列。 为了检查序列是否为有效的，我们会跟踪平衡，也就是左括号的数量减去右括号的数量的净值。如果这个值始终小于零或者不以零结束，该序列就是无效的，否则它是有效的。 方法一改进版：递归法这道题给定一个数字n，让生成共有n个括号的所有正确的形式，对于这种列出所有结果的题首先还是考虑用递归Recursion来解，由于字符串只有左括号和右括号两种字符，而且最终结果必定是左括号3个，右括号3个，所以我们定义两个变量left和right分别表示剩余左右括号的个数，如果在某次递归时，左括号的个数大于右括号的个数，说明此时生成的字符串中右括号的个数大于左括号的个数，即会出现’)(‘这样的非法串，所以这种情况直接返回，不继续处理。如果left和right都为0，则说明此时生成的字符串已有3个左括号和3个右括号，且字符串合法，则存入结果中后返回。如果以上两种情况都不满足，若此时left大于0，则调用递归函数，注意参数的更新，若right大于0，则调用递归函数，同样要更新参数。 这种递归的方法和第一种暴力法很像，核心思想都是先产生字符串，一旦不符合规则立刻舍弃，但是这样会增加时间复杂度，我们可以直接产生符合要求的字符串，然后添加到vector中，这就需要我们有一个比较严谨的逻辑条件。请看方法二 方法二：回溯法（重点掌握）思路和算法类似于此题，要求解出所有的排列组合，我们优先考虑递归法或者回溯法只有在我们知道序列仍然保持有效时才添加&#39;(&#39;or&#39;)&#39;，而不是像方法一那样每次添加。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点， 如果我们还剩一个位置，我们可以开始放一个左括号。 如果它不超过左括号的数量，我们可以放一个右括号。 方法三：闭合法思路 为了枚举某些内容，我们通常希望将其表示为更容易计算的不相交子集的总和。 考虑有效括号序列 S 的闭包数：至少存在index&gt; = 0，使得S[0], S[1], ..., S[2*index+1]是有效的。 显然，每个括号序列都有一个唯一的闭包号。 我们可以尝试单独列举它们。 算法 对于每个闭合数c，我们知道起始和结束括号必定位于索引0和2*c + 1。然后两者间的2*c个元素一定是有效序列，其余元素一定是有效序列。 代码法一：暴力法（java）1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; combinations = new ArrayList(); generateAll(new char[2 * n], 0, combinations); return combinations; &#125; public void generateAll(char[] current, int pos, List&lt;String&gt; result) &#123; if (pos == current.length) &#123; if (valid(current)) result.add(new String(current)); &#125; else &#123; current[pos] = '('; generateAll(current, pos+1, result); current[pos] = ')'; generateAll(current, pos+1, result); &#125; &#125; public boolean valid(char[] current) &#123; int balance = 0; for (char c: current) &#123; if (c == '(') balance++; else balance--; if (balance &lt; 0) return false; &#125; return (balance == 0); &#125;&#125;def generateParenthesis(self, N): if N == 0: return [''] ans = [] for c in xrange(N): for left in self.generateParenthesis(c): for right in self.generateParenthesis(N-1-c): ans.append('(&#123;&#125;)&#123;&#125;'.format(left, right)) return ans 法一改进版：递归法12345678910111213141516class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; res; generateParenthesisDFS(n, n, \"\", res); return res; &#125; void generateParenthesisDFS(int left, int right, string out, vector&lt;string&gt; &amp;res) &#123; if (left &gt; right) return; if (left == 0 &amp;&amp; right == 0) res.push_back(out); else &#123; if (left &gt; 0) generateParenthesisDFS(left - 1, right, out + '(', res); if (right &gt; 0) generateParenthesisDFS(left, right - 1, out + ')', res); &#125; &#125;&#125;; 法二：回溯法（java）12345678910111213141516171819class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; ans = new ArrayList(); backtrack(ans, \"\", 0, 0, n); return ans; &#125; public void backtrack(List&lt;String&gt; ans, String cur, int open, int close, int max)&#123; if (cur.length() == max * 2) &#123; ans.add(cur); return; &#125; if (open &lt; max) backtrack(ans, cur+\"(\", open+1, close, max); if (close &lt; open) backtrack(ans, cur+\")\", open, close+1, max); &#125;&#125; 法三：闭合法1234567891011121314class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; ans = new ArrayList(); if (n == 0) &#123; ans.add(\"\"); &#125; else &#123; for (int c = 0; c &lt; n; ++c) for (String left: generateParenthesis(c)) for (String right: generateParenthesis(n-1-c)) ans.add(\"(\" + left + \")\" + right); &#125; return ans; &#125;&#125; 个人总结递归与回溯的区别递归：为了描述问题的某一状态，必须用到该状态的上一状态，而描述上一状态，又必须用到上一状态的上一状态……这种用自已来定义自己的方法，称为递归定义。形式如 f(n) = n*f(n-1), if n=0,f(n)=1. 解答树角度：在dfs遍历一棵解答树 优点：结构简洁 缺点：效率低，可能栈溢出递归一般结构：1234567891011void f() &#123; if(符合边界条件) &#123; /////// return; &#125; //某种形式的调用 f(); &#125; 回溯：从问题的某一种可能出发, 搜索从这种情况出发所能达到的所有可能, 当这一条路走到” 尽头 “的时候, 再倒回出发点, 从另一个可能出发, 继续搜索. 这种不断” 回溯 “寻找解的方法, 称作” 回溯法 “。递归的一种，或者说是通过递归这种代码结构来实现回溯这个目的。回溯法可以被认为是一个有过剪枝的DFS过程。 解答树角度：带回溯的dfs遍历一棵解答树 回溯的一般结构：123456789101112131415161718void dfs(int 当前状态) &#123; if(当前状态为边界状态) &#123; 记录或输出 return; &#125; for(i=0;i&lt;n;i++) //横向遍历解答树所有子节点 &#123; //扩展出一个子状态。 修改了全局变量 if(子状态满足约束条件) &#123; dfs(子状态) &#125; 恢复全局变量//回溯部分 &#125; &#125; DFS与BFSBFS：Breadth-First-Search，宽度优先搜索；BFS是从root开始扩展，每一层都是精密的搜索完整了才下一个 DFS：Depth-first search，深度优先搜索。DFS主要的特性是深度优先，总是不停的往下找，走到没路才罢休。 关于此题这道题就是灵活运用递归和回溯，可以看出来我们有两次判断，一个判断就是如果括号有n组，那么左括号一定不能大于n，而且，当左括号数量大于右括号时，我们开始有了分类，可以继续插入左括号（如果满足条件一的话），也可以插入右括号。核心的思想还是要想到递归。关于列出所有排列组合的情况，优先考虑递归回溯。","tags":[{"name":"DFS","slug":"DFS","permalink":"http://www.allenmistake.top/tags/DFS/"},{"name":"回溯","slug":"回溯","permalink":"http://www.allenmistake.top/tags/回溯/"}]},{"title":"Jekyll&latex使用技巧","date":"2018-11-17T17:00:00.000Z","path":"2018/11/18/jekyllskill/","text":"jekyll常见问题与解决方法双花括号首先，在jekyll中双花括号是由其自身含义的，如果你不是因为jekyll而编写的双花括号， 需要加入下面语句 123&#123;% raw %&#125;//要编写的代码，其中也许会包含&apos;&#123;&#123;&apos;，类似的双花括号&#123;% endraw %&#125; 这两行代码的意思就是让中间的代码块不翻译成jekyll语言，所以jekyll独有的语法在这个区域中全部失效。 插入图片1![题目图片](&#123;&#123;site.url&#125;&#125;/assets/img/leetcode11.jpg) latex的常用公式与语法使用latex的前提是加入下面标识 1$在此键入公式$ 上标与下标1$a^2*b_2$ 出来的效果就是这样的：$a^2*b_2$ 备注这个帮助文档时不时更新，当遇到jekyll、latex相关问题时，将解决办法总结出来，以便之后查阅。","tags":[{"name":"其他","slug":"其他","permalink":"http://www.allenmistake.top/tags/其他/"}]},{"title":"Leetcode日记：12&13.整型与罗马数字的相互转化","date":"2018-11-16T17:00:00.000Z","path":"2018/11/17/leetcode12&13/","text":"12.整型to罗马数字题目Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol ValueI 1V 5X 10L 50C 100D 500M 1000For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1:12Input: 3Output: &quot;III&quot; Example 2:12Input: 4Output: &quot;IV&quot; Example 3:12Input: 9Output: &quot;IX&quot; Example 4:123Input: 58Output: &quot;LVIII&quot;Explanation: L = 50, V = 5, III = 3. Example 5:123Input: 1994Output: &quot;MCMXCIV&quot;Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 分析我们将每一个罗马字母与相对象的数字存放在两个数组中，因为限制了输入本身的整型数字大小，所以我们直接依次除以每一位代表的整数，注意4和9这两个数有特殊的逻辑编写方式。综合考虑，逻辑是 从高位开始除以罗马数字M-&gt;I，（设当前罗马位为$\\alpha$）得到结果x 如果x小于4，说明可以用该位的罗马数字重复表示（$\\alpha*n$）（例如，3000就是MMM） 如果x等于4，那就是$\\alpha-1,\\alpha$（例如IV） 如果x大于4小于九，那就是$\\alpha，\\alpha*n$（例如VIII） 如果x等于9，便是$\\alpha-2，\\alpha$（例如IX） 取余，继续迭代 其实，这个动手稍微算一下，总结一下规律，还是比较好明白这里面的逻辑规律的，只是用眼看反而不容易看出来。 但是我们还有一种算法，简化代码，首先，不觉得把4和9单独拿出来判断过于繁琐了么，干脆就把所有的4和9的情况也写进数组，这样就完全依靠数组来来判断，而不需要再写那么多else if，看起来很麻烦。这里其实是一个很简单的贪婪算法，既然这里谈到了贪心算法，我们不如就来了解一下 贪心算法贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止 其实可以发现，贪心算法的优点在于代码简洁，比较傻瓜，但是不一定是最优解。但是此题我们不需要考虑最优解这个问题，在这道题的应用，即我们只考虑当前最高位，检测当前最高位是否大于我们数组中预设的最高位，如果是，则减去最高位，并且字符串添加一次最高位，因为数组中设置了4和9，我们也不用担心4被忽略 代码一般解法1234567891011121314151617181920212223242526class Solution &#123;public: string intToRoman(int num) &#123; string res = \"\"; char roman[] = &#123;'M', 'D', 'C', 'L', 'X', 'V', 'I'&#125;; int value[] = &#123;1000, 500, 100, 50, 10, 5, 1&#125;; for (int n = 0; n &lt; 7; n += 2) &#123; int x = num / value[n]; if (x &lt; 4) &#123; for (int i = 1; i &lt;= x; ++i) res += roman[n]; &#125; else if (x == 4) res = res + roman[n] + roman[n - 1]; else if (x &gt; 4 &amp;&amp; x &lt; 9) &#123; res += roman[n - 1]; for (int i = 6; i &lt;= x; ++i) res += roman[n]; &#125; else if (x == 9) res = res + roman[n] + roman[n - 2]; num %= value[n]; &#125; return res; &#125;&#125;; 贪婪算法123456789101112131415class Solution &#123;public: string intToRoman(int num) &#123; string res = \"\"; vector&lt;int&gt; val&#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;; vector&lt;string&gt; str&#123;\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"&#125;; for (int i = 0; i &lt; val.size(); ++i) &#123; while (num &gt;= val[i]) &#123; num -= val[i]; res += str[i]; &#125; &#125; return res; &#125;&#125;; 13.罗马数字to整型示例 1:12输入: &quot;III&quot;输出: 3 示例 2:12输入: &quot;IV&quot;输出: 4 示例 3:12输入: &quot;IX&quot;输出: 9 示例 4:123输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3. 示例 5:123输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. Follow up:Coud you solve it without converting the integer to a string? 分析提示： 相同的数字连写，所表示的数等于这些数字相加得到的数，如：Ⅲ = 3； 小的数字在大的数字的右边，所表示的数等于这些数字相加得到的数， 如：Ⅷ = 8；Ⅻ = 12； 小的数字，（限于Ⅰ、X 和C）在大的数字的左边，所表示的数等于大数减小数得到的数，如：Ⅳ= 4；Ⅸ= 9； 正常使用时，连写的数字重复不得超过三次。（表盘上的四点钟“IIII”例外） 在一个数的上面画一条横线，表示这个数扩大1000倍。 有几条须注意掌握： 基本数字Ⅰ、X 、C 中的任何一个，自身连用构成数目，或者放在大数的右边连用构成数目，都不能超过三个；放在大数的左边只能用一个。 不能把基本数字V 、L 、D 中的任何一个作为小数放在大数的左边采用相减的方法构成数目；放在大数的右边采用相加的方式构成数目，只能使用一个。 V 和X 左边的小数字只能用Ⅰ。 L 和C 左边的小数字只能用X。 D 和M 左边的小数字只能用C。 而这道题好就好在没有让我们来验证输入字符串是不是罗马数字，这样省掉不少功夫。我们需要用到map数据结构，来将罗马数字的字母转化为对应的整数值，因为输入的一定是罗马数字，那么我们只要考虑两种情况即可：第一，如果当前数字是最后一个数字，或者之后的数字比它小的话，则加上当前数字第二，其他情况则减去这个数字 代码12345678910111213class Solution &#123;public: int romanToInt(string s) &#123; int res = 0; unordered_map&lt;char, int&gt; m&#123;&#123;'I', 1&#125;, &#123;'V', 5&#125;, &#123;'X', 10&#125;, &#123;'L', 50&#125;, &#123;'C', 100&#125;, &#123;'D', 500&#125;, &#123;'M', 1000&#125;&#125;; for (int i = 0; i &lt; s.size(); ++i) &#123; int val = m[s[i]]; if (i == s.size() - 1 || m[s[i+1]] &lt;= m[s[i]]) res += val; else res -= val; &#125; return res; &#125;&#125;; 个人总结这两道题虽然题目很一样，但是所采用的逻辑结构是完全不一样的。整型转化成罗马数字所采用的是数字拆分，我们可以选择像7&amp;9一样的除法提取每一位，但是由于罗马数字的特殊逻辑，需要再判断中添加循环，来重复打印；而像方法2选择减法拆分直接将循环充分利用，很是巧妙。 第二道题则利用了map的对应关系，当然这个也可以将4和9考虑进来，只不过对程序的化简起不到太大作用，（采用4和9仍要判断是否要判断下一位）。","tags":[{"name":"字符串","slug":"字符串","permalink":"http://www.allenmistake.top/tags/字符串/"},{"name":"贪心算法","slug":"贪心算法","permalink":"http://www.allenmistake.top/tags/贪心算法/"}]},{"title":"Leetcode日记：7&9.翻转整数&判断回文数","date":"2018-11-13T17:00:00.000Z","path":"2018/11/14/leecode7&9/","text":"7.翻转整数题目Reverse digits of an integer. Example1: 1x = 123, return 321 Example2: 1x = -123, return -321 分析这是一道相当经典的算法题，题目本身不难，看你自己考虑的是否全面，需要考虑的有几个问题 变换数字问题，是由int转化为int，溢出问题如何避免与检测？ 需要对整数的每一位进行提取，如何编写代码？ 思路面对上面的两个问题 首先，溢出问题的解决我们可以用一个long long型的变量来存放翻转过程的数，最后检查如果输出的结果溢出(res &gt; INT_MAX || res &lt; INT_MIN），这边是我们滴水不漏版的答案。但是我们思考因为输入的x也是一个整型数，所以x的范围也应该在 -2147483648～2147483647 之间，那么x的第一位只能是1或者2，翻转之后res的最后一位只能是1或2，所以res只能是 2147483641 或 2147483642 都在int的范围内。但是它们对应的x为 1463847412 和 2463847412，后者超出了数值范围。所以当过程中res等于 214748364 时， 输入的x只能为 1463847412， 翻转后的结果为 2147483641，都在正确的范围内，所以不用check。这便是官方给出的精简版。 无论是哪个版本，提取每一位的方法都是一样的，顺序是从低位往高位取，例如123456，我们先对他进行取余=6，提取出最后一位，再把123456整体除以10，将最后一位抹去，循环往复。 代码滴水不漏版1234567891011class Solution &#123;public: int reverse(int x) &#123; long long res = 0; while (x != 0) &#123; res = 10 * res + x % 10; x /= 10; &#125; return (res &gt; INT_MAX || res &lt; INT_MIN) ? 0 : res; &#125;&#125;; 官方精简版12345678910111213class Solution &#123;public: int reverse(int x) &#123; int res = 0; while (x != 0) &#123; if (abs(res) &gt; INT_MAX / 10) return 0; res = res * 10 + x % 10; x /= 10; &#125; return res; &#125;&#125;; 9.判断回文数Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. `Example 1:12Input: 121Output: true Example 2:123Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3:123Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up:Coud you solve it without converting the integer to a string? 分析首先只要是负数就一定不是回文数，可以首先排除；然后就是找第1位和对应的第n位，这里提供了一种思路就是首先用n次循环计算出位数，然后 $\\text{div}=10^n$，设立这个数的目的是为了找到前向位，后向位我们通过上面的翻转整数（取余）很快得到。 代码1234567891011121314151617class Solution &#123;public: bool isPalindrome(int x) &#123; if (x &lt; 0) return false; int div = 1; while (x / div &gt;= 10) div *= 10; while (x &gt; 0) &#123; int left = x / div; int right = x % 10; if (left != right) return false; x = (x % div) / 10; div /= 100; &#125; return true; &#125;&#125;; 个人总结这两道题都是很经典的入门题，涉及到的只是不多 int类型溢出判断 整数得到每一位数 这两个是很基础的知识，以后可能会经常用到，今天两道题不涉及特殊的数据结构，所以可说的不多，继续努力吧。感觉easy题以后要是明白的话没必要在往博客上写了。","tags":[{"name":"整数","slug":"整数","permalink":"http://www.allenmistake.top/tags/整数/"}]},{"title":"Leetcode日记：6.Z字形变换","date":"2018-11-12T17:00:00.000Z","path":"2018/11/13/leetcode6/","text":"题目给定一个字符串，找出不含有重复字符的最长子串的长度。示例 1: 123456输入: s = &quot;PAYPALISHIRING&quot;, numRows = 3输出: &quot;PAHNAPLSIIGYIR&quot;解释：P A H NA P L S I I GY I R 示例 2: 123456输入: s = &quot;PAYPALISHIRING&quot;, numRows = 4输出: &quot;PINALSIGYAHRPI&quot;解释:P I NA L S I GY A H RP I 分析这道题有两种解法，一种是利用数学表达式计算出行数与元素排布位置的联系，用数学表达式表达出，不过这并不是我们想要的最优解，或者说，他并不优雅，因为没有体现出算法的美感，只是单纯的找规律了。 所以我们想，能不能不靠找规律，准备一个数组与之对应： 思路通过从左向右迭代字符串，我们可以轻松地确定字符位于 Z 字形图案中的哪一行。 算法我们可以使用 $\\min(numRows,n)$ 个列表来表示 Z 字形图案中的非空行。从左到右迭代，将每个字符添加到合适的行。可以使用当前行和当前方向这两个变量对合适的行进行跟踪。只有当我们向上移动到最上面的行或向下移动到最下面的行时，当前方向才会发生改变。 代码123456789101112131415161718192021222324class Solution &#123;public: string convert(string s, int numRows) &#123; if (numRows == 1) return s; vector&lt;string&gt; rows(min(numRows, int(s.size()))); int curRow = 0; bool goingDown = false; for (char c : s) &#123; rows[curRow] += c; if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown; curRow += goingDown ? 1 : -1; &#125; string ret; for (string row : rows) ret += row; return ret; &#125;&#125;; 代码运行过程以&quot;PAYPALISHIRING&quot;numRows=3为例： 我们首先把行数，元素数两者最小那个当做划分区域（通常都是行数小），这样我们就分成了numRows=3组，很自然，我们把前三个元素依次放到，第1、2、3组中，注意，当我们触底（curRows=3）时，需要回溯（减小curRows），所以我们创建了变量goingdown，来控制是向上还是向下。 而且只需要遍历一次，下面以goingdown的改变来分组 元素0-2 第一组：P 第二组：A 第三组：Y 元素3-4 第一组：PA 第二组：AP 第三组：Y 元素5-6 第一组：PA 第二组：APL 第三组：YI 依次类推，很容易明白其中规律 个人总结其实数学规律很容易想到，但是代码可能可能不是很容易写出来，但是上面的这种算法，很直观，为什么不容易想到呢，我认为是思维受到了限制，我们很容易地就直接造出一个与原数组等长的数组，一个一个往上去添加，但是我们可以先靠行分类，然后改变数值放入的顺序。 本体值得注意的有 123vector&lt;string&gt; rows(min(numRows, int(s.size())));···rows[curRow] += c; vector中的元素类型是String，这一点很巧妙，这样只需要一个加号，就能在结尾添加新字符。 12goingDown = !goingDown;curRow += goingDown ? 1 : -1; 能把代码写到如此简洁需要一个过程，当然，简单点的话可以写一个判断来改变goingdown的值 最重要的思想还是通过控制curRow的步进方向，来实现Z字形变换","tags":[{"name":"数组","slug":"数组","permalink":"http://www.allenmistake.top/tags/数组/"}]},{"title":"Leetcode日记：4.两个有序数组的中位数","date":"2018-11-09T17:00:00.000Z","path":"2018/11/10/leetcode4/","text":"题目There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty.Example 1: 12nums1 = [1, 3]nums2 = [2] The median is 2.0Example 2: 12nums1 = [1, 2]nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 分析要求很简单，给定两个不全为空的数组，求他们两个数组合在一起后的中位数，首先，我们要直到 中位数是什么？ 回顾一下中位数的定义，如果某个有序数组长度是奇数，那么其中位数就是最中间那个，如果是偶数，那么就是最中间两个数字的平均值。 我们要明确，这道题是给定了时间复杂度了的，即O(log (m+n))，是一个log复杂度，所以肯定不是遍历。其实看到log很容易想到二分法，但是如何在两个数组中利用二分法求中位数呢？假设两个有序数组的长度分别为m和n，由于两个数组长度之和 m+n 的奇偶不确定，因此需要分情况来讨论，对于奇数的情况，直接找到最中间的数即可，偶数的话需要求最中间两个数的平均值。为了简化代码，不分情况讨论，我们使用一个小trick，我们分别找第 (m+n+1) / 2 个，和 (m+n+2) / 2 个，然后求其平均值即可，这对奇偶数均适用。加入 m+n 为奇数的话，那么其实 (m+n+1) / 2 和 (m+n+2) / 2 的值相等，相当于两个相同的数字相加再除以2，还是其本身。 详细讲解可以仔细研读官方给出的解决方案，这里只说几个重点好，这里我们需要定义一个函数来在两个有序数组中找到第K个元素，下面重点来看如何实现找到第K个元素。 降低复杂度的特殊情况首先，为了避免产生新的数组从而增加时间复杂度，我们使用两个变量i和j分别来标记数组nums1和nums2的起始位置。然后来处理一些corner cases（边缘情况），比如当某一个数组的起始位置大于等于其数组长度时，说明其所有数字均已经被淘汰了，相当于一个空数组了，那么实际上就变成了在另一个数组中找数字，直接就可以找出来了。还有就是如果K=1的话，那么我们只要比较nums1和nums2的起始位置i和j上的数字就可以了。 对谁进行二分？难点就在于一般的情况怎么处理？因为我们需要在两个有序数组中找到第K个元素，为了加快搜索的速度，我们要使用二分法，那么对谁二分呢，数组么？其实要对K二分，意思是我们需要分别在nums1和nums2中查找第K/2个元素，注意这里由于两个数组的长度不定，所以有可能某个数组没有第K/2个数字，所以我们需要先check一下，数组中到底存不存在第K/2个数字，如果存在就取出来，否则就赋值上一个整型最大值。如果某个数组没有第K/2个数字，那么我们就淘汰另一个数字的前K/2个数字即可。有没有可能两个数组都不存在第K/2个数字呢，这道题里是不可能的，因为我们的K不是任意给的，而是给的m+n的中间值，所以必定至少会有一个数组是存在第K/2个数字的。 二分法最后就是二分法的核心啦，比较这两个数组的第K/2小的数字midVal1和midVal2的大小，如果第一个数组的第K/2个数字小的话，那么说明我们要找的数字肯定不在nums1中的前K/2个数字，所以我们可以将其淘汰，将nums1的起始位置向后移动K/2个，并且此时的K也自减去K/2，调用递归。反之，我们淘汰nums2中的前K/2个数字，并将nums2的起始位置向后移动K/2个，并且此时的K也自减去K/2，调用递归即可，参见代码如下： 代码12345678910111213141516171819class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(), n = nums2.size(), left = (m + n + 1) / 2, right = (m + n + 2) / 2; return (findKth(nums1, 0, nums2, 0, left) + findKth(nums1, 0, nums2, 0, right)) / 2.0; &#125; int findKth(vector&lt;int&gt;&amp; nums1, int i, vector&lt;int&gt;&amp; nums2, int j, int k) &#123; if (i &gt;= nums1.size()) return nums2[j + k - 1]; if (j &gt;= nums2.size()) return nums1[i + k - 1]; if (k == 1) return min(nums1[i], nums2[j]); int midVal1 = (i + k / 2 - 1 &lt; nums1.size()) ? nums1[i + k / 2 - 1] : INT_MAX; int midVal2 = (j + k / 2 - 1 &lt; nums2.size()) ? nums2[j + k / 2 - 1] : INT_MAX; if (midVal1 &lt; midVal2) &#123; return findKth(nums1, i + k / 2, nums2, j, k - k / 2); &#125; else &#123; return findKth(nums1, i, nums2, j + k / 2, k - k / 2); &#125; &#125;&#125;; 代码运行过程我们假设两个有序数组分别是num1：[1，5，6，9]num2：[3，7，8]那么我们带入到上述代码中运行，观察运行情况 首先，我们根据两个数组总长度确定left=4和right=4。 计算(num1，i=0，num2，j=0，k=4)我们先不管前三个特殊判断，直接看接下来的赋值， 第一次迭代midVal1=5，midVal2=7（位置i+k/2-1）然后比较大小midVal1与midVal2的大小，小的元素所在的数组(i=i+k/2)继续带入（num1，i=2，num2，j=0，k=k-k/2=2） 第二次迭代midVal1=6，midVal2=3（大的元素随着k的减小而往前收缩），（num1，i=2，num2，j=1，k=k-k/2=1） 第三次迭代，此时k等于1，执行特殊判断(3)，num1[i=2]=6，num2[j=1]=7，取最小值6，找到。 我们再来看一个例子：num1：[6]num2：[1，5，7，8，10] 初始化：left=3，right=4 首先计算left分支（k=3）： i=0，j=0，k=3；均取头元素，num1[0]&gt;num2[0]，j=k/2，k=k-k/2 i=0，j=1，k=2，num1[0]&gt;num2[1]，j=k/2，k=k-k/2 k=1，return min(6,7)=6； 下面计算right分支（k=4）: i=0，j=0，k=4；此时并无i+k/2-1，所以设置midVal1=无穷，这样midVal2一定是比较小的，j=k/2，k=k-k/2 i=0，j=2，k=2；此时midVal1收缩到num1[0]，与num2[2]比较 i=1，j=2，k=1，此时i=num1.size()，执行第一判断，return num2[2]=7 所以最后结果是（6+7）/2 总结可以看出，有些限制复杂度的题，更是给了我们足够的提示，log（m+n）代表不能遍历数组，而且需要二分，如何将二分和中位数的判断紧密的结合起来，是个难题。也是这道题在Leetcode处于Hard的原因， 首先，我们要掌握二分法在两个数组中的处理方式 判断好边界情况 参考内容 [LeetCode] Median of Two Sorted Arrays 两个有序数组的中位数 Leetcode官方解法","tags":[{"name":"递归","slug":"递归","permalink":"http://www.allenmistake.top/tags/递归/"}]},{"title":"Leetcode日记：3.最长不重复子串","date":"2018-11-08T17:00:00.000Z","path":"2018/11/09/leetcode3/","text":"题目给定一个字符串，找出不含有重复字符的最长子串的长度。示例 1: 123输入: &quot;abcabcbb&quot;输出: 3解释: 无重复字符的最长子串是 &quot;abc&quot;，其长度为 3。 示例 2: 123输入: &quot;bbbbb&quot;输出: 1解释: 无重复字符的最长子串是 &quot;b&quot;，其长度为 1。 示例 3: 1234输入: &quot;pwwkew&quot;输出: 3解释: 无重复字符的最长子串是 &quot;wke&quot;，其长度为 3。请注意，答案必须是一个子串，&quot;pwke&quot; 是一个子序列 而不是子串。 分析这道求让我们求最长的无重复字符的子串，注意这里是子串，不是子序列，所以必须是连续的。我们先不考虑代码怎么实现，如果给一个例子中的例子”abcabcbb”，让你手动找无重复字符的子串，该怎么找。博主会一个字符一个字符的遍历，比如a，b，c，然后又出现了一个a，那么此时就应该去掉第一次出现的a，然后继续往后，又出现了一个b，则应该去掉一次出现的b，以此类推，最终发现最长的长度为3。所以说，我们需要记录之前出现过的字符，记录的方式有很多，最常见的是统计字符出现的个数，但是这道题字符出现的位置很重要，所以我们可以使用HashMap来建立字符和其出现位置之间的映射。进一步考虑，由于字符会重复出现，到底是保存所有出现的位置呢，还是只记录一个位置？我们之前手动推导的方法实际上是维护了一个滑动窗口，窗口内的都是没有重复的字符，我们需要尽可能的扩大窗口的大小。由于窗口在不停向右滑动，所以我们只关心每个字符最后出现的位置，并建立映射。窗口的右边界就是当前遍历到的字符的位置，为了求出窗口的大小，我们需要一个变量left来指向滑动窗口的左边界，这样，如果当前遍历到的字符从未出现过，那么直接扩大右边界，如果之前出现过，那么就分两种情况，在或不在滑动窗口内，如果不在滑动窗口内，那么就没事，当前字符可以加进来，如果在的话，就需要先在滑动窗口内去掉这个已经出现过的字符了，去掉的方法并不需要将左边界left一位一位向右遍历查找，由于我们的HashMap已经保存了该重复字符最后出现的位置，所以直接移动left指针就可以了。我们维护一个结果res，每次用出现过的窗口大小来更新结果res，就可以得到最终结果啦。这里我们可以建立一个256位大小的整型数组来代替HashMap，这样做的原因是ASCII表共能表示256个字符，所以可以记录所有字符，然后我们需要定义两个变量res和left，其中res用来记录最长无重复子串的长度，left指向该无重复子串左边的起始位置，然后我们遍历整个字符串，对于每一个遍历到的字符，如果哈希表中该字符串对应的值为0，说明没有遇到过该字符，则此时计算最长无重复子串，i - left +１，其中ｉ是最长无重复子串最右边的位置，left是最左边的位置，还有一种情况也需要计算最长无重复子串，就是当哈希表中的值小于left，这是由于此时出现过重复的字符，left的位置更新了，如果又遇到了新的字符，就要重新计算最长无重复子串。最后每次都要在哈希表中将当前字符对应的值赋值为i+1。 代码123456789101112131415class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int m[256] = &#123;0&#125;, res = 0, left = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; if (m[s[i]] == 0 || m[s[i]] &lt; left) &#123; res = max(res, i - left + 1); &#125; else &#123; left = m[s[i]]; &#125; m[s[i]] = i + 1; &#125; return res; &#125;&#125;; 代码运行过程以”abcabcab”`为例：（这里以a来代替a的Ascll码值） 123456判断：m[a]==0（a没出现过） res=1 更新m&#123;a&#125;=1（a出现在第1个位置）m[b]==0 res=2 更新m[b]=2（b出现在第2个位置）m[c]==0 res=3 更新m[c]=3 （c出现在第3个位置）判断：此时m[a]==1!=0，所以执行else left=m[a]（更新起始位置）再次更新m[a]=4判断：此时m[b]==2!=0，所以执行else left=m[b] m[b]=5直到最后，滑窗滑到&quot;cab&quot; 个人总结m[s[i]]中的索引是以s[i]的字符ASCII，其值为该字符在s中最后出现的位置相当于HashMap中的key=字符，value=位置 1if (m[s[i]] == 0 || m[s[i]] &lt; left) 这个判断可以理解为如果 第i个字符从未出现过，或i在之前曾经出现过，那么我们就将当前最长长度设置为从left-1到i的长度i-left+1重要的是我们要了解这个程序的逻辑结构———如何判别一个字符子串重复其次，还要理解滑窗的概念，滑窗的确定需要两个值 起始位置left，即到目前为止，不重复的第一个字符 长度res，也是最后要返回的值","tags":[{"name":"哈希","slug":"哈希","permalink":"http://www.allenmistake.top/tags/哈希/"}]},{"title":"我的第一个jekyll博客","date":"2018-11-07T17:00:00.000Z","path":"2018/11/08/my-first-jekyll-blog/","text":"我的第一个jekyll博客千辛万苦，终于搭建了自己的博客，个人感觉CSDN还是很不错的，但是有两个很明显的缺点 广告太多，而且是百度推广的，自己搜索点什么全都能在上面看见，有时候搜个蟑螂药，图片上去是蟑螂； 界面太混乱，缺少定制性； 所以我找了很多搭建个人博客的方法，其实有很多方法，有Hexo还有jekyll，最后还是选择了jekyll，jekyll还是有很多优点的 theme多，界面赏心悦目； 完美支持Github托管，上手简单； 全面支持Markdown，而且可以学到一些前端的知识； 测试第一篇博客少不了测试环节，首先，我们测试一下代码块 12345678910111213141516//这是一个测试代码class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int m[256] = &#123;0&#125;, res = 0, left = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; if (m[s[i]] == 0 || m[s[i]] &lt; left) &#123; res = max(res, i - left + 1); &#125; else &#123; left = m[s[i]]; &#125; m[s[i]] = i + 1; &#125; return res; &#125;&#125;; 然后加粗看一下效果 日后计划jekyll博客把jekyll博客功能逐渐补充完善，补充草稿功能，加入目录导航，添加个性化标签。 算法把基本功能不值得差不多了，就要开始刷Leetcode题目了，个人感觉把一些重要的加上就行了，不用每个都要分析一下。 AndroidAnroid的内容打算从寒假开始看，现在把Java基础打好，虽然本科学习了一段，但对于JVM的特性还不太清楚；而且c++底层的东西也正在学习，首先要把基础打好。 总结这是一个痛并快乐的过程，其实也没有多痛啦~只是需要督促自己学习，总之，努力努力再努力！","tags":[{"name":"其他","slug":"其他","permalink":"http://www.allenmistake.top/tags/其他/"}]}]